// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.

package jsonvalidations

import (
	"fmt"
	"validationpkg/validationutils"
)

func On_issue_Tests(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	totalResults, err := On_issueValidations(input)
	if err != nil {
		return nil, err
	}

	if !input.Config.Debug {
		for i := range totalResults {
			totalResults[i].DebugInfo = nil
		}
	}

	if input.Config.HideParentErrors {
		// Delete results with valid false and no description
		filtered := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid && r.Description == "" {
				continue
			}
			filtered = append(filtered, r)
		}
		totalResults = filtered
	}

	if input.Config.OnlyInvalid {
		res := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid {
				res = append(res, r)
			}
		}

		if len(res) == 0 {
			// Find the overall test result
			var targetSuccess *validationutils.ValidationOutput
			for i := range totalResults {
				if totalResults[i].TestName == "On_issueValidations" {
					targetSuccess = &totalResults[i]
					break
				}
			}

			if targetSuccess == nil {
				panic("Critical: Overall test result not found")
			}

			return []validationutils.ValidationOutput{*targetSuccess}, nil
		}

		return res, nil
	}

	return totalResults, nil
}

var On_issueValidations = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	scope := validationutils.GetJsonPath(input.Payload, "$", true)

	subResults := make([]validationutils.ValidationOutput, 0)
	valid := true
	configureDebugInfo := ""
	for _, testObj := range scope {
		testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("Invalid object structure in scope for test On_issueValidations")
		}

		testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

		var REQUIRED_CONTEXT_FIELDS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_FIELDS")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				var REQUIRED_CONTEXT_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_DOMAIN")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_DOMAIN","attr":"$.context.domain","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_DOMAIN",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_DOMAIN**

- $.context.domain must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_DOMAIN",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_COUNTRY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_COUNTRY")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.context.location.country.code`})
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_COUNTRY","attr":["$.context.location.country.code"],"_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_COUNTRY",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_COUNTRY**

- ["$.context.location.country.code"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_COUNTRY",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_CITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_CITY")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.context.location.city.code`})
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_CITY","attr":["$.context.location.city.code"],"_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_CITY",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_CITY**

- ["$.context.location.city.code"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_CITY",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_TRANSACTION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_TRANSACTION_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.transaction_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_TRANSACTION_ID","attr":"$.context.transaction_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_TRANSACTION_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_TRANSACTION_ID**

- $.context.transaction_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_TRANSACTION_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_MESSAGE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_MESSAGE_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.message_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_MESSAGE_ID","attr":"$.context.message_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_MESSAGE_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_MESSAGE_ID**

- $.context.message_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_MESSAGE_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_ACTION")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_ACTION","attr":"$.context.action","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_ACTION",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_ACTION**

- $.context.action must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_ACTION",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_TIMESTAMP")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.timestamp", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_TIMESTAMP","attr":"$.context.timestamp","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_TIMESTAMP",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_TIMESTAMP**

- $.context.timestamp must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_TIMESTAMP",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_VERSION")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.context.version`})
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_VERSION","attr":["$.context.version"],"_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_VERSION",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_VERSION**

- ["$.context.version"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_VERSION",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BAP_URI")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BAP_URI","attr":"$.context.bap_uri","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BAP_URI",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BAP_URI**

- $.context.bap_uri must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BAP_URI",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BAP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BAP_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BAP_ID","attr":"$.context.bap_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BAP_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BAP_ID**

- $.context.bap_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BAP_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BPP_URI")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BPP_URI","attr":"$.context.bpp_uri","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BPP_URI",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BPP_URI**

- $.context.bpp_uri must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BPP_URI",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BPP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BPP_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BPP_ID","attr":"$.context.bpp_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BPP_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BPP_ID**

- $.context.bpp_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BPP_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_TTL")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_TTL","attr":"$.context.ttl","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_TTL",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_TTL**

- $.context.ttl must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_TTL",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var VALID_CONTEXT_COUNTRY_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test VALID_CONTEXT_COUNTRY_CODE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.country", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"VALID_CONTEXT_COUNTRY_CODE","attr":"$.context.country","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "VALID_CONTEXT_COUNTRY_CODE",
								Valid:    false,
								Code:     30000,
								Description: `#### **VALID_CONTEXT_COUNTRY_CODE**

- $.context.country must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "VALID_CONTEXT_COUNTRY_CODE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					REQUIRED_CONTEXT_DOMAIN,
					REQUIRED_CONTEXT_COUNTRY,
					REQUIRED_CONTEXT_CITY,
					REQUIRED_CONTEXT_TRANSACTION_ID,
					REQUIRED_CONTEXT_MESSAGE_ID,
					REQUIRED_CONTEXT_ACTION,
					REQUIRED_CONTEXT_TIMESTAMP,
					REQUIRED_CONTEXT_VERSION,
					REQUIRED_CONTEXT_BAP_URI,
					REQUIRED_CONTEXT_BAP_ID,
					REQUIRED_CONTEXT_BPP_URI,
					REQUIRED_CONTEXT_BPP_ID,
					REQUIRED_CONTEXT_TTL,
					VALID_CONTEXT_COUNTRY_CODE,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "REQUIRED_CONTEXT_FIELDS",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var ON_ISSUE_VALIDATION_VERSION_200 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$.message.issue.actions", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test ON_ISSUE_VALIDATION_VERSION_200")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				action := validationutils.StringSliceToInterface([]string{`on_issue`})
				validationutils.UnusedFunction(action)

				var REQUIRED_MESSAGE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_ID","attr":"$.message.issue.id","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_ID**

- $.message.issue.id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_STATUS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_STATUS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.status", true)
						validationutils.UnusedFunction(attr)
						enumList := validationutils.StringSliceToInterface([]string{`OPEN`, `CLOSED`, `PROCESSING`, `RESOLVED`, `NEED_MORE_INFO`, `INFO_PROVIDED`})
						validationutils.UnusedFunction(enumList)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := ((validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, enumList))) && (validationutils.AreUnique(attr))

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_STATUS","attr":"$.message.issue.status","_RETURN_":"attr are present && attr all in enumList && attr are unique","enumList":["OPEN","CLOSED","PROCESSING","RESOLVED","NEED_MORE_INFO","INFO_PROVIDED"],"action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_STATUS",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_STATUS**

**All of the following must be true:**
  - **All of the following must be true:**
    - $.message.issue.status must be present in the payload
    - All elements of $.message.issue.status must be in ["OPEN", "CLOSED", "PROCESSING", "RESOLVED", "NEED_MORE_INFO", "INFO_PROVIDED"]
  - All values of $.message.issue.status are unique`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_STATUS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_LEVEL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_LEVEL")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.level", true)
						validationutils.UnusedFunction(attr)
						enumList := validationutils.StringSliceToInterface([]string{`ISSUE`, `GREVIENCE`, `DISPUTE`})
						validationutils.UnusedFunction(enumList)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, enumList))

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_LEVEL","attr":"$.message.issue.level","_RETURN_":"attr are present && attr all in enumList","enumList":["ISSUE","GREVIENCE","DISPUTE"],"action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_LEVEL",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_LEVEL**

**All of the following must be true:**
  - $.message.issue.level must be present in the payload
  - All elements of $.message.issue.level must be in ["ISSUE", "GREVIENCE", "DISPUTE"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_LEVEL",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_CREATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_CREATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.created_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_CREATED_AT","attr":"$.message.issue.created_at","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_CREATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_CREATED_AT**

- $.message.issue.created_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_CREATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_UPDATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_UPDATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.updated_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_UPDATED_AT","attr":"$.message.issue.updated_at","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_UPDATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_UPDATED_AT**

- $.message.issue.updated_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_UPDATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_REF_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_REF_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.refs[*].ref_id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_REF_ID","attr":"$.message.issue.refs[*].ref_id","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_REF_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_REF_ID**

- $.message.issue.refs[*].ref_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_REF_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_REF_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_REF_TYPE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.refs[*].ref_type", true)
						validationutils.UnusedFunction(attr)
						enumList := validationutils.StringSliceToInterface([]string{`ORDER`, `ITEM`, `FULFILLMENT`, `TRANSACTION_ID`, `MESSAGE_ID`, `PROVIDER`, `COMPLAINT`, `ACTION`, `PAYMENT`, `CUSTOMER`, `AGENT`})
						validationutils.UnusedFunction(enumList)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, enumList))

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_REF_TYPE","attr":"$.message.issue.refs[*].ref_type","_RETURN_":"attr are present && attr all in enumList","enumList":["ORDER","ITEM","FULFILLMENT","TRANSACTION_ID","MESSAGE_ID","PROVIDER","COMPLAINT","ACTION","PAYMENT","CUSTOMER","AGENT"],"action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_REF_TYPE",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_REF_TYPE**

**All of the following must be true:**
  - $.message.issue.refs[*].ref_type must be present in the payload
  - All elements of $.message.issue.refs[*].ref_type must be in ["ORDER", "ITEM", "FULFILLMENT", "TRANSACTION_ID", "MESSAGE_ID", "PROVIDER", "COMPLAINT", "ACTION", "PAYMENT", "CUSTOMER", "AGENT"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_REF_TYPE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_EXPECTED_RESPONSE_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_EXPECTED_RESPONSE_TIME")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.message.issue.expected_response_time.duration`})
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_EXPECTED_RESPONSE_TIME","attr":["$.message.issue.expected_response_time.duration"],"_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_EXPECTED_RESPONSE_TIME",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_EXPECTED_RESPONSE_TIME**

- ["$.message.issue.expected_response_time.duration"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_EXPECTED_RESPONSE_TIME",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_EXPECTED_RESOLUTION_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_EXPECTED_RESOLUTION_TIME")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.message.issue.expected_resolution_time.duration`})
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_EXPECTED_RESOLUTION_TIME","attr":["$.message.issue.expected_resolution_time.duration"],"_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_EXPECTED_RESOLUTION_TIME",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_EXPECTED_RESOLUTION_TIME**

- ["$.message.issue.expected_resolution_time.duration"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_EXPECTED_RESOLUTION_TIME",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_ID_10 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_ID_10")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_ID_10","attr":"$.message.issue.actors[*].id","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_ID_10",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_ID_10**

- $.message.issue.actors[*].id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_ID_10",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_TYPE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].type", true)
						validationutils.UnusedFunction(attr)
						enumList := validationutils.StringSliceToInterface([]string{`INTERFACING_NP`, `COUNTERPARTY_NP`, `CASCADED_NP`, `PROVIDER`, `AGENT`, `CUSTOMER`, `INTERFACING_NP_GRO`, `COUNTERPARTY_NP_GRO`, `CASCADED_NP_GRO`, `CONSUMER`})
						validationutils.UnusedFunction(enumList)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, enumList))

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_TYPE","attr":"$.message.issue.actors[*].type","_RETURN_":"attr are present && attr all in enumList","enumList":["INTERFACING_NP","COUNTERPARTY_NP","CASCADED_NP","PROVIDER","AGENT","CUSTOMER","INTERFACING_NP_GRO","COUNTERPARTY_NP_GRO","CASCADED_NP_GRO","CONSUMER"],"action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_TYPE",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_TYPE**

**All of the following must be true:**
  - $.message.issue.actors[*].type must be present in the payload
  - All elements of $.message.issue.actors[*].type must be in ["INTERFACING_NP", "COUNTERPARTY_NP", "CASCADED_NP", "PROVIDER", "AGENT", "CUSTOMER", "INTERFACING_NP_GRO", "COUNTERPARTY_NP_GRO", "CASCADED_NP_GRO", "CONSUMER"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_TYPE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_NAME_13 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_NAME_13")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].info.person.name", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_NAME_13","attr":"$.message.issue.actors[*].info.person.name","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_NAME_13",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_NAME_13**

- $.message.issue.actors[*].info.person.name must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_NAME_13",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_PHONE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_PHONE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].info.contact.phone", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_PHONE","attr":"$.message.issue.actors[*].info.contact.phone","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_PHONE",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_PHONE**

- $.message.issue.actors[*].info.contact.phone must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_PHONE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_EMAIL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_EMAIL")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].info.contact.email", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_EMAIL","attr":"$.message.issue.actors[*].info.contact.email","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_EMAIL",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_EMAIL**

- $.message.issue.actors[*].info.contact.email must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_EMAIL",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_ID_25 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_ID_25")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actions[*].id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_ID_25","attr":"$.message.issue.actions[*].id","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_ID_25",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_ID_25**

- $.message.issue.actions[*].id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_ID_25",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_CODE_26 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_CODE_26")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actions[*].descriptor.code", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_CODE_26","attr":"$.message.issue.actions[*].descriptor.code","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_CODE_26",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_CODE_26**

- $.message.issue.actions[*].descriptor.code must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_CODE_26",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_SHORT_DESC_27 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_SHORT_DESC_27")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actions[*].descriptor.short_desc", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_SHORT_DESC_27","attr":"$.message.issue.actions[*].descriptor.short_desc","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_SHORT_DESC_27",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_SHORT_DESC_27**

- $.message.issue.actions[*].descriptor.short_desc must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_SHORT_DESC_27",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_UPDATED_AT_28 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_UPDATED_AT_28")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actions[*].updated_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_UPDATED_AT_28","attr":"$.message.issue.actions[*].updated_at","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_UPDATED_AT_28",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_UPDATED_AT_28**

- $.message.issue.actions[*].updated_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_UPDATED_AT_28",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_ACTION_BY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_ACTION_BY")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actions[*].action_by", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_ACTION_BY","attr":"$.message.issue.actions[*].action_by","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_ACTION_BY",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_ACTION_BY**

- $.message.issue.actions[*].action_by must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_ACTION_BY",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					REQUIRED_MESSAGE_ID,
					REQUIRED_MESSAGE_STATUS,
					REQUIRED_MESSAGE_LEVEL,
					REQUIRED_MESSAGE_CREATED_AT,
					REQUIRED_MESSAGE_UPDATED_AT,
					REQUIRED_MESSAGE_REF_ID,
					REQUIRED_MESSAGE_REF_TYPE,
					REQUIRED_EXPECTED_RESPONSE_TIME,
					REQUIRED_EXPECTED_RESOLUTION_TIME,
					REQUIRED_MESSAGE_ID_10,
					REQUIRED_MESSAGE_TYPE,
					REQUIRED_MESSAGE_NAME_13,
					REQUIRED_MESSAGE_PHONE,
					REQUIRED_MESSAGE_EMAIL,
					REQUIRED_MESSAGE_ID_25,
					REQUIRED_MESSAGE_CODE_26,
					REQUIRED_MESSAGE_SHORT_DESC_27,
					REQUIRED_MESSAGE_UPDATED_AT_28,
					REQUIRED_MESSAGE_ACTION_BY,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "ON_ISSUE_VALIDATION_VERSION_200",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var ON_ISSUE_VALIDATION_VERSION_100 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$.message.issue.issue_actions", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test ON_ISSUE_VALIDATION_VERSION_100")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				action := validationutils.StringSliceToInterface([]string{`on_issue`})
				validationutils.UnusedFunction(action)

				var REQUIRED_ISSUE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_ID","attr":"$.message.issue.id","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_ISSUE_ID**

- $.message.issue.id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_ISSUE_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESPONDENT_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESPONDENT_ACTION")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.respondent_actions[*].respondent_action", true)
						validationutils.UnusedFunction(attr)
						enumList := validationutils.StringSliceToInterface([]string{`OPEN`, `PROCESSING`, `RESOLVED`, `CLOSED`, `INFO_PROVIDED`, `NEED_MORE_INFO`})
						validationutils.UnusedFunction(enumList)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, enumList))

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESPONDENT_ACTION","attr":"$.message.issue.issue_actions.respondent_actions[*].respondent_action","_RETURN_":"attr are present && attr all in enumList","enumList":["OPEN","PROCESSING","RESOLVED","CLOSED","INFO_PROVIDED","NEED_MORE_INFO"],"action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESPONDENT_ACTION",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESPONDENT_ACTION**

**All of the following must be true:**
  - $.message.issue.issue_actions.respondent_actions[*].respondent_action must be present in the payload
  - All elements of $.message.issue.issue_actions.respondent_actions[*].respondent_action must be in ["OPEN", "PROCESSING", "RESOLVED", "CLOSED", "INFO_PROVIDED", "NEED_MORE_INFO"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESPONDENT_ACTION",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESPONDENT_SHORT_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESPONDENT_SHORT_DESC")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.respondent_actions[*].short_desc", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESPONDENT_SHORT_DESC","attr":"$.message.issue.issue_actions.respondent_actions[*].short_desc","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESPONDENT_SHORT_DESC",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESPONDENT_SHORT_DESC**

- $.message.issue.issue_actions.respondent_actions[*].short_desc must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESPONDENT_SHORT_DESC",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESPONDENT_UPDATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESPONDENT_UPDATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.respondent_actions[*].updated_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESPONDENT_UPDATED_AT","attr":"$.message.issue.issue_actions.respondent_actions[*].updated_at","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESPONDENT_UPDATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESPONDENT_UPDATED_AT**

- $.message.issue.issue_actions.respondent_actions[*].updated_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESPONDENT_UPDATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESPONDENT_UPDATED_BY_PERSON = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESPONDENT_UPDATED_BY_PERSON")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.respondent_actions[*].updated_by.person.name", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESPONDENT_UPDATED_BY_PERSON","attr":"$.message.issue.issue_actions.respondent_actions[*].updated_by.person.name","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESPONDENT_UPDATED_BY_PERSON",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESPONDENT_UPDATED_BY_PERSON**

- $.message.issue.issue_actions.respondent_actions[*].updated_by.person.name must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESPONDENT_UPDATED_BY_PERSON",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESPONDENT_UPDATED_BY_ORG = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESPONDENT_UPDATED_BY_ORG")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.respondent_actions[*].updated_by.org.name", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESPONDENT_UPDATED_BY_ORG","attr":"$.message.issue.issue_actions.respondent_actions[*].updated_by.org.name","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESPONDENT_UPDATED_BY_ORG",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESPONDENT_UPDATED_BY_ORG**

- $.message.issue.issue_actions.respondent_actions[*].updated_by.org.name must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESPONDENT_UPDATED_BY_ORG",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_ISSUE_CREATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_CREATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.created_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_CREATED_AT","attr":"$.message.issue.created_at","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_CREATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_ISSUE_CREATED_AT**

- $.message.issue.created_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_ISSUE_CREATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_ISSUE_UPDATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_UPDATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.updated_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_UPDATED_AT","attr":"$.message.issue.updated_at","_RETURN_":"attr are present","action":["on_issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_UPDATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_ISSUE_UPDATED_AT**

- $.message.issue.updated_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_ISSUE_UPDATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					REQUIRED_ISSUE_ID,
					REQUIRED_RESPONDENT_ACTION,
					REQUIRED_RESPONDENT_SHORT_DESC,
					REQUIRED_RESPONDENT_UPDATED_AT,
					REQUIRED_RESPONDENT_UPDATED_BY_PERSON,
					REQUIRED_RESPONDENT_UPDATED_BY_ORG,
					REQUIRED_ISSUE_CREATED_AT,
					REQUIRED_ISSUE_UPDATED_AT,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "ON_ISSUE_VALIDATION_VERSION_100",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}

		var testFunctions = validationutils.TestFunctionArray{
			REQUIRED_CONTEXT_FIELDS,
			ON_ISSUE_VALIDATION_VERSION_200,
			ON_ISSUE_VALIDATION_VERSION_100,
		}

		allResults := make([]validationutils.ValidationOutput, 0)

		for _, testFunc := range testFunctions {
			results, err := testFunc(input)
			if err != nil {
				return nil, err
			}
			allResults = append(allResults, results...)
		}

		subResults = allResults
		// if all subResults are valid, then valid is true
		valid = true
		for _, res := range subResults {
			if !res.Valid {
				valid = false
				break
			}
		}

		configureDebugInfo = `NESTED_TEST_OBJECT`

		delete(testObjMap, "_EXTERNAL")
	}

	result := validationutils.ValidationOutput{
		TestName: "On_issueValidations",
		Valid:    valid,
		Code:     0,
		DebugInfo: &validationutils.DebugInfo{
			FedConfig: configureDebugInfo,
		},
	}

	if valid {
		result.Code = 200
	} else {
		result.Code = 30000
	}

	results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
	results = append(results, result)
	results = append(results, subResults...)

	return results, nil
}
