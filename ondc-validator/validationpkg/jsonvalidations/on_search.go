// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.

package jsonvalidations

import (
	"fmt"
	"validationpkg/validationutils"
)

func On_search_Tests(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	totalResults, err := On_searchValidations(input)
	if err != nil {
		return nil, err
	}

	if !input.Config.Debug {
		for i := range totalResults {
			totalResults[i].DebugInfo = nil
		}
	}

	if input.Config.HideParentErrors {
		// Delete results with valid false and no description
		filtered := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid && r.Description == "" {
				continue
			}
			filtered = append(filtered, r)
		}
		totalResults = filtered
	}

	if input.Config.OnlyInvalid {
		res := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid {
				res = append(res, r)
			}
		}

		if len(res) == 0 {
			// Find the overall test result
			var targetSuccess *validationutils.ValidationOutput
			for i := range totalResults {
				if totalResults[i].TestName == "On_searchValidations" {
					targetSuccess = &totalResults[i]
					break
				}
			}

			if targetSuccess == nil {
				panic("Critical: Overall test result not found")
			}

			return []validationutils.ValidationOutput{*targetSuccess}, nil
		}

		return res, nil
	}

	return totalResults, nil
}

var On_searchValidations = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	scope := validationutils.GetJsonPath(input.Payload, "$", true)

	subResults := make([]validationutils.ValidationOutput, 0)
	valid := true
	configureDebugInfo := ""
	for _, testObj := range scope {
		testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("Invalid object structure in scope for test On_searchValidations")
		}

		testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

		var ON_SEARCH_CONTEXT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test ON_SEARCH_CONTEXT")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				action := validationutils.StringSliceToInterface([]string{`on_search`})
				validationutils.UnusedFunction(action)

				var CONTEXT_REQUIRED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CONTEXT_REQUIRED_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_DOMAIN")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_DOMAIN","attr":"$.context.domain","_RETURN_":"attr are present","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_DOMAIN",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_DOMAIN**

- $.context.domain must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_DOMAIN",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_ACTION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_ACTION","attr":"$.context.action","_RETURN_":"attr are present","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_ACTION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_ACTION**

- $.context.action must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_ACTION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_COUNTRY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_COUNTRY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.country", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_COUNTRY","attr":"$.context.country","_RETURN_":"attr are present","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_COUNTRY",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_COUNTRY**

- $.context.country must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_COUNTRY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_CONTEXT_CODE_14 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_CODE_14")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.city", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^(std:\d{3,5}|\*)$`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_CODE_14","attr":"$.context.city","reg":["^(std:\\\\d{3,5}|\\\\*)$"],"_RETURN_":"attr follow regex reg","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_CONTEXT_CODE_14",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_CONTEXT_CODE_14**

- All elements of $.context.city must follow every regex in ["^(std:\\d{3,5}|\\*)$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_CODE_14",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_VERSION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.core_version", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_VERSION","attr":"$.context.core_version","_RETURN_":"attr are present","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_VERSION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_VERSION**

- $.context.core_version must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_VERSION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BAP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BAP_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BAP_ID","attr":"$.context.bap_id","_RETURN_":"attr are present","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BAP_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BAP_ID**

- $.context.bap_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BAP_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BAP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BAP_URI","attr":"$.context.bap_uri","_RETURN_":"attr are present","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BAP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BAP_URI**

- $.context.bap_uri must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BAP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BPP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BPP_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BPP_ID","search":["search"],"attr":"$.context.bpp_id","_CONTINUE_":"(action equal to search)","_RETURN_":"attr are present","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BPP_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BPP_ID**

- $.context.bpp_id must be present in the payload

> **Skip if:**
>
>     - ["on_search"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BPP_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BPP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BPP_URI","search":["search"],"_CONTINUE_":"(action equal to search)","attr":"$.context.bpp_uri","_RETURN_":"attr are present","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BPP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BPP_URI**

- $.context.bpp_uri must be present in the payload

> **Skip if:**
>
>     - ["on_search"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BPP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TRANSACTION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TRANSACTION_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.transaction_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TRANSACTION_ID","attr":"$.context.transaction_id","_RETURN_":"attr are present","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TRANSACTION_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TRANSACTION_ID**

- $.context.transaction_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TRANSACTION_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_MESSAGE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_MESSAGE_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.message_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_MESSAGE_ID","attr":"$.context.message_id","_RETURN_":"attr are present","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_MESSAGE_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_MESSAGE_ID**

- $.context.message_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_MESSAGE_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TIMESTAMP")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.timestamp", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TIMESTAMP","attr":"$.context.timestamp","reg":["^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}Z$"],"_RETURN_":"attr follow regex reg","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TIMESTAMP",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TIMESTAMP**

- All elements of $.context.timestamp must follow every regex in ["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TIMESTAMP",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
								validationutils.UnusedFunction(attr)
								optional_vars := validationutils.StringSliceToInterface([]string{`on_search`, `on_select`, `on_confirm`, `on_init`, `on_cancel`, `on_track`, `on_update`, `on_status`})
								validationutils.UnusedFunction(optional_vars)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.AllIn(action, optional_vars)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TTL","attr":"$.context.ttl","optional_vars":["on_search","on_select","on_confirm","on_init","on_cancel","on_track","on_update","on_status"],"_CONTINUE_":"(action all in optional_vars)","_RETURN_":"attr are present","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TTL**

- $.context.ttl must be present in the payload

> **Skip if:**
>
>     - all elements of ["on_search"] are in ["on_search", "on_select", "on_confirm", "on_init", "on_cancel", "on_track", "on_update", "on_status"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CONTEXT_REQUIRED_DOMAIN,
							CONTEXT_REQUIRED_ACTION,
							CONTEXT_REQUIRED_COUNTRY,
							REQUIRED_CONTEXT_CODE_14,
							CONTEXT_REQUIRED_VERSION,
							CONTEXT_REQUIRED_BAP_ID,
							CONTEXT_REQUIRED_BAP_URI,
							CONTEXT_REQUIRED_BPP_ID,
							CONTEXT_REQUIRED_BPP_URI,
							CONTEXT_REQUIRED_TRANSACTION_ID,
							CONTEXT_REQUIRED_MESSAGE_ID,
							CONTEXT_REQUIRED_TIMESTAMP,
							CONTEXT_REQUIRED_TTL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CONTEXT_REQUIRED",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var CONTEXT_ENUM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CONTEXT_ENUM_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_DOMAIN")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								domain := validationutils.StringSliceToInterface([]string{`ONDC:RET10`})
								validationutils.UnusedFunction(domain)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.EqualTo(attr, domain)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_DOMAIN","domain":["ONDC:RET10"],"attr":"$.context.domain","_RETURN_":"attr equal to domain","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_DOMAIN",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_DOMAIN**

- $.context.domain must equal ["ONDC:RET10"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_DOMAIN",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_ENUM_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_ACTION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.EqualTo(attr, action)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_ACTION","attr":"$.context.action","_RETURN_":"attr equal to action","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_ACTION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_ACTION**

- $.context.action must equal ["on_search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_ACTION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_ENUM_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_VERSION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								version := validationutils.StringSliceToInterface([]string{`1.2.5`})
								validationutils.UnusedFunction(version)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.core_version", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.AllIn(attr, version)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_VERSION","version":["1.2.5"],"attr":"$.context.core_version","_RETURN_":"attr all in version","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_VERSION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_VERSION**

- All elements of $.context.core_version must be in ["1.2.5"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_VERSION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_BAP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^https?\:\/\/`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_BAP_URI","attr":"$.context.bap_uri","reg":["^https?\\:\\/\\/"],"_RETURN_":"attr follow regex reg","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_BAP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_BAP_URI**

- All elements of $.context.bap_uri must follow every regex in ["^https?\:\/\/"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_BAP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_BPP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^https?\:\/\/`})
								validationutils.UnusedFunction(reg)
								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_BPP_URI","attr":"$.context.bpp_uri","reg":["^https?\\:\\/\\/"],"_RETURN_":"attr follow regex reg","search":["search"],"_CONTINUE_":"(action equal to search)","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_BPP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_BPP_URI**

- All elements of $.context.bpp_uri must follow every regex in ["^https?\:\/\/"]

> **Skip if:**
>
>     - ["on_search"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_BPP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^P(?=\d|T)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$`})
								validationutils.UnusedFunction(reg)
								optional_vars := validationutils.StringSliceToInterface([]string{`on_search`, `on_select`, `on_confirm`, `on_init`, `on_cancel`, `on_track`, `on_update`, `on_status`})
								validationutils.UnusedFunction(optional_vars)
								action := validationutils.StringSliceToInterface([]string{`on_search`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.AllIn(action, optional_vars)
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_TTL","attr":"$.context.ttl","reg":["^P(?=\\\\d|T)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?(\\\\d+S)?)?$"],"optional_vars":["on_search","on_select","on_confirm","on_init","on_cancel","on_track","on_update","on_status"],"_CONTINUE_":"(action all in optional_vars)","_RETURN_":"attr follow regex reg","action":["on_search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_TTL**

- All elements of $.context.ttl must follow every regex in ["^P(?=\\d|T)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$"]

> **Skip if:**
>
>     - all elements of ["on_search"] are in ["on_search", "on_select", "on_confirm", "on_init", "on_cancel", "on_track", "on_update", "on_status"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CONTEXT_ENUM_DOMAIN,
							CONTEXT_ENUM_ACTION,
							CONTEXT_ENUM_VERSION,
							CONTEXT_REG_BAP_URI,
							CONTEXT_REG_BPP_URI,
							CONTEXT_REG_TTL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CONTEXT_ENUM",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					CONTEXT_REQUIRED,
					CONTEXT_ENUM,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "ON_SEARCH_CONTEXT",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var ON_SEARCH_CATALOG = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test ON_SEARCH_CATALOG")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				var_star := validationutils.StringSliceToInterface([]string{`*`})
				validationutils.UnusedFunction(var_star)
				verification_attr := validationutils.GetJsonPath(testObjMap, "$.context.city", true)
				validationutils.UnusedFunction(verification_attr)

				skipCheck := validationutils.EqualTo(verification_attr, var_star)
				if skipCheck {
					continue
				}

				var CATALOG_BPP_DESCRIPTOR = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CATALOG_BPP_DESCRIPTOR")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var BPP_DESCRIPTOR_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BPP_DESCRIPTOR_NAME")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/descriptor'].name", true)
								validationutils.UnusedFunction(attr)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"BPP_DESCRIPTOR_NAME","attr":"$.message.catalog['bpp/descriptor'].name","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "BPP_DESCRIPTOR_NAME",
										Valid:    false,
										Code:     30000,
										Description: `#### **BPP_DESCRIPTOR_NAME**

- $.message.catalog['bpp/descriptor'].name must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BPP_DESCRIPTOR_NAME",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var BPP_DESCRIPTOR_SYMBOL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BPP_DESCRIPTOR_SYMBOL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/descriptor'].symbol", true)
								validationutils.UnusedFunction(attr)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"BPP_DESCRIPTOR_SYMBOL","attr":"$.message.catalog['bpp/descriptor'].symbol","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "BPP_DESCRIPTOR_SYMBOL",
										Valid:    false,
										Code:     30000,
										Description: `#### **BPP_DESCRIPTOR_SYMBOL**

- $.message.catalog['bpp/descriptor'].symbol must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BPP_DESCRIPTOR_SYMBOL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var BPP_DESCRIPTOR_SHORT_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BPP_DESCRIPTOR_SHORT_DESC")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/descriptor'].short_desc", true)
								validationutils.UnusedFunction(attr)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"BPP_DESCRIPTOR_SHORT_DESC","attr":"$.message.catalog['bpp/descriptor'].short_desc","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "BPP_DESCRIPTOR_SHORT_DESC",
										Valid:    false,
										Code:     30000,
										Description: `#### **BPP_DESCRIPTOR_SHORT_DESC**

- $.message.catalog['bpp/descriptor'].short_desc must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BPP_DESCRIPTOR_SHORT_DESC",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var BPP_DESCRIPTOR_LONG_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BPP_DESCRIPTOR_LONG_DESC")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/descriptor'].long_desc", true)
								validationutils.UnusedFunction(attr)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"BPP_DESCRIPTOR_LONG_DESC","attr":"$.message.catalog['bpp/descriptor'].long_desc","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "BPP_DESCRIPTOR_LONG_DESC",
										Valid:    false,
										Code:     30000,
										Description: `#### **BPP_DESCRIPTOR_LONG_DESC**

- $.message.catalog['bpp/descriptor'].long_desc must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BPP_DESCRIPTOR_LONG_DESC",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var BPP_DESCRIPTOR_IMAGES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BPP_DESCRIPTOR_IMAGES")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/descriptor'].images[*]", true)
								validationutils.UnusedFunction(attr)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"BPP_DESCRIPTOR_IMAGES","attr":"$.message.catalog['bpp/descriptor'].images[*]","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "BPP_DESCRIPTOR_IMAGES",
										Valid:    false,
										Code:     30000,
										Description: `#### **BPP_DESCRIPTOR_IMAGES**

- $.message.catalog['bpp/descriptor'].images[*] must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BPP_DESCRIPTOR_IMAGES",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var BPP_DESCRIPTOR_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BPP_DESCRIPTOR_TAGS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var TAGS_BPP_DESCRIPTORS_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BPP_DESCRIPTORS_VALID_TAGS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/descriptor'].tags[*].code", true)
										validationutils.UnusedFunction(attr)
										valid := validationutils.StringSliceToInterface([]string{`bpp_terms`})
										validationutils.UnusedFunction(valid)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.AllIn(attr, valid)

										configureDebugInfo = `{"_NAME_":"TAGS_BPP_DESCRIPTORS_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/descriptor'].tags[*].code","valid":["bpp_terms"],"_RETURN_":"attr all in valid","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "TAGS_BPP_DESCRIPTORS_VALID_TAGS",
												Valid:    false,
												Code:     30000,
												Description: `#### **TAGS_BPP_DESCRIPTORS_VALID_TAGS**

- All elements of $.message.catalog['bpp/descriptor'].tags[*].code must be in ["bpp_terms"]

> **Skip if:**
>
>     - $.message.catalog['bpp/descriptor'].tags[*].code is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_BPP_DESCRIPTORS_VALID_TAGS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_BPP_DESCRIPTORS_VALID_ENUMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BPP_DESCRIPTORS_VALID_ENUMS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[*].code", true)
										validationutils.UnusedFunction(attr)
										valid := validationutils.StringSliceToInterface([]string{`np_type`, `accept_bap_terms`, `collect_payment`})
										validationutils.UnusedFunction(valid)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.AllIn(attr, valid)

										configureDebugInfo = `{"_NAME_":"TAGS_BPP_DESCRIPTORS_VALID_ENUMS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[*].code","valid":["np_type","accept_bap_terms","collect_payment"],"_RETURN_":"attr all in valid","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "TAGS_BPP_DESCRIPTORS_VALID_ENUMS",
												Valid:    false,
												Code:     30000,
												Description: `#### **TAGS_BPP_DESCRIPTORS_VALID_ENUMS**

- All elements of $.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[*].code must be in ["np_type", "accept_bap_terms", "collect_payment"]

> **Skip if:**
>
>     - $.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[*].code is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_BPP_DESCRIPTORS_VALID_ENUMS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var BPP_DESCRIPTOR_TAGS_BPP_TERMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test BPP_DESCRIPTOR_TAGS_BPP_TERMS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_BPP_TERMS_NP_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BPP_TERMS_NP_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='np_type')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`ISN`, `MSN`})
												validationutils.UnusedFunction(var_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_BPP_TERMS_NP_TYPE","attr":"$.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='np_type')].value","var_enum":["ISN","MSN"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_BPP_TERMS_NP_TYPE",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_BPP_TERMS_NP_TYPE**

- All elements of $.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='np_type')].value must be in ["ISN", "MSN"]`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_BPP_TERMS_NP_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_BPP_TERMS_ACCEPT_BAP_TERMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BPP_TERMS_ACCEPT_BAP_TERMS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='accept_bap_terms')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`Y`, `N`})
												validationutils.UnusedFunction(var_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_BPP_TERMS_ACCEPT_BAP_TERMS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='accept_bap_terms')].value","var_enum":["Y","N"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_BPP_TERMS_ACCEPT_BAP_TERMS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_BPP_TERMS_ACCEPT_BAP_TERMS**

- All elements of $.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='accept_bap_terms')].value must be in ["Y", "N"]

> **Skip if:**
>
>     - $.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='accept_bap_terms')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_BPP_TERMS_ACCEPT_BAP_TERMS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_BPP_TERMS_COLLECT_PAYMENT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BPP_TERMS_COLLECT_PAYMENT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='collect_payment')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`Y`, `N`})
												validationutils.UnusedFunction(var_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_BPP_TERMS_COLLECT_PAYMENT","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='collect_payment')].value","var_enum":["Y","N"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_BPP_TERMS_COLLECT_PAYMENT",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_BPP_TERMS_COLLECT_PAYMENT**

- All elements of $.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='collect_payment')].value must be in ["Y", "N"]

> **Skip if:**
>
>     - $.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='collect_payment')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_BPP_TERMS_COLLECT_PAYMENT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_BPP_TERMS_MANDATORY_ARBITRATION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BPP_TERMS_MANDATORY_ARBITRATION")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='mandatory_arbitration')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`true`, `false`})
												validationutils.UnusedFunction(var_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_BPP_TERMS_MANDATORY_ARBITRATION","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='mandatory_arbitration')].value","var_enum":["true","false"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_BPP_TERMS_MANDATORY_ARBITRATION",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_BPP_TERMS_MANDATORY_ARBITRATION**

- All elements of $.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='mandatory_arbitration')].value must be in ["true", "false"]

> **Skip if:**
>
>     - $.message.catalog['bpp/descriptor'].tags[?(@.code=='bpp_terms')].list[?(@.code=='mandatory_arbitration')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_BPP_TERMS_MANDATORY_ARBITRATION",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_BPP_TERMS_NP_TYPE,
											TAGS_BPP_TERMS_ACCEPT_BAP_TERMS,
											TAGS_BPP_TERMS_COLLECT_PAYMENT,
											TAGS_BPP_TERMS_MANDATORY_ARBITRATION,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "BPP_DESCRIPTOR_TAGS_BPP_TERMS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									TAGS_BPP_DESCRIPTORS_VALID_TAGS,
									TAGS_BPP_DESCRIPTORS_VALID_ENUMS,
									BPP_DESCRIPTOR_TAGS_BPP_TERMS,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BPP_DESCRIPTOR_TAGS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							BPP_DESCRIPTOR_NAME,
							BPP_DESCRIPTOR_SYMBOL,
							BPP_DESCRIPTOR_SHORT_DESC,
							BPP_DESCRIPTOR_LONG_DESC,
							BPP_DESCRIPTOR_IMAGES,
							BPP_DESCRIPTOR_TAGS,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CATALOG_BPP_DESCRIPTOR",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var CATALOG_BPP_PROVIDERS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CATALOG_BPP_PROVIDERS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var PROVIDERS_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].id", true)
								validationutils.UnusedFunction(attr)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"PROVIDERS_ID","attr":"$.message.catalog['bpp/providers'][*].id","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PROVIDERS_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **PROVIDERS_ID**

- $.message.catalog['bpp/providers'][*].id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_RATING = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_RATING")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].rating", true)
								validationutils.UnusedFunction(attr)
								rating_reg := validationutils.StringSliceToInterface([]string{`^(?:[1-4](?:\.\d+)?|5(?:\.0+)?|\s*)$`})
								validationutils.UnusedFunction(rating_reg)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, rating_reg)

								configureDebugInfo = `{"_NAME_":"PROVIDERS_RATING","attr":"$.message.catalog['bpp/providers'][*].rating","_CONTINUE_":"!(attr are present)","rating_reg":["^(?:[1-4](?:\\\\.\\\\d+)?|5(?:\\\\.0+)?|\\\\s*)$"],"_RETURN_":"attr follow regex rating_reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PROVIDERS_RATING",
										Valid:    false,
										Code:     30000,
										Description: `#### **PROVIDERS_RATING**

- All elements of $.message.catalog['bpp/providers'][*].rating must follow every regex in ["^(?:[1-4](?:\\.\\d+)?|5(?:\\.0+)?|\\s*)$"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].rating is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_RATING",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_TIME_LABEL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_TIME_LABEL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].time.label", true)
								validationutils.UnusedFunction(attr)
								var_enum := validationutils.StringSliceToInterface([]string{`enable`, `disable`})
								validationutils.UnusedFunction(var_enum)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								validate := validationutils.AllIn(attr, var_enum)

								configureDebugInfo = `{"_NAME_":"PROVIDERS_TIME_LABEL","attr":"$.message.catalog['bpp/providers'][*].time.label","var_enum":["enable","disable"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PROVIDERS_TIME_LABEL",
										Valid:    false,
										Code:     30000,
										Description: `#### **PROVIDERS_TIME_LABEL**

- All elements of $.message.catalog['bpp/providers'][*].time.label must be in ["enable", "disable"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_TIME_LABEL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_TIME_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_TIME_TIMESTAMP")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].time.timestamp", true)
								validationutils.UnusedFunction(attr)
								time_reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$`})
								validationutils.UnusedFunction(time_reg)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								validate := validationutils.FollowRegex(attr, time_reg)

								configureDebugInfo = `{"_NAME_":"PROVIDERS_TIME_TIMESTAMP","attr":"$.message.catalog['bpp/providers'][*].time.timestamp","time_reg":["^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}Z$"],"_RETURN_":"attr follow regex time_reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PROVIDERS_TIME_TIMESTAMP",
										Valid:    false,
										Code:     30000,
										Description: `#### **PROVIDERS_TIME_TIMESTAMP**

- All elements of $.message.catalog['bpp/providers'][*].time.timestamp must follow every regex in ["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_TIME_TIMESTAMP",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_TAGS_VALID_ENUMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_TAGS_VALID_ENUMS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].tags[*].code", true)
								validationutils.UnusedFunction(attr)
								var_enum := validationutils.StringSliceToInterface([]string{`timing`, `close_timing`, `serviceability`, `order_value`, `np_fees`})
								validationutils.UnusedFunction(var_enum)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								validate := validationutils.AllIn(attr, var_enum)

								configureDebugInfo = `{"_NAME_":"PROVIDERS_TAGS_VALID_ENUMS","attr":"$.message.catalog['bpp/providers'][*].tags[*].code","var_enum":["timing","close_timing","serviceability","order_value","np_fees"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PROVIDERS_TAGS_VALID_ENUMS",
										Valid:    false,
										Code:     30000,
										Description: `#### **PROVIDERS_TAGS_VALID_ENUMS**

- All elements of $.message.catalog['bpp/providers'][*].tags[*].code must be in ["timing", "close_timing", "serviceability", "order_value", "np_fees"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_TAGS_VALID_ENUMS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_FULFILLMENTS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_FULFILLMENTS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var FULFILLMENTS_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_ID")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].fulfillments[*].id", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"FULFILLMENTS_ID","attr":"$.message.catalog['bpp/providers'][*].fulfillments[*].id","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_ID",
												Valid:    false,
												Code:     30000,
												Description: `#### **FULFILLMENTS_ID**

- $.message.catalog['bpp/providers'][*].fulfillments[*].id must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_ID",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var FULFILLMENTS_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_TYPE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].fulfillments[*].type", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`Delivery`, `Self-Pickup`, `Buyer-Delivery`})
										validationutils.UnusedFunction(var_enum)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"FULFILLMENTS_TYPE","attr":"$.message.catalog['bpp/providers'][*].fulfillments[*].type","var_enum":["Delivery","Self-Pickup","Buyer-Delivery"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_TYPE",
												Valid:    false,
												Code:     30000,
												Description: `#### **FULFILLMENTS_TYPE**

- All elements of $.message.catalog['bpp/providers'][*].fulfillments[*].type must be in ["Delivery", "Self-Pickup", "Buyer-Delivery"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_TYPE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var FULFILLMENTS_CONTACT_PHONE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_CONTACT_PHONE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].fulfillments[*].contact.phone", true)
										validationutils.UnusedFunction(attr)
										phone := validationutils.StringSliceToInterface([]string{`^\d{10,11}$`})
										validationutils.UnusedFunction(phone)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.FollowRegex(attr, phone)

										configureDebugInfo = `{"_NAME_":"FULFILLMENTS_CONTACT_PHONE","attr":"$.message.catalog['bpp/providers'][*].fulfillments[*].contact.phone","phone":["^\\\\d{10,11}$"],"_RETURN_":"attr follow regex phone","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_CONTACT_PHONE",
												Valid:    false,
												Code:     30000,
												Description: `#### **FULFILLMENTS_CONTACT_PHONE**

- All elements of $.message.catalog['bpp/providers'][*].fulfillments[*].contact.phone must follow every regex in ["^\\d{10,11}$"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_CONTACT_PHONE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var FULFILLMENTS_CONTACT_EMAIL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_CONTACT_EMAIL")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].fulfillments[*].contact.email", true)
										validationutils.UnusedFunction(attr)
										email := validationutils.StringSliceToInterface([]string{`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`})
										validationutils.UnusedFunction(email)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.FollowRegex(attr, email)

										configureDebugInfo = `{"_NAME_":"FULFILLMENTS_CONTACT_EMAIL","attr":"$.message.catalog['bpp/providers'][*].fulfillments[*].contact.email","email":["^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"],"_RETURN_":"attr follow regex email","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_CONTACT_EMAIL",
												Valid:    false,
												Code:     30000,
												Description: `#### **FULFILLMENTS_CONTACT_EMAIL**

- All elements of $.message.catalog['bpp/providers'][*].fulfillments[*].contact.email must follow every regex in ["^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_CONTACT_EMAIL",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									FULFILLMENTS_ID,
									FULFILLMENTS_TYPE,
									FULFILLMENTS_CONTACT_PHONE,
									FULFILLMENTS_CONTACT_EMAIL,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_FULFILLMENTS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_DESCRIPTOR = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_DESCRIPTOR")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var PROVIDERS_DESCRIPTOR_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_DESCRIPTOR_NAME")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].descriptor.name", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PROVIDERS_DESCRIPTOR_NAME","attr":"$.message.catalog['bpp/providers'][*].descriptor.name","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PROVIDERS_DESCRIPTOR_NAME",
												Valid:    false,
												Code:     30000,
												Description: `#### **PROVIDERS_DESCRIPTOR_NAME**

- $.message.catalog['bpp/providers'][*].descriptor.name must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PROVIDERS_DESCRIPTOR_NAME",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PROVIDERS_DESCRIPTOR_SYMBOL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_DESCRIPTOR_SYMBOL")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].descriptor.symbol", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PROVIDERS_DESCRIPTOR_SYMBOL","attr":"$.message.catalog['bpp/providers'][*].descriptor.symbol","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PROVIDERS_DESCRIPTOR_SYMBOL",
												Valid:    false,
												Code:     30000,
												Description: `#### **PROVIDERS_DESCRIPTOR_SYMBOL**

- $.message.catalog['bpp/providers'][*].descriptor.symbol must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PROVIDERS_DESCRIPTOR_SYMBOL",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PROVIDERS_DESCRIPTOR_SHORT_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_DESCRIPTOR_SHORT_DESC")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].descriptor.short_desc", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PROVIDERS_DESCRIPTOR_SHORT_DESC","attr":"$.message.catalog['bpp/providers'][*].descriptor.short_desc","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PROVIDERS_DESCRIPTOR_SHORT_DESC",
												Valid:    false,
												Code:     30000,
												Description: `#### **PROVIDERS_DESCRIPTOR_SHORT_DESC**

- $.message.catalog['bpp/providers'][*].descriptor.short_desc must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PROVIDERS_DESCRIPTOR_SHORT_DESC",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PROVIDERS_DESCRIPTOR_LONG_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_DESCRIPTOR_LONG_DESC")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].descriptor.long_desc", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PROVIDERS_DESCRIPTOR_LONG_DESC","attr":"$.message.catalog['bpp/providers'][*].descriptor.long_desc","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PROVIDERS_DESCRIPTOR_LONG_DESC",
												Valid:    false,
												Code:     30000,
												Description: `#### **PROVIDERS_DESCRIPTOR_LONG_DESC**

- $.message.catalog['bpp/providers'][*].descriptor.long_desc must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PROVIDERS_DESCRIPTOR_LONG_DESC",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PROVIDERS_DESCRIPTOR_IMAGES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_DESCRIPTOR_IMAGES")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].descriptor.images[*]", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PROVIDERS_DESCRIPTOR_IMAGES","attr":"$.message.catalog['bpp/providers'][*].descriptor.images[*]","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PROVIDERS_DESCRIPTOR_IMAGES",
												Valid:    false,
												Code:     30000,
												Description: `#### **PROVIDERS_DESCRIPTOR_IMAGES**

- $.message.catalog['bpp/providers'][*].descriptor.images[*] must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PROVIDERS_DESCRIPTOR_IMAGES",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									PROVIDERS_DESCRIPTOR_NAME,
									PROVIDERS_DESCRIPTOR_SYMBOL,
									PROVIDERS_DESCRIPTOR_SHORT_DESC,
									PROVIDERS_DESCRIPTOR_LONG_DESC,
									PROVIDERS_DESCRIPTOR_IMAGES,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_DESCRIPTOR",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].ttl", true)
								validationutils.UnusedFunction(attr)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"PROVIDERS_TTL","attr":"$.message.catalog['bpp/providers'][*].ttl","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PROVIDERS_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **PROVIDERS_TTL**

- $.message.catalog['bpp/providers'][*].ttl must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_LOCATIONS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_LOCATIONS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var LOCATIONS_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_ID")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].id", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_ID","attr":"$.message.catalog['bpp/providers'][*].locations[*].id","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_ID",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_ID**

- $.message.catalog['bpp/providers'][*].locations[*].id must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_ID",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_TIME_LABEL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_TIME_LABEL")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].time.label", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`enable`, `disable`})
										validationutils.UnusedFunction(var_enum)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_TIME_LABEL","attr":"$.message.catalog['bpp/providers'][*].locations[*].time.label","var_enum":["enable","disable"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_TIME_LABEL",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_TIME_LABEL**

- All elements of $.message.catalog['bpp/providers'][*].locations[*].time.label must be in ["enable", "disable"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_TIME_LABEL",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_TIME_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_TIME_TIMESTAMP")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].time.timestamp", true)
										validationutils.UnusedFunction(attr)
										time_reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$`})
										validationutils.UnusedFunction(time_reg)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.FollowRegex(attr, time_reg)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_TIME_TIMESTAMP","attr":"$.message.catalog['bpp/providers'][*].locations[*].time.timestamp","time_reg":["^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}Z$"],"_RETURN_":"attr follow regex time_reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_TIME_TIMESTAMP",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_TIME_TIMESTAMP**

- All elements of $.message.catalog['bpp/providers'][*].locations[*].time.timestamp must follow every regex in ["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_TIME_TIMESTAMP",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_TIME_SCHEDULE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_TIME_SCHEDULE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].time.schedule.holidays[*]", true)
										validationutils.UnusedFunction(attr)
										time_reg := validationutils.StringSliceToInterface([]string{`^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$`})
										validationutils.UnusedFunction(time_reg)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.FollowRegex(attr, time_reg)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_TIME_SCHEDULE","attr":"$.message.catalog['bpp/providers'][*].locations[*].time.schedule.holidays[*]","time_reg":["^\\\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\\\d|3[01])$"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr follow regex time_reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_TIME_SCHEDULE",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_TIME_SCHEDULE**

- All elements of $.message.catalog['bpp/providers'][*].locations[*].time.schedule.holidays[*] must follow every regex in ["^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].locations[*].time.schedule.holidays[*] is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_TIME_SCHEDULE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_TIME_SCHEDULE_TIMES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_TIME_SCHEDULE_TIMES")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].time.schedule.times[*]", true)
										validationutils.UnusedFunction(attr)
										time_reg := validationutils.StringSliceToInterface([]string{`^(?:[01]\d|2[0-3])[0-5]\d$`})
										validationutils.UnusedFunction(time_reg)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.FollowRegex(attr, time_reg)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_TIME_SCHEDULE_TIMES","attr":"$.message.catalog['bpp/providers'][*].locations[*].time.schedule.times[*]","_CONTINUE_":"!(attr are present)","time_reg":["^(?:[01]\\\\d|2[0-3])[0-5]\\\\d$"],"_RETURN_":"attr follow regex time_reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_TIME_SCHEDULE_TIMES",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_TIME_SCHEDULE_TIMES**

- All elements of $.message.catalog['bpp/providers'][*].locations[*].time.schedule.times[*] must follow every regex in ["^(?:[01]\\d|2[0-3])[0-5]\\d$"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].locations[*].time.schedule.times[*] is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_TIME_SCHEDULE_TIMES",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_TIME_DAYS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_TIME_DAYS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].time.days", true)
										validationutils.UnusedFunction(attr)
										days_reg := validationutils.StringSliceToInterface([]string{`^(?!.*\b([1-7]),.*\b\1\b)([1-7](,[1-7]){0,6})$`})
										validationutils.UnusedFunction(days_reg)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.FollowRegex(attr, days_reg)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_TIME_DAYS","attr":"$.message.catalog['bpp/providers'][*].locations[*].time.days","_CONTINUE_":"!(attr are present)","days_reg":["^(?!.*\\\\b([1-7]),.*\\\\b\\\\1\\\\b)([1-7](,[1-7]){0,6})$"],"_RETURN_":"attr follow regex days_reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_TIME_DAYS",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_TIME_DAYS**

- All elements of $.message.catalog['bpp/providers'][*].locations[*].time.days must follow every regex in ["^(?!.*\\b([1-7]),.*\\b\\1\\b)([1-7](,[1-7]){0,6})$"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].locations[*].time.days is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_TIME_DAYS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_TIME_FREQUENCY_RANGE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_TIME_FREQUENCY_RANGE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										frequency := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].time.frequency", true)
										validationutils.UnusedFunction(frequency)
										times := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].time.schedule.times[*]", true)
										validationutils.UnusedFunction(times)
										range1 := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].time.range.start", true)
										validationutils.UnusedFunction(range1)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := ((validationutils.ArePresent(frequency)) && (validationutils.ArePresent(times))) || (validationutils.ArePresent(range1))

										configureDebugInfo = `{"_NAME_":"LOCATIONS_TIME_FREQUENCY_RANGE","frequency":"$.message.catalog['bpp/providers'][*].locations[*].time.frequency","times":"$.message.catalog['bpp/providers'][*].locations[*].time.schedule.times[*]","range1":"$.message.catalog['bpp/providers'][*].locations[*].time.range.start","_RETURN_":"(frequency are present && times are present) || range1 are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_TIME_FREQUENCY_RANGE",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_TIME_FREQUENCY_RANGE**

**Any of these must be true:**
  - **All of the following must be true:**
    - $.message.catalog['bpp/providers'][*].locations[*].time.frequency must be present in the payload
    - $.message.catalog['bpp/providers'][*].locations[*].time.schedule.times[*] must be present in the payload
  - $.message.catalog['bpp/providers'][*].locations[*].time.range.start must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_TIME_FREQUENCY_RANGE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_TIME_FREQUENCY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_TIME_FREQUENCY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										frequency := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].time.frequency", true)
										validationutils.UnusedFunction(frequency)
										reg := validationutils.StringSliceToInterface([]string{`^P(?=\d|T)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?=\d)(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?)?$`})
										validationutils.UnusedFunction(reg)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(frequency))
										if skipCheck {
											continue
										}

										validate := validationutils.FollowRegex(frequency, reg)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_TIME_FREQUENCY","frequency":"$.message.catalog['bpp/providers'][*].locations[*].time.frequency","_CONTINUE_":"!(frequency are present)","reg":["^P(?=\\d|T)(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?(?:T(?=\\d)(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?)?$"],"_RETURN_":"frequency follow regex reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_TIME_FREQUENCY",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_TIME_FREQUENCY**

- All elements of $.message.catalog['bpp/providers'][*].locations[*].time.frequency must follow every regex in ["^P(?=\d|T)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?=\d)(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?)?$"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].locations[*].time.frequency is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_TIME_FREQUENCY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_GPS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_GPS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].gps", true)
										validationutils.UnusedFunction(attr)
										reg := validationutils.StringSliceToInterface([]string{`^\d{2}\.\d{4,}\s*,\s*\d{2}\.\d{4,}$`})
										validationutils.UnusedFunction(reg)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.FollowRegex(attr, reg)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_GPS","attr":"$.message.catalog['bpp/providers'][*].locations[*].gps","reg":["^\\\\d{2}\\\\.\\\\d{4,}\\\\s*,\\\\s*\\\\d{2}\\\\.\\\\d{4,}$"],"_RETURN_":"attr follow regex reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_GPS",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_GPS**

- All elements of $.message.catalog['bpp/providers'][*].locations[*].gps must follow every regex in ["^\\d{2}\\.\\d{4,}\\s*,\\s*\\d{2}\\.\\d{4,}$"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_GPS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var RANGE_START_AND_END = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test RANGE_START_AND_END")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										start := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].time.range.start", true)
										validationutils.UnusedFunction(start)
										end := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].time.range.end", true)
										validationutils.UnusedFunction(end)
										reg := validationutils.StringSliceToInterface([]string{`^([01]\d|2[0-3])[0-5]\d$`})
										validationutils.UnusedFunction(reg)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := (validationutils.FollowRegex(start, reg)) && (validationutils.FollowRegex(end, reg))

										configureDebugInfo = `{"_NAME_":"RANGE_START_AND_END","start":"$.message.catalog['bpp/providers'][*].locations[*].time.range.start","end":"$.message.catalog['bpp/providers'][*].locations[*].time.range.end","reg":["^([01]\\\\d|2[0-3])[0-5]\\\\d$"],"_RETURN_":"start follow regex reg && end follow regex reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "RANGE_START_AND_END",
												Valid:    false,
												Code:     30000,
												Description: `#### **RANGE_START_AND_END**

**All of the following must be true:**
  - All elements of $.message.catalog['bpp/providers'][*].locations[*].time.range.start must follow every regex in ["^([01]\\d|2[0-3])[0-5]\\d$"]
  - All elements of $.message.catalog['bpp/providers'][*].locations[*].time.range.end must follow every regex in ["^([01]\\d|2[0-3])[0-5]\\d$"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "RANGE_START_AND_END",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_ADDRESS_LOCALITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_ADDRESS_LOCALITY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].address.locality", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_ADDRESS_LOCALITY","attr":"$.message.catalog['bpp/providers'][*].locations[*].address.locality","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_ADDRESS_LOCALITY",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_ADDRESS_LOCALITY**

- $.message.catalog['bpp/providers'][*].locations[*].address.locality must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_ADDRESS_LOCALITY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_ADDRESS_STREET = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_ADDRESS_STREET")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].address.street", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_ADDRESS_STREET","attr":"$.message.catalog['bpp/providers'][*].locations[*].address.street","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_ADDRESS_STREET",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_ADDRESS_STREET**

- $.message.catalog['bpp/providers'][*].locations[*].address.street must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_ADDRESS_STREET",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_ADDRESS_CITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_ADDRESS_CITY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].address.city", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_ADDRESS_CITY","attr":"$.message.catalog['bpp/providers'][*].locations[*].address.city","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_ADDRESS_CITY",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_ADDRESS_CITY**

- $.message.catalog['bpp/providers'][*].locations[*].address.city must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_ADDRESS_CITY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_ADDRESS_AREA_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_ADDRESS_AREA_CODE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].address.area_code", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_ADDRESS_AREA_CODE","attr":"$.message.catalog['bpp/providers'][*].locations[*].address.area_code","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_ADDRESS_AREA_CODE",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_ADDRESS_AREA_CODE**

- $.message.catalog['bpp/providers'][*].locations[*].address.area_code must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_ADDRESS_AREA_CODE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_ADDRESS_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_ADDRESS_STATE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].address.state", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_ADDRESS_STATE","attr":"$.message.catalog['bpp/providers'][*].locations[*].address.state","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_ADDRESS_STATE",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_ADDRESS_STATE**

- $.message.catalog['bpp/providers'][*].locations[*].address.state must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_ADDRESS_STATE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var LOCATIONS_CIRCLE_RADIUS_UNIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test LOCATIONS_CIRCLE_RADIUS_UNIT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].locations[*].circle.radius.unit", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`km`})
										validationutils.UnusedFunction(var_enum)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"LOCATIONS_CIRCLE_RADIUS_UNIT","attr":"$.message.catalog['bpp/providers'][*].locations[*].circle.radius.unit","var_enum":["km"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "LOCATIONS_CIRCLE_RADIUS_UNIT",
												Valid:    false,
												Code:     30000,
												Description: `#### **LOCATIONS_CIRCLE_RADIUS_UNIT**

- All elements of $.message.catalog['bpp/providers'][*].locations[*].circle.radius.unit must be in ["km"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].locations[*].circle.radius.unit is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "LOCATIONS_CIRCLE_RADIUS_UNIT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									LOCATIONS_ID,
									LOCATIONS_TIME_LABEL,
									LOCATIONS_TIME_TIMESTAMP,
									LOCATIONS_TIME_SCHEDULE,
									LOCATIONS_TIME_SCHEDULE_TIMES,
									LOCATIONS_TIME_DAYS,
									LOCATIONS_TIME_FREQUENCY_RANGE,
									LOCATIONS_TIME_FREQUENCY,
									LOCATIONS_GPS,
									RANGE_START_AND_END,
									LOCATIONS_ADDRESS_LOCALITY,
									LOCATIONS_ADDRESS_STREET,
									LOCATIONS_ADDRESS_CITY,
									LOCATIONS_ADDRESS_AREA_CODE,
									LOCATIONS_ADDRESS_STATE,
									LOCATIONS_CIRCLE_RADIUS_UNIT,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_LOCATIONS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_CATEGORIES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_CATEGORIES")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var CATEGORIES_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test CATEGORIES_ID")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].categories[*].id", true)
										validationutils.UnusedFunction(attr)
										reg := validationutils.StringSliceToInterface([]string{`^[a-zA-Z0-9]{1,12}$`})
										validationutils.UnusedFunction(reg)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.FollowRegex(attr, reg)

										configureDebugInfo = `{"_NAME_":"CATEGORIES_ID","attr":"$.message.catalog['bpp/providers'][*].categories[*].id","_CONTINUE_":"!(attr are present)","reg":["^[a-zA-Z0-9]{1,12}$"],"_RETURN_":"attr follow regex reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "CATEGORIES_ID",
												Valid:    false,
												Code:     30000,
												Description: `#### **CATEGORIES_ID**

- All elements of $.message.catalog['bpp/providers'][*].categories[*].id must follow every regex in ["^[a-zA-Z0-9]{1,12}$"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].categories[*].id is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "CATEGORIES_ID",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var CATEGORIES_DESCRIPTOR_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test CATEGORIES_DESCRIPTOR_NAME")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].categories[*].descriptor.name", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"CATEGORIES_DESCRIPTOR_NAME","attr":"$.message.catalog['bpp/providers'][*].categories[*].descriptor.name","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "CATEGORIES_DESCRIPTOR_NAME",
												Valid:    false,
												Code:     30000,
												Description: `#### **CATEGORIES_DESCRIPTOR_NAME**

- $.message.catalog['bpp/providers'][*].categories[*].descriptor.name must be present in the payload

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].categories[*].descriptor.name is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "CATEGORIES_DESCRIPTOR_NAME",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var BPP_PROVIDER_CATEGORIES_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test BPP_PROVIDER_CATEGORIES_TAGS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_PROVIDER_CATEGORY_TYPE_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_CATEGORY_TYPE_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].categories[*].tags[*].code", true)
												validationutils.UnusedFunction(attr)
												tag_enum := validationutils.StringSliceToInterface([]string{`type`, `attr`, `np_fees`})
												validationutils.UnusedFunction(tag_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, tag_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_PROVIDER_CATEGORY_TYPE_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].categories[*].tags[*].code","tag_enum":["type","attr","np_fees"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDER_CATEGORY_TYPE_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_PROVIDER_CATEGORY_TYPE_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].categories[*].tags[*].code must be in ["type", "attr", "np_fees"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].categories[*].tags[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDER_CATEGORY_TYPE_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_PROVIDER_CATEGORY_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_CATEGORY_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												var TAGS_PROVIDER_CATEGORY_TYPE_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_CATEGORY_TYPE_TYPE")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[*].code", true)
														validationutils.UnusedFunction(attr)
														tag_enum := validationutils.StringSliceToInterface([]string{`type`, `attr`})
														validationutils.UnusedFunction(tag_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, tag_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_PROVIDER_CATEGORY_TYPE_TYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[*].code","tag_enum":["type","attr"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_PROVIDER_CATEGORY_TYPE_TYPE",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_PROVIDER_CATEGORY_TYPE_TYPE**

- All elements of $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[*].code must be in ["type", "attr"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[*].code is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDER_CATEGORY_TYPE_TYPE",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var TAGS_PROVIDER_CATEGORY_TYPE_TAGS_1 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_CATEGORY_TYPE_TAGS_1")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[?(@.code=='type')].value", true)
														validationutils.UnusedFunction(attr)
														var_enum := validationutils.StringSliceToInterface([]string{`variant_group`, `category`})
														validationutils.UnusedFunction(var_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, var_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_PROVIDER_CATEGORY_TYPE_TAGS_1","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[?(@.code=='type')].value","var_enum":["variant_group","category"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_PROVIDER_CATEGORY_TYPE_TAGS_1",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_PROVIDER_CATEGORY_TYPE_TAGS_1**

- All elements of $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[?(@.code=='type')].value must be in ["variant_group", "category"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[?(@.code=='type')].value is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDER_CATEGORY_TYPE_TAGS_1",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var TAGS_PROVIDER_CATEGORY_TYPE_TAGS_2 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_CATEGORY_TYPE_TAGS_2")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[?(@.code=='type')].value", true)
														validationutils.UnusedFunction(attr)
														var_enum := validationutils.StringSliceToInterface([]string{`variant_group`, `category`})
														validationutils.UnusedFunction(var_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, var_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_PROVIDER_CATEGORY_TYPE_TAGS_2","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[?(@.code=='type')].value","var_enum":["variant_group","category"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_PROVIDER_CATEGORY_TYPE_TAGS_2",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_PROVIDER_CATEGORY_TYPE_TAGS_2**

- All elements of $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[?(@.code=='type')].value must be in ["variant_group", "category"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='type')].list[?(@.code=='type')].value is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDER_CATEGORY_TYPE_TAGS_2",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}

												var testFunctions = validationutils.TestFunctionArray{
													TAGS_PROVIDER_CATEGORY_TYPE_TYPE,
													TAGS_PROVIDER_CATEGORY_TYPE_TAGS_1,
													TAGS_PROVIDER_CATEGORY_TYPE_TAGS_2,
												}

												allResults := make([]validationutils.ValidationOutput, 0)

												for _, testFunc := range testFunctions {
													results, err := testFunc(input)
													if err != nil {
														return nil, err
													}
													allResults = append(allResults, results...)
												}

												subResults = allResults
												// if all subResults are valid, then valid is true
												valid = true
												for _, res := range subResults {
													if !res.Valid {
														valid = false
														break
													}
												}

												configureDebugInfo = `NESTED_TEST_OBJECT`

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDER_CATEGORY_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_PROVIDER_CATEGORY_NP_FEES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_CATEGORY_NP_FEES")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												var TAGS_PROVIDER_CATEGORY_TYPE_NP_FEES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_CATEGORY_TYPE_NP_FEES")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='np_fees')].list[*].code", true)
														validationutils.UnusedFunction(attr)
														tag_enum := validationutils.StringSliceToInterface([]string{`channel_margin_type`, `channel_margin_value`})
														validationutils.UnusedFunction(tag_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, tag_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_PROVIDER_CATEGORY_TYPE_NP_FEES","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='np_fees')].list[*].code","tag_enum":["channel_margin_type","channel_margin_value"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_PROVIDER_CATEGORY_TYPE_NP_FEES",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_PROVIDER_CATEGORY_TYPE_NP_FEES**

- All elements of $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='np_fees')].list[*].code must be in ["channel_margin_type", "channel_margin_value"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='np_fees')].list[*].code is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDER_CATEGORY_TYPE_NP_FEES",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var TAGS_PROVIDER_CATEGORY_NP_FEES_CHANNEL_MARGIN_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_CATEGORY_NP_FEES_CHANNEL_MARGIN_TYPE")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='np_fees')].list[?(@.code=='channel_margin_type')].value", true)
														validationutils.UnusedFunction(attr)
														var_enum := validationutils.StringSliceToInterface([]string{`percent`, `amount`})
														validationutils.UnusedFunction(var_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, var_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_PROVIDER_CATEGORY_NP_FEES_CHANNEL_MARGIN_TYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='np_fees')].list[?(@.code=='channel_margin_type')].value","var_enum":["percent","amount"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_PROVIDER_CATEGORY_NP_FEES_CHANNEL_MARGIN_TYPE",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_PROVIDER_CATEGORY_NP_FEES_CHANNEL_MARGIN_TYPE**

- All elements of $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='np_fees')].list[?(@.code=='channel_margin_type')].value must be in ["percent", "amount"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='np_fees')].list[?(@.code=='channel_margin_type')].value is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDER_CATEGORY_NP_FEES_CHANNEL_MARGIN_TYPE",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}

												var testFunctions = validationutils.TestFunctionArray{
													TAGS_PROVIDER_CATEGORY_TYPE_NP_FEES,
													TAGS_PROVIDER_CATEGORY_NP_FEES_CHANNEL_MARGIN_TYPE,
												}

												allResults := make([]validationutils.ValidationOutput, 0)

												for _, testFunc := range testFunctions {
													results, err := testFunc(input)
													if err != nil {
														return nil, err
													}
													allResults = append(allResults, results...)
												}

												subResults = allResults
												// if all subResults are valid, then valid is true
												valid = true
												for _, res := range subResults {
													if !res.Valid {
														valid = false
														break
													}
												}

												configureDebugInfo = `NESTED_TEST_OBJECT`

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDER_CATEGORY_NP_FEES",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_PROVIDER_CATEGORY_ATTR = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_CATEGORY_ATTR")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												var TAGS_PROVIDER_CATEGORY_TYPE_ATTR = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_CATEGORY_TYPE_ATTR")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='attr')].list[*].code", true)
														validationutils.UnusedFunction(attr)
														tag_enum := validationutils.StringSliceToInterface([]string{`name`, `seq`})
														validationutils.UnusedFunction(tag_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, tag_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_PROVIDER_CATEGORY_TYPE_ATTR","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='attr')].list[*].code","tag_enum":["name","seq"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_PROVIDER_CATEGORY_TYPE_ATTR",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_PROVIDER_CATEGORY_TYPE_ATTR**

- All elements of $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='attr')].list[*].code must be in ["name", "seq"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].categories[*].tags[?(@.code=='attr')].list[*].code is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDER_CATEGORY_TYPE_ATTR",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}

												var testFunctions = validationutils.TestFunctionArray{
													TAGS_PROVIDER_CATEGORY_TYPE_ATTR,
												}

												allResults := make([]validationutils.ValidationOutput, 0)

												for _, testFunc := range testFunctions {
													results, err := testFunc(input)
													if err != nil {
														return nil, err
													}
													allResults = append(allResults, results...)
												}

												subResults = allResults
												// if all subResults are valid, then valid is true
												valid = true
												for _, res := range subResults {
													if !res.Valid {
														valid = false
														break
													}
												}

												configureDebugInfo = `NESTED_TEST_OBJECT`

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDER_CATEGORY_ATTR",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_PROVIDER_CATEGORY_TYPE_VALID_TAGS,
											TAGS_PROVIDER_CATEGORY_TYPE,
											TAGS_PROVIDER_CATEGORY_NP_FEES,
											TAGS_PROVIDER_CATEGORY_ATTR,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "BPP_PROVIDER_CATEGORIES_TAGS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									CATEGORIES_ID,
									CATEGORIES_DESCRIPTOR_NAME,
									BPP_PROVIDER_CATEGORIES_TAGS,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_CATEGORIES",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_ITEMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_ITEMS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var ITEMS_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_ID")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].id", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_ID","attr":"$.message.catalog['bpp/providers'][*].items[*].id","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_ID",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_ID**

- $.message.catalog['bpp/providers'][*].items[*].id must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_ID",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_RATING = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_RATING")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].rating", true)
										validationutils.UnusedFunction(attr)
										rating_reg := validationutils.StringSliceToInterface([]string{`^(?:[1-4](?:\.\d+)?|5(?:\.0+)?|\s*)$`})
										validationutils.UnusedFunction(rating_reg)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.FollowRegex(attr, rating_reg)

										configureDebugInfo = `{"_NAME_":"ITEMS_RATING","attr":"$.message.catalog['bpp/providers'][*].items[*].rating","_CONTINUE_":"!(attr are present)","rating_reg":["^(?:[1-4](?:\\\\.\\\\d+)?|5(?:\\\\.0+)?|\\\\s*)$"],"_RETURN_":"attr follow regex rating_reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_RATING",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_RATING**

- All elements of $.message.catalog['bpp/providers'][*].items[*].rating must follow every regex in ["^(?:[1-4](?:\\.\\d+)?|5(?:\\.0+)?|\\s*)$"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].items[*].rating is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_RATING",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_TIME_LABEL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_TIME_LABEL")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].time.label", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`enable`, `disable`})
										validationutils.UnusedFunction(var_enum)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"ITEMS_TIME_LABEL","attr":"$.message.catalog['bpp/providers'][*].items[*].time.label","var_enum":["enable","disable"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_TIME_LABEL",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_TIME_LABEL**

- All elements of $.message.catalog['bpp/providers'][*].items[*].time.label must be in ["enable", "disable"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_TIME_LABEL",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_TIME_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_TIME_TIMESTAMP")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].time.timestamp", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_TIME_TIMESTAMP","attr":"$.message.catalog['bpp/providers'][*].items[*].time.timestamp","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_TIME_TIMESTAMP",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_TIME_TIMESTAMP**

- $.message.catalog['bpp/providers'][*].items[*].time.timestamp must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_TIME_TIMESTAMP",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_DESCRIPTOR_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_DESCRIPTOR_NAME")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].descriptor.name", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_DESCRIPTOR_NAME","attr":"$.message.catalog['bpp/providers'][*].items[*].descriptor.name","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_DESCRIPTOR_NAME",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_DESCRIPTOR_NAME**

- $.message.catalog['bpp/providers'][*].items[*].descriptor.name must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_DESCRIPTOR_NAME",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_DESCRIPTOR_SYMBOL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_DESCRIPTOR_SYMBOL")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].descriptor.symbol", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_DESCRIPTOR_SYMBOL","attr":"$.message.catalog['bpp/providers'][*].items[*].descriptor.symbol","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_DESCRIPTOR_SYMBOL",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_DESCRIPTOR_SYMBOL**

- $.message.catalog['bpp/providers'][*].items[*].descriptor.symbol must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_DESCRIPTOR_SYMBOL",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_DESCRIPTOR_SHORT_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_DESCRIPTOR_SHORT_DESC")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].descriptor.short_desc", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_DESCRIPTOR_SHORT_DESC","attr":"$.message.catalog['bpp/providers'][*].items[*].descriptor.short_desc","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_DESCRIPTOR_SHORT_DESC",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_DESCRIPTOR_SHORT_DESC**

- $.message.catalog['bpp/providers'][*].items[*].descriptor.short_desc must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_DESCRIPTOR_SHORT_DESC",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_DESCRIPTOR_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_DESCRIPTOR_CODE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].descriptor.code", true)
										validationutils.UnusedFunction(attr)
										reg := validationutils.StringSliceToInterface([]string{`^(1|5):`})
										validationutils.UnusedFunction(reg)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.FollowRegex(attr, reg)

										configureDebugInfo = `{"_NAME_":"ITEMS_DESCRIPTOR_CODE","attr":"$.message.catalog['bpp/providers'][*].items[*].descriptor.code","reg":["^(1|5):"],"_RETURN_":"attr follow regex reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_DESCRIPTOR_CODE",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_DESCRIPTOR_CODE**

- All elements of $.message.catalog['bpp/providers'][*].items[*].descriptor.code must follow every regex in ["^(1|5):"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_DESCRIPTOR_CODE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_DESCRIPTOR_IMAGES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_DESCRIPTOR_IMAGES")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].descriptor.images[*]", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_DESCRIPTOR_IMAGES","attr":"$.message.catalog['bpp/providers'][*].items[*].descriptor.images[*]","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_DESCRIPTOR_IMAGES",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_DESCRIPTOR_IMAGES**

- $.message.catalog['bpp/providers'][*].items[*].descriptor.images[*] must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_DESCRIPTOR_IMAGES",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_QUANTITY_UNITIZED_MEASURE_UNIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_QUANTITY_UNITIZED_MEASURE_UNIT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].quantity.unitized.measure.unit", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`unit`, `dozen`, `gram`, `kilogram`, `tonne`, `litre`, `millilitre`})
										validationutils.UnusedFunction(var_enum)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"ITEMS_QUANTITY_UNITIZED_MEASURE_UNIT","attr":"$.message.catalog['bpp/providers'][*].items[*].quantity.unitized.measure.unit","var_enum":["unit","dozen","gram","kilogram","tonne","litre","millilitre"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_QUANTITY_UNITIZED_MEASURE_UNIT",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_QUANTITY_UNITIZED_MEASURE_UNIT**

- All elements of $.message.catalog['bpp/providers'][*].items[*].quantity.unitized.measure.unit must be in ["unit", "dozen", "gram", "kilogram", "tonne", "litre", "millilitre"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_QUANTITY_UNITIZED_MEASURE_UNIT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_QUANTITY_UNITIZED_MEASURE_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_QUANTITY_UNITIZED_MEASURE_VALUE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].quantity.unitized.measure.value", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_QUANTITY_UNITIZED_MEASURE_VALUE","attr":"$.message.catalog['bpp/providers'][*].items[*].quantity.unitized.measure.value","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_QUANTITY_UNITIZED_MEASURE_VALUE",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_QUANTITY_UNITIZED_MEASURE_VALUE**

- $.message.catalog['bpp/providers'][*].items[*].quantity.unitized.measure.value must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_QUANTITY_UNITIZED_MEASURE_VALUE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_QUANTITY_AVAILABLE_COUNT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_QUANTITY_AVAILABLE_COUNT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].quantity.available.count", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`99`, `0`})
										validationutils.UnusedFunction(var_enum)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"ITEMS_QUANTITY_AVAILABLE_COUNT","attr":"$.message.catalog['bpp/providers'][*].items[*].quantity.available.count","var_enum":["99","0"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_QUANTITY_AVAILABLE_COUNT",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_QUANTITY_AVAILABLE_COUNT**

- All elements of $.message.catalog['bpp/providers'][*].items[*].quantity.available.count must be in ["99", "0"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_QUANTITY_AVAILABLE_COUNT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_QUANTITY_MAXIMUM_COUNT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_QUANTITY_MAXIMUM_COUNT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].quantity.maximum.count", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_QUANTITY_MAXIMUM_COUNT","attr":"$.message.catalog['bpp/providers'][*].items[*].quantity.maximum.count","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_QUANTITY_MAXIMUM_COUNT",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_QUANTITY_MAXIMUM_COUNT**

- $.message.catalog['bpp/providers'][*].items[*].quantity.maximum.count must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_QUANTITY_MAXIMUM_COUNT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_PRICE_CURRENCY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_PRICE_CURRENCY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].price.currency", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`INR`})
										validationutils.UnusedFunction(var_enum)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"ITEMS_PRICE_CURRENCY","attr":"$.message.catalog['bpp/providers'][*].items[*].price.currency","var_enum":["INR"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_PRICE_CURRENCY",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_PRICE_CURRENCY**

- All elements of $.message.catalog['bpp/providers'][*].items[*].price.currency must be in ["INR"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_PRICE_CURRENCY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_PRICE_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_PRICE_VALUE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].price.value", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_PRICE_VALUE","attr":"$.message.catalog['bpp/providers'][*].items[*].price.value","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_PRICE_VALUE",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_PRICE_VALUE**

- $.message.catalog['bpp/providers'][*].items[*].price.value must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_PRICE_VALUE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_PRICE_MAXIMUM_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_PRICE_MAXIMUM_VALUE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].price.maximum_value", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_PRICE_MAXIMUM_VALUE","attr":"$.message.catalog['bpp/providers'][*].items[*].price.maximum_value","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_PRICE_MAXIMUM_VALUE",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_PRICE_MAXIMUM_VALUE**

- $.message.catalog['bpp/providers'][*].items[*].price.maximum_value must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_PRICE_MAXIMUM_VALUE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_CATEGORY_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_CATEGORY_ID")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].category_id", true)
										validationutils.UnusedFunction(attr)
										valid := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Masala & Seasoning`, `Oil & Ghee`, `Eggs, Meat & Fish`, `Cleaning & Household`, `Bakery, Cakes & Dairy`, `Pet Care`, `Stationery`, `Detergents and Dishwash`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Pasta, Soup and Noodles`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Cooking and Baking Needs`, `Tinned and Processed Food`, `Atta, Flours and Sooji`, `Rice and Rice Products`, `Dals and Pulses`, `Salt, Sugar and Jaggery`, `Energy and Soft Drinks`, `Water`, `Tea and Coffee`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Vegetables`, `Frozen Snacks`, `Gift Voucher`})
										validationutils.UnusedFunction(valid)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.AllIn(attr, valid)

										configureDebugInfo = `{"_NAME_":"ITEMS_CATEGORY_ID","attr":"$.message.catalog['bpp/providers'][*].items[*].category_id","valid":["Fruits and Vegetables","Masala & Seasoning","Oil & Ghee","Eggs, Meat & Fish","Cleaning & Household","Bakery, Cakes & Dairy","Pet Care","Stationery","Detergents and Dishwash","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Pasta, Soup and Noodles","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Cooking and Baking Needs","Tinned and Processed Food","Atta, Flours and Sooji","Rice and Rice Products","Dals and Pulses","Salt, Sugar and Jaggery","Energy and Soft Drinks","Water","Tea and Coffee","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Vegetables","Frozen Snacks","Gift Voucher"],"_RETURN_":"attr all in valid","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_CATEGORY_ID",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_CATEGORY_ID**

- All elements of $.message.catalog['bpp/providers'][*].items[*].category_id must be in ["Fruits and Vegetables", "Masala & Seasoning", "Oil & Ghee", "Eggs, Meat & Fish", "Cleaning & Household", "Bakery, Cakes & Dairy", "Pet Care", "Stationery", "Detergents and Dishwash", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Pasta, Soup and Noodles", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Cooking and Baking Needs", "Tinned and Processed Food", "Atta, Flours and Sooji", "Rice and Rice Products", "Dals and Pulses", "Salt, Sugar and Jaggery", "Energy and Soft Drinks", "Water", "Tea and Coffee", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Vegetables", "Frozen Snacks", "Gift Voucher"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_CATEGORY_ID",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_FULFILLMENT_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_FULFILLMENT_ID")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].fulfillment_id", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_FULFILLMENT_ID","attr":"$.message.catalog['bpp/providers'][*].items[*].fulfillment_id","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_FULFILLMENT_ID",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_FULFILLMENT_ID**

- $.message.catalog['bpp/providers'][*].items[*].fulfillment_id must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_FULFILLMENT_ID",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_LOCATION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_LOCATION_ID")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].location_id", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_LOCATION_ID","attr":"$.message.catalog['bpp/providers'][*].items[*].location_id","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_LOCATION_ID",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_LOCATION_ID**

- $.message.catalog['bpp/providers'][*].items[*].location_id must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_LOCATION_ID",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_RETURNABLE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_RETURNABLE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/returnable']", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_RETURNABLE","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/returnable']","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_RETURNABLE",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_RETURNABLE**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/returnable'] must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_RETURNABLE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_CANCELLABLE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_CANCELLABLE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/cancellable']", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_CANCELLABLE","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/cancellable']","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_CANCELLABLE",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_CANCELLABLE**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/cancellable'] must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_CANCELLABLE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_RETURN_WINDOW = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_RETURN_WINDOW")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/return_window']", true)
										validationutils.UnusedFunction(attr)
										reg := validationutils.StringSliceToInterface([]string{`^P(?=\d|T)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$`})
										validationutils.UnusedFunction(reg)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.FollowRegex(attr, reg)

										configureDebugInfo = `{"_NAME_":"ITEMS_RETURN_WINDOW","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/return_window']","reg":["^P(?=\\\\d|T)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?(\\\\d+S)?)?$"],"_RETURN_":"attr follow regex reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_RETURN_WINDOW",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_RETURN_WINDOW**

- All elements of $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/return_window'] must follow every regex in ["^P(?=\\d|T)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_RETURN_WINDOW",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_SELLER_PICKUP_RETURN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_SELLER_PICKUP_RETURN")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/seller_pickup_return']", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_SELLER_PICKUP_RETURN","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/seller_pickup_return']","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_SELLER_PICKUP_RETURN",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_SELLER_PICKUP_RETURN**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/seller_pickup_return'] must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_SELLER_PICKUP_RETURN",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_TIME_TO_SHIP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_TIME_TO_SHIP")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/time_to_ship']", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_TIME_TO_SHIP","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/time_to_ship']","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_TIME_TO_SHIP",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_TIME_TO_SHIP**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/time_to_ship'] must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_TIME_TO_SHIP",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_AVAILABLE_ON_COD = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_AVAILABLE_ON_COD")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/available_on_cod']", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_AVAILABLE_ON_COD","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/available_on_cod']","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_AVAILABLE_ON_COD",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_AVAILABLE_ON_COD**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/available_on_cod'] must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_AVAILABLE_ON_COD",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_ADDITIVES_INFO = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_ADDITIVES_INFO")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].additives_info", true)
										validationutils.UnusedFunction(attr)
										category := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].category_id", true)
										validationutils.UnusedFunction(category)
										applicable_categories := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Bakery, Cakes & Dairy`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Tinned and Processed Food`, `Energy and Soft Drinks`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Snacks`})
										validationutils.UnusedFunction(applicable_categories)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := ((!(validationutils.ArePresent(attr))) || (!(validationutils.ArePresent(category)))) || (!(validationutils.AllIn(category, applicable_categories)))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_ADDITIVES_INFO","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].additives_info","category":"$.message.catalog['bpp/providers'][*].items[*].category_id","_CONTINUE_":"!(attr are present) || !(category are present) || !(category all in applicable_categories)","_RETURN_":"attr are present","applicable_categories":["Fruits and Vegetables","Bakery, Cakes & Dairy","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Tinned and Processed Food","Energy and Soft Drinks","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Snacks"],"var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_ADDITIVES_INFO",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_ADDITIVES_INFO**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].additives_info must be present in the payload

> **Skip if:**
>
>     - **Any of these must be true:**
>       - **Any of these must be true:**
>         - $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].additives_info is not in the payload
>         - $.message.catalog['bpp/providers'][*].items[*].category_id is not in the payload
>       - not all elements of $.message.catalog['bpp/providers'][*].items[*].category_id are in ["Fruits and Vegetables", "Bakery, Cakes & Dairy", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Tinned and Processed Food", "Energy and Soft Drinks", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Snacks"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_ADDITIVES_INFO",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_BRAND_OWNER_FSSAI_LICENSE_NO = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_BRAND_OWNER_FSSAI_LICENSE_NO")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].brand_owner_FSSAI_license_no", true)
										validationutils.UnusedFunction(attr)
										category := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].category_id", true)
										validationutils.UnusedFunction(category)
										applicable_categories := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Bakery, Cakes & Dairy`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Tinned and Processed Food`, `Energy and Soft Drinks`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Snacks`})
										validationutils.UnusedFunction(applicable_categories)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := ((!(validationutils.ArePresent(attr))) || (!(validationutils.ArePresent(category)))) || (!(validationutils.AllIn(category, applicable_categories)))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_BRAND_OWNER_FSSAI_LICENSE_NO","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].brand_owner_FSSAI_license_no","category":"$.message.catalog['bpp/providers'][*].items[*].category_id","_CONTINUE_":"!(attr are present) || !(category are present) || !(category all in applicable_categories)","_RETURN_":"attr are present","applicable_categories":["Fruits and Vegetables","Bakery, Cakes & Dairy","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Tinned and Processed Food","Energy and Soft Drinks","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Snacks"],"var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_BRAND_OWNER_FSSAI_LICENSE_NO",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_BRAND_OWNER_FSSAI_LICENSE_NO**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].brand_owner_FSSAI_license_no must be present in the payload

> **Skip if:**
>
>     - **Any of these must be true:**
>       - **Any of these must be true:**
>         - $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].brand_owner_FSSAI_license_no is not in the payload
>         - $.message.catalog['bpp/providers'][*].items[*].category_id is not in the payload
>       - not all elements of $.message.catalog['bpp/providers'][*].items[*].category_id are in ["Fruits and Vegetables", "Bakery, Cakes & Dairy", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Tinned and Processed Food", "Energy and Soft Drinks", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Snacks"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_BRAND_OWNER_FSSAI_LICENSE_NO",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_IMPORTER_FSSAI_LICENSE_NO = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_IMPORTER_FSSAI_LICENSE_NO")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].importer_FSSAI_license_no", true)
										validationutils.UnusedFunction(attr)
										category := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].category_id", true)
										validationutils.UnusedFunction(category)
										applicable_categories := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Bakery, Cakes & Dairy`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Tinned and Processed Food`, `Energy and Soft Drinks`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Snacks`})
										validationutils.UnusedFunction(applicable_categories)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := ((!(validationutils.ArePresent(attr))) || (!(validationutils.ArePresent(category)))) || (!(validationutils.AllIn(category, applicable_categories)))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_IMPORTER_FSSAI_LICENSE_NO","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].importer_FSSAI_license_no","category":"$.message.catalog['bpp/providers'][*].items[*].category_id","_CONTINUE_":"!(attr are present) ||!(category are present) || !(category all in applicable_categories)","_RETURN_":"attr are present","applicable_categories":["Fruits and Vegetables","Bakery, Cakes & Dairy","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Tinned and Processed Food","Energy and Soft Drinks","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Snacks"],"var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_IMPORTER_FSSAI_LICENSE_NO",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_IMPORTER_FSSAI_LICENSE_NO**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].importer_FSSAI_license_no must be present in the payload

> **Skip if:**
>
>     - **Any of these must be true:**
>       - **Any of these must be true:**
>         - $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].importer_FSSAI_license_no is not in the payload
>         - $.message.catalog['bpp/providers'][*].items[*].category_id is not in the payload
>       - not all elements of $.message.catalog['bpp/providers'][*].items[*].category_id are in ["Fruits and Vegetables", "Bakery, Cakes & Dairy", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Tinned and Processed Food", "Energy and Soft Drinks", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Snacks"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_IMPORTER_FSSAI_LICENSE_NO",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_NUTRITIONAL_INFO = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_NUTRITIONAL_INFO")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].nutritional_info", true)
										validationutils.UnusedFunction(attr)
										category := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].category_id", true)
										validationutils.UnusedFunction(category)
										applicable_categories := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Bakery, Cakes & Dairy`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Tinned and Processed Food`, `Energy and Soft Drinks`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Snacks`})
										validationutils.UnusedFunction(applicable_categories)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := ((!(validationutils.ArePresent(attr))) || (!(validationutils.ArePresent(category)))) || (!(validationutils.AllIn(category, applicable_categories)))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_NUTRITIONAL_INFO","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].nutritional_info","category":"$.message.catalog['bpp/providers'][*].items[*].category_id","_CONTINUE_":"!(attr are present) ||!(category are present) || !(category all in applicable_categories)","_RETURN_":"attr are present","applicable_categories":["Fruits and Vegetables","Bakery, Cakes & Dairy","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Tinned and Processed Food","Energy and Soft Drinks","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Snacks"],"var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_NUTRITIONAL_INFO",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_NUTRITIONAL_INFO**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].nutritional_info must be present in the payload

> **Skip if:**
>
>     - **Any of these must be true:**
>       - **Any of these must be true:**
>         - $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].nutritional_info is not in the payload
>         - $.message.catalog['bpp/providers'][*].items[*].category_id is not in the payload
>       - not all elements of $.message.catalog['bpp/providers'][*].items[*].category_id are in ["Fruits and Vegetables", "Bakery, Cakes & Dairy", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Tinned and Processed Food", "Energy and Soft Drinks", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Snacks"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_NUTRITIONAL_INFO",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_OTHER_FSSAI_LICENSE_NO = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_OTHER_FSSAI_LICENSE_NO")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].other_FSSAI_license_no", true)
										validationutils.UnusedFunction(attr)
										category := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].category_id", true)
										validationutils.UnusedFunction(category)
										applicable_categories := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Bakery, Cakes & Dairy`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Tinned and Processed Food`, `Energy and Soft Drinks`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Snacks`})
										validationutils.UnusedFunction(applicable_categories)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := (!(validationutils.ArePresent(attr))) || (!(validationutils.AllIn(category, applicable_categories)))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_OTHER_FSSAI_LICENSE_NO","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].other_FSSAI_license_no","category":"$.message.catalog['bpp/providers'][*].items[*].category_id","_CONTINUE_":"!(attr are present) || !(category all in applicable_categories)","_RETURN_":"attr are present","applicable_categories":["Fruits and Vegetables","Bakery, Cakes & Dairy","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Tinned and Processed Food","Energy and Soft Drinks","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Snacks"],"var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_OTHER_FSSAI_LICENSE_NO",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_OTHER_FSSAI_LICENSE_NO**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].other_FSSAI_license_no must be present in the payload

> **Skip if:**
>
>     - **Any of these must be true:**
>       - $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_prepackaged_food'].other_FSSAI_license_no is not in the payload
>       - not all elements of $.message.catalog['bpp/providers'][*].items[*].category_id are in ["Fruits and Vegetables", "Bakery, Cakes & Dairy", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Tinned and Processed Food", "Energy and Soft Drinks", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Snacks"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_OTHER_FSSAI_LICENSE_NO",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_COMMON_OR_GENERIC_NAME_OF_COMMODITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_COMMON_OR_GENERIC_NAME_OF_COMMODITY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].common_or_generic_name_of_commodity", true)
										validationutils.UnusedFunction(attr)
										category := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].category_id", true)
										validationutils.UnusedFunction(category)
										applicable_categories := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Masala & Seasoning`, `Oil & Ghee`, `Eggs, Meat & Fish`, `Cleaning & Household`, `Bakery, Cakes & Dairy`, `Pet Care`, `Stationery`, `Detergents and Dishwash`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Pasta, Soup and Noodles`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Cooking and Baking Needs`, `Tinned and Processed Food`, `Atta, Flours and Sooji`, `Rice and Rice Products`, `Dals and Pulses`, `Salt, Sugar and Jaggery`, `Energy and Soft Drinks`, `Water`, `Tea and Coffee`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Vegetables`, `Frozen Snacks`})
										validationutils.UnusedFunction(applicable_categories)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := ((!(validationutils.ArePresent(attr))) || (!(validationutils.ArePresent(category)))) || (!(validationutils.AllIn(category, applicable_categories)))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_COMMON_OR_GENERIC_NAME_OF_COMMODITY","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].common_or_generic_name_of_commodity","category":"$.message.catalog['bpp/providers'][*].items[*].category_id","_CONTINUE_":"!(attr are present) || !(category are present) || !(category all in applicable_categories)","applicable_categories":["Fruits and Vegetables","Masala & Seasoning","Oil & Ghee","Eggs, Meat & Fish","Cleaning & Household","Bakery, Cakes & Dairy","Pet Care","Stationery","Detergents and Dishwash","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Pasta, Soup and Noodles","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Cooking and Baking Needs","Tinned and Processed Food","Atta, Flours and Sooji","Rice and Rice Products","Dals and Pulses","Salt, Sugar and Jaggery","Energy and Soft Drinks","Water","Tea and Coffee","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Vegetables","Frozen Snacks"],"_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_COMMON_OR_GENERIC_NAME_OF_COMMODITY",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_COMMON_OR_GENERIC_NAME_OF_COMMODITY**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].common_or_generic_name_of_commodity must be present in the payload

> **Skip if:**
>
>     - **Any of these must be true:**
>       - **Any of these must be true:**
>         - $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].common_or_generic_name_of_commodity is not in the payload
>         - $.message.catalog['bpp/providers'][*].items[*].category_id is not in the payload
>       - not all elements of $.message.catalog['bpp/providers'][*].items[*].category_id are in ["Fruits and Vegetables", "Masala & Seasoning", "Oil & Ghee", "Eggs, Meat & Fish", "Cleaning & Household", "Bakery, Cakes & Dairy", "Pet Care", "Stationery", "Detergents and Dishwash", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Pasta, Soup and Noodles", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Cooking and Baking Needs", "Tinned and Processed Food", "Atta, Flours and Sooji", "Rice and Rice Products", "Dals and Pulses", "Salt, Sugar and Jaggery", "Energy and Soft Drinks", "Water", "Tea and Coffee", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Vegetables", "Frozen Snacks"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_COMMON_OR_GENERIC_NAME_OF_COMMODITY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_ADDRESS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_ADDRESS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].manufacturer_or_packer_address", true)
										validationutils.UnusedFunction(attr)
										category := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].category_id", true)
										validationutils.UnusedFunction(category)
										applicable_categories := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Masala & Seasoning`, `Oil & Ghee`, `Eggs, Meat & Fish`, `Cleaning & Household`, `Bakery, Cakes & Dairy`, `Pet Care`, `Stationery`, `Detergents and Dishwash`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Pasta, Soup and Noodles`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Cooking and Baking Needs`, `Tinned and Processed Food`, `Atta, Flours and Sooji`, `Rice and Rice Products`, `Dals and Pulses`, `Salt, Sugar and Jaggery`, `Energy and Soft Drinks`, `Water`, `Tea and Coffee`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Vegetables`, `Frozen Snacks`})
										validationutils.UnusedFunction(applicable_categories)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := ((!(validationutils.ArePresent(attr))) || (!(validationutils.ArePresent(category)))) || (!(validationutils.AllIn(category, applicable_categories)))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_ADDRESS","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].manufacturer_or_packer_address","category":"$.message.catalog['bpp/providers'][*].items[*].category_id","_CONTINUE_":"!(attr are present) || !(category are present) || !(category all in applicable_categories)","applicable_categories":["Fruits and Vegetables","Masala & Seasoning","Oil & Ghee","Eggs, Meat & Fish","Cleaning & Household","Bakery, Cakes & Dairy","Pet Care","Stationery","Detergents and Dishwash","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Pasta, Soup and Noodles","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Cooking and Baking Needs","Tinned and Processed Food","Atta, Flours and Sooji","Rice and Rice Products","Dals and Pulses","Salt, Sugar and Jaggery","Energy and Soft Drinks","Water","Tea and Coffee","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Vegetables","Frozen Snacks"],"_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_ADDRESS",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_ADDRESS**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].manufacturer_or_packer_address must be present in the payload

> **Skip if:**
>
>     - **Any of these must be true:**
>       - **Any of these must be true:**
>         - $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].manufacturer_or_packer_address is not in the payload
>         - $.message.catalog['bpp/providers'][*].items[*].category_id is not in the payload
>       - not all elements of $.message.catalog['bpp/providers'][*].items[*].category_id are in ["Fruits and Vegetables", "Masala & Seasoning", "Oil & Ghee", "Eggs, Meat & Fish", "Cleaning & Household", "Bakery, Cakes & Dairy", "Pet Care", "Stationery", "Detergents and Dishwash", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Pasta, Soup and Noodles", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Cooking and Baking Needs", "Tinned and Processed Food", "Atta, Flours and Sooji", "Rice and Rice Products", "Dals and Pulses", "Salt, Sugar and Jaggery", "Energy and Soft Drinks", "Water", "Tea and Coffee", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Vegetables", "Frozen Snacks"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_ADDRESS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_NAME")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].manufacturer_or_packer_name", true)
										validationutils.UnusedFunction(attr)
										category := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].category_id", true)
										validationutils.UnusedFunction(category)
										applicable_categories := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Masala & Seasoning`, `Oil & Ghee`, `Eggs, Meat & Fish`, `Cleaning & Household`, `Bakery, Cakes & Dairy`, `Pet Care`, `Stationery`, `Detergents and Dishwash`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Pasta, Soup and Noodles`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Cooking and Baking Needs`, `Tinned and Processed Food`, `Atta, Flours and Sooji`, `Rice and Rice Products`, `Dals and Pulses`, `Salt, Sugar and Jaggery`, `Energy and Soft Drinks`, `Water`, `Tea and Coffee`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Vegetables`, `Frozen Snacks`})
										validationutils.UnusedFunction(applicable_categories)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := ((!(validationutils.ArePresent(attr))) || (!(validationutils.ArePresent(category)))) || (!(validationutils.AllIn(category, applicable_categories)))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_NAME","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].manufacturer_or_packer_name","category":"$.message.catalog['bpp/providers'][*].items[*].category_id","_CONTINUE_":"!(attr are present) || !(category are present) || !(category all in applicable_categories)","applicable_categories":["Fruits and Vegetables","Masala & Seasoning","Oil & Ghee","Eggs, Meat & Fish","Cleaning & Household","Bakery, Cakes & Dairy","Pet Care","Stationery","Detergents and Dishwash","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Pasta, Soup and Noodles","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Cooking and Baking Needs","Tinned and Processed Food","Atta, Flours and Sooji","Rice and Rice Products","Dals and Pulses","Salt, Sugar and Jaggery","Energy and Soft Drinks","Water","Tea and Coffee","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Vegetables","Frozen Snacks"],"_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_NAME",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_NAME**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].manufacturer_or_packer_name must be present in the payload

> **Skip if:**
>
>     - **Any of these must be true:**
>       - **Any of these must be true:**
>         - $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].manufacturer_or_packer_name is not in the payload
>         - $.message.catalog['bpp/providers'][*].items[*].category_id is not in the payload
>       - not all elements of $.message.catalog['bpp/providers'][*].items[*].category_id are in ["Fruits and Vegetables", "Masala & Seasoning", "Oil & Ghee", "Eggs, Meat & Fish", "Cleaning & Household", "Bakery, Cakes & Dairy", "Pet Care", "Stationery", "Detergents and Dishwash", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Pasta, Soup and Noodles", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Cooking and Baking Needs", "Tinned and Processed Food", "Atta, Flours and Sooji", "Rice and Rice Products", "Dals and Pulses", "Salt, Sugar and Jaggery", "Energy and Soft Drinks", "Water", "Tea and Coffee", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Vegetables", "Frozen Snacks"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_NAME",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MONTH_YEAR_OF_MANUFACTURE_PACKING_IMPORT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MONTH_YEAR_OF_MANUFACTURE_PACKING_IMPORT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].month_year_of_manufacture_packing_import", true)
										validationutils.UnusedFunction(attr)
										category := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].category_id", true)
										validationutils.UnusedFunction(category)
										applicable_categories := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Masala & Seasoning`, `Oil & Ghee`, `Eggs, Meat & Fish`, `Cleaning & Household`, `Bakery, Cakes & Dairy`, `Pet Care`, `Stationery`, `Detergents and Dishwash`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Pasta, Soup and Noodles`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Cooking and Baking Needs`, `Tinned and Processed Food`, `Atta, Flours and Sooji`, `Rice and Rice Products`, `Dals and Pulses`, `Salt, Sugar and Jaggery`, `Energy and Soft Drinks`, `Water`, `Tea and Coffee`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Vegetables`, `Frozen Snacks`})
										validationutils.UnusedFunction(applicable_categories)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := ((!(validationutils.ArePresent(attr))) || (!(validationutils.ArePresent(category)))) || (!(validationutils.AllIn(category, applicable_categories)))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MONTH_YEAR_OF_MANUFACTURE_PACKING_IMPORT","attr":"$.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].month_year_of_manufacture_packing_import","category":"$.message.catalog['bpp/providers'][*].items[*].category_id","_CONTINUE_":"!(attr are present) || !(category are present) || !(category all in applicable_categories)","applicable_categories":["Fruits and Vegetables","Masala & Seasoning","Oil & Ghee","Eggs, Meat & Fish","Cleaning & Household","Bakery, Cakes & Dairy","Pet Care","Stationery","Detergents and Dishwash","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Pasta, Soup and Noodles","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Cooking and Baking Needs","Tinned and Processed Food","Atta, Flours and Sooji","Rice and Rice Products","Dals and Pulses","Salt, Sugar and Jaggery","Energy and Soft Drinks","Water","Tea and Coffee","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Vegetables","Frozen Snacks"],"_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MONTH_YEAR_OF_MANUFACTURE_PACKING_IMPORT",
												Valid:    false,
												Code:     30000,
												Description: `#### **ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MONTH_YEAR_OF_MANUFACTURE_PACKING_IMPORT**

- $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].month_year_of_manufacture_packing_import must be present in the payload

> **Skip if:**
>
>     - **Any of these must be true:**
>       - **Any of these must be true:**
>         - $.message.catalog['bpp/providers'][*].items[*]['@ondc/org/statutory_reqs_packaged_commodities'].month_year_of_manufacture_packing_import is not in the payload
>         - $.message.catalog['bpp/providers'][*].items[*].category_id is not in the payload
>       - not all elements of $.message.catalog['bpp/providers'][*].items[*].category_id are in ["Fruits and Vegetables", "Masala & Seasoning", "Oil & Ghee", "Eggs, Meat & Fish", "Cleaning & Household", "Bakery, Cakes & Dairy", "Pet Care", "Stationery", "Detergents and Dishwash", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Pasta, Soup and Noodles", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Cooking and Baking Needs", "Tinned and Processed Food", "Atta, Flours and Sooji", "Rice and Rice Products", "Dals and Pulses", "Salt, Sugar and Jaggery", "Energy and Soft Drinks", "Water", "Tea and Coffee", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Vegetables", "Frozen Snacks"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MONTH_YEAR_OF_MANUFACTURE_PACKING_IMPORT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var ITEMS_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_TAGS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_BPP_ITEMS_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BPP_ITEMS_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].tags[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`origin`, `veg_nonveg`, `image`, `timing`, `np_fees`})
												validationutils.UnusedFunction(valid)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_BPP_ITEMS_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].items[*].tags[*].code","valid":["origin","veg_nonveg","image","timing","np_fees"],"_RETURN_":"attr all in valid","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_BPP_ITEMS_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_BPP_ITEMS_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].items[*].tags[*].code must be in ["origin", "veg_nonveg", "image", "timing", "np_fees"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].items[*].tags[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_BPP_ITEMS_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_ITEMS_ORIGIN_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_ITEMS_ORIGIN_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='origin')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												tag_enum := validationutils.StringSliceToInterface([]string{`country`})
												validationutils.UnusedFunction(tag_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, tag_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_ITEMS_ORIGIN_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='origin')].list[*].code","tag_enum":["country"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_ITEMS_ORIGIN_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_ITEMS_ORIGIN_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='origin')].list[*].code must be in ["country"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='origin')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_ITEMS_ORIGIN_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var ITEMS_TAGS_ORIGIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_TAGS_ORIGIN")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='origin')].list[?(@.code=='country')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^[A-Z]{3}$`})
												validationutils.UnusedFunction(reg)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"ITEMS_TAGS_ORIGIN","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='origin')].list[?(@.code=='country')].value","reg":["^[A-Z]{3}$"],"_RETURN_":"attr follow regex reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "ITEMS_TAGS_ORIGIN",
														Valid:    false,
														Code:     30000,
														Description: `#### **ITEMS_TAGS_ORIGIN**

- All elements of $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='origin')].list[?(@.code=='country')].value must follow every regex in ["^[A-Z]{3}$"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='origin')].list[?(@.code=='country')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "ITEMS_TAGS_ORIGIN",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var ITEMS_TAGS_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_TAGS_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='image')].list[?(@.code=='type')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`back_image`})
												validationutils.UnusedFunction(var_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"ITEMS_TAGS_TYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='image')].list[?(@.code=='type')].value","var_enum":["back_image"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "ITEMS_TAGS_TYPE",
														Valid:    false,
														Code:     30000,
														Description: `#### **ITEMS_TAGS_TYPE**

- All elements of $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='image')].list[?(@.code=='type')].value must be in ["back_image"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='image')].list[?(@.code=='type')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "ITEMS_TAGS_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var ITEMS_TAGS_TYPE_VALID_URL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_TAGS_TYPE_VALID_URL")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='image')].list[?(@.code=='url')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^(https?:\/\/)?(www\.)?[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(\/[^\s]*)?$`})
												validationutils.UnusedFunction(reg)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"ITEMS_TAGS_TYPE_VALID_URL","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='image')].list[?(@.code=='url')].value","reg":["^(https?:\\\\/\\\\/)?(www\\\\.)?[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}(\\/[^\\\\s]*)?$"],"_RETURN_":"attr follow regex reg","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "ITEMS_TAGS_TYPE_VALID_URL",
														Valid:    false,
														Code:     30000,
														Description: `#### **ITEMS_TAGS_TYPE_VALID_URL**

- All elements of $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='image')].list[?(@.code=='url')].value must follow every regex in ["^(https?:\\/\\/)?(www\\.)?[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}(\/[^\\s]*)?$"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='image')].list[?(@.code=='url')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "ITEMS_TAGS_TYPE_VALID_URL",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_VEG_NONVEG = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_VEG_NONVEG")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												var TAGS_VEG_NONVEG_CODES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_VEG_NONVEG_CODES")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='veg_nonveg')].list[*].code", true)
														validationutils.UnusedFunction(attr)
														var_enum := validationutils.StringSliceToInterface([]string{`veg`, `non_veg`, `egg`})
														validationutils.UnusedFunction(var_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, var_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_VEG_NONVEG_CODES","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='veg_nonveg')].list[*].code","var_enum":["veg","non_veg","egg"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_VEG_NONVEG_CODES",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_VEG_NONVEG_CODES**

- All elements of $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='veg_nonveg')].list[*].code must be in ["veg", "non_veg", "egg"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='veg_nonveg')].list[*].code is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_VEG_NONVEG_CODES",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var TAGS_VEG_NONVEG_VALUES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_VEG_NONVEG_VALUES")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='veg_nonveg')].list[*].value", true)
														validationutils.UnusedFunction(attr)
														var_enum := validationutils.StringSliceToInterface([]string{`yes`})
														validationutils.UnusedFunction(var_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, var_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_VEG_NONVEG_VALUES","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='veg_nonveg')].list[*].value","var_enum":["yes"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_VEG_NONVEG_VALUES",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_VEG_NONVEG_VALUES**

- All elements of $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='veg_nonveg')].list[*].value must be in ["yes"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].items[*].tags[?(@.code=='veg_nonveg')].list[*].value is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_VEG_NONVEG_VALUES",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}

												var testFunctions = validationutils.TestFunctionArray{
													TAGS_VEG_NONVEG_CODES,
													TAGS_VEG_NONVEG_VALUES,
												}

												allResults := make([]validationutils.ValidationOutput, 0)

												for _, testFunc := range testFunctions {
													results, err := testFunc(input)
													if err != nil {
														return nil, err
													}
													allResults = append(allResults, results...)
												}

												subResults = allResults
												// if all subResults are valid, then valid is true
												valid = true
												for _, res := range subResults {
													if !res.Valid {
														valid = false
														break
													}
												}

												configureDebugInfo = `NESTED_TEST_OBJECT`

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_VEG_NONVEG",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_BPP_ITEMS_VALID_TAGS,
											TAGS_ITEMS_ORIGIN_VALID_TAGS,
											ITEMS_TAGS_ORIGIN,
											ITEMS_TAGS_TYPE,
											ITEMS_TAGS_TYPE_VALID_URL,
											TAGS_VEG_NONVEG,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "ITEMS_TAGS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									ITEMS_ID,
									ITEMS_RATING,
									ITEMS_TIME_LABEL,
									ITEMS_TIME_TIMESTAMP,
									ITEMS_DESCRIPTOR_NAME,
									ITEMS_DESCRIPTOR_SYMBOL,
									ITEMS_DESCRIPTOR_SHORT_DESC,
									ITEMS_DESCRIPTOR_CODE,
									ITEMS_DESCRIPTOR_IMAGES,
									ITEMS_QUANTITY_UNITIZED_MEASURE_UNIT,
									ITEMS_QUANTITY_UNITIZED_MEASURE_VALUE,
									ITEMS_QUANTITY_AVAILABLE_COUNT,
									ITEMS_QUANTITY_MAXIMUM_COUNT,
									ITEMS_PRICE_CURRENCY,
									ITEMS_PRICE_VALUE,
									ITEMS_PRICE_MAXIMUM_VALUE,
									ITEMS_CATEGORY_ID,
									ITEMS_FULFILLMENT_ID,
									ITEMS_LOCATION_ID,
									ITEMS_RETURNABLE,
									ITEMS_CANCELLABLE,
									ITEMS_RETURN_WINDOW,
									ITEMS_SELLER_PICKUP_RETURN,
									ITEMS_TIME_TO_SHIP,
									ITEMS_AVAILABLE_ON_COD,
									ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_ADDITIVES_INFO,
									ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_BRAND_OWNER_FSSAI_LICENSE_NO,
									ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_IMPORTER_FSSAI_LICENSE_NO,
									ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_NUTRITIONAL_INFO,
									ITEMS_STATUTORY_REQS_PREPACKAGED_FOOD_OTHER_FSSAI_LICENSE_NO,
									ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_COMMON_OR_GENERIC_NAME_OF_COMMODITY,
									ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_ADDRESS,
									ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MANUFACTURER_OR_PACKER_NAME,
									ITEMS_STATUTORY_REQS_PACKAGED_COMMODITIES_MONTH_YEAR_OF_MANUFACTURE_PACKING_IMPORT,
									ITEMS_TAGS,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_ITEMS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_OFFERS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_OFFERS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var OFFERS_DESCRIPTOR_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test OFFERS_DESCRIPTOR_CODE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].offers[*].descriptor.code", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`discount`, `buyXgetY`, `freebie`, `slab`, `combo`, `delivery`})
										validationutils.UnusedFunction(var_enum)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"OFFERS_DESCRIPTOR_CODE","attr":"$.message.catalog['bpp/providers'][*].offers[*].descriptor.code","var_enum":["discount","buyXgetY","freebie","slab","combo","delivery"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "OFFERS_DESCRIPTOR_CODE",
												Valid:    false,
												Code:     30000,
												Description: `#### **OFFERS_DESCRIPTOR_CODE**

- All elements of $.message.catalog['bpp/providers'][*].offers[*].descriptor.code must be in ["discount", "buyXgetY", "freebie", "slab", "combo", "delivery"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].offers[*].descriptor.code is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "OFFERS_DESCRIPTOR_CODE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var BPP_PROVIDERS_OFFERS_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test BPP_PROVIDERS_OFFERS_TAGS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_OFFERS_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_OFFERS_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].offers[*].tags[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`qualifier`, `benefit`, `meta`, `finance_terms`})
												validationutils.UnusedFunction(valid)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_OFFERS_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].offers[*].tags[*].code","valid":["qualifier","benefit","meta","finance_terms"],"_RETURN_":"attr all in valid","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_OFFERS_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_OFFERS_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].offers[*].tags[*].code must be in ["qualifier", "benefit", "meta", "finance_terms"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].offers[*].tags[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_OFFERS_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_QUALIFIER = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_QUALIFIER")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												var TAGS_QUALIFIER_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_QUALIFIER_VALID_TAGS")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='qualifier')].list[*].code", true)
														validationutils.UnusedFunction(attr)
														tag_enum := validationutils.StringSliceToInterface([]string{`min_value`, `item_count`, `item_count_upper`})
														validationutils.UnusedFunction(tag_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, tag_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_QUALIFIER_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='qualifier')].list[*].code","tag_enum":["min_value","item_count","item_count_upper"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_QUALIFIER_VALID_TAGS",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_QUALIFIER_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='qualifier')].list[*].code must be in ["min_value", "item_count", "item_count_upper"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='qualifier')].list[*].code is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_QUALIFIER_VALID_TAGS",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}

												var testFunctions = validationutils.TestFunctionArray{
													TAGS_QUALIFIER_VALID_TAGS,
												}

												allResults := make([]validationutils.ValidationOutput, 0)

												for _, testFunc := range testFunctions {
													results, err := testFunc(input)
													if err != nil {
														return nil, err
													}
													allResults = append(allResults, results...)
												}

												subResults = allResults
												// if all subResults are valid, then valid is true
												valid = true
												for _, res := range subResults {
													if !res.Valid {
														valid = false
														break
													}
												}

												configureDebugInfo = `NESTED_TEST_OBJECT`

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_QUALIFIER",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_BENEFIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BENEFIT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												var TAGS_BENEFIT_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BENEFIT_VALID_TAGS")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='benefit')].list[*].code", true)
														validationutils.UnusedFunction(attr)
														tag_enum := validationutils.StringSliceToInterface([]string{`value_type`, `value`, `value_cap`, `item_count`, `item_id`, `item_value`})
														validationutils.UnusedFunction(tag_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, tag_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_BENEFIT_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='benefit')].list[*].code","tag_enum":["value_type","value","value_cap","item_count","item_id","item_value"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_BENEFIT_VALID_TAGS",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_BENEFIT_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='benefit')].list[*].code must be in ["value_type", "value", "value_cap", "item_count", "item_id", "item_value"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='benefit')].list[*].code is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_BENEFIT_VALID_TAGS",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var TAGS_BENEFIT_VALUE_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BENEFIT_VALUE_TYPE")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='benefit')].list[?(@.code=='value_type')].value", true)
														validationutils.UnusedFunction(attr)
														var_enum := validationutils.StringSliceToInterface([]string{`percent`, `amount`})
														validationutils.UnusedFunction(var_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, var_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_BENEFIT_VALUE_TYPE","attr":"$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='benefit')].list[?(@.code=='value_type')].value","var_enum":["percent","amount"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_BENEFIT_VALUE_TYPE",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_BENEFIT_VALUE_TYPE**

- All elements of $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='benefit')].list[?(@.code=='value_type')].value must be in ["percent", "amount"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='benefit')].list[?(@.code=='value_type')].value is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_BENEFIT_VALUE_TYPE",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}

												var testFunctions = validationutils.TestFunctionArray{
													TAGS_BENEFIT_VALID_TAGS,
													TAGS_BENEFIT_VALUE_TYPE,
												}

												allResults := make([]validationutils.ValidationOutput, 0)

												for _, testFunc := range testFunctions {
													results, err := testFunc(input)
													if err != nil {
														return nil, err
													}
													allResults = append(allResults, results...)
												}

												subResults = allResults
												// if all subResults are valid, then valid is true
												valid = true
												for _, res := range subResults {
													if !res.Valid {
														valid = false
														break
													}
												}

												configureDebugInfo = `NESTED_TEST_OBJECT`

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_BENEFIT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_META = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_META")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												var TAGS_META_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_META_VALID_TAGS")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[*].code", true)
														validationutils.UnusedFunction(attr)
														tag_enum := validationutils.StringSliceToInterface([]string{`additive`, `auto`})
														validationutils.UnusedFunction(tag_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, tag_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_META_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[*].code","tag_enum":["additive","auto"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_META_VALID_TAGS",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_META_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[*].code must be in ["additive", "auto"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[*].code is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_META_VALID_TAGS",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var TAGS_META_ADDITIVE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_META_ADDITIVE")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[?(@.code=='additive')].value", true)
														validationutils.UnusedFunction(attr)
														var_enum := validationutils.StringSliceToInterface([]string{`yes`, `no`})
														validationutils.UnusedFunction(var_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, var_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_META_ADDITIVE","attr":"$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[?(@.code=='additive')].value","var_enum":["yes","no"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_META_ADDITIVE",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_META_ADDITIVE**

- All elements of $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[?(@.code=='additive')].value must be in ["yes", "no"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[?(@.code=='additive')].value is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_META_ADDITIVE",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var TAGS_META_AUTO = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_META_AUTO")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[?(@.code=='auto')].value", true)
														validationutils.UnusedFunction(attr)
														var_enum := validationutils.StringSliceToInterface([]string{`yes`, `no`})
														validationutils.UnusedFunction(var_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, var_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_META_AUTO","attr":"$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[?(@.code=='auto')].value","var_enum":["yes","no"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_META_AUTO",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_META_AUTO**

- All elements of $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[?(@.code=='auto')].value must be in ["yes", "no"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='meta')].list[?(@.code=='auto')].value is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_META_AUTO",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}

												var testFunctions = validationutils.TestFunctionArray{
													TAGS_META_VALID_TAGS,
													TAGS_META_ADDITIVE,
													TAGS_META_AUTO,
												}

												allResults := make([]validationutils.ValidationOutput, 0)

												for _, testFunc := range testFunctions {
													results, err := testFunc(input)
													if err != nil {
														return nil, err
													}
													allResults = append(allResults, results...)
												}

												subResults = allResults
												// if all subResults are valid, then valid is true
												valid = true
												for _, res := range subResults {
													if !res.Valid {
														valid = false
														break
													}
												}

												configureDebugInfo = `NESTED_TEST_OBJECT`

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_META",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_FINANCE_TERMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_FINANCE_TERMS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												var TAGS_FINANCE_TERMS_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_FINANCE_TERMS_VALID_TAGS")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='finance_terms')].list[*].code", true)
														validationutils.UnusedFunction(attr)
														tag_enum := validationutils.StringSliceToInterface([]string{`subvention_type`, `subvention_amount`})
														validationutils.UnusedFunction(tag_enum)
														var_star := validationutils.StringSliceToInterface([]string{`*`})
														validationutils.UnusedFunction(var_star)
														verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
														validationutils.UnusedFunction(verification_attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.AllIn(attr, tag_enum)

														configureDebugInfo = `{"_NAME_":"TAGS_FINANCE_TERMS_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='finance_terms')].list[*].code","tag_enum":["subvention_type","subvention_amount"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "TAGS_FINANCE_TERMS_VALID_TAGS",
																Valid:    false,
																Code:     30000,
																Description: `#### **TAGS_FINANCE_TERMS_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='finance_terms')].list[*].code must be in ["subvention_type", "subvention_amount"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].offers[*].tags[?(@.code=='finance_terms')].list[*].code is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "TAGS_FINANCE_TERMS_VALID_TAGS",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}

												var testFunctions = validationutils.TestFunctionArray{
													TAGS_FINANCE_TERMS_VALID_TAGS,
												}

												allResults := make([]validationutils.ValidationOutput, 0)

												for _, testFunc := range testFunctions {
													results, err := testFunc(input)
													if err != nil {
														return nil, err
													}
													allResults = append(allResults, results...)
												}

												subResults = allResults
												// if all subResults are valid, then valid is true
												valid = true
												for _, res := range subResults {
													if !res.Valid {
														valid = false
														break
													}
												}

												configureDebugInfo = `NESTED_TEST_OBJECT`

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_FINANCE_TERMS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_OFFERS_VALID_TAGS,
											TAGS_QUALIFIER,
											TAGS_BENEFIT,
											TAGS_META,
											TAGS_FINANCE_TERMS,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "BPP_PROVIDERS_OFFERS_TAGS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									OFFERS_DESCRIPTOR_CODE,
									BPP_PROVIDERS_OFFERS_TAGS,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_OFFERS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PROVIDERS_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PROVIDERS_TAGS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var TAGS_PROVIDERS_VALID_TIMING_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDERS_VALID_TIMING_TAGS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].tags[?(@.code=='timing')].list[?(@.code=='type')].value", true)
										validationutils.UnusedFunction(attr)
										var_star := validationutils.StringSliceToInterface([]string{`*`})
										validationutils.UnusedFunction(var_star)
										verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
										validationutils.UnusedFunction(verification_attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"TAGS_PROVIDERS_VALID_TIMING_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].tags[?(@.code=='timing')].list[?(@.code=='type')].value","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDERS_VALID_TIMING_TAGS",
												Valid:    false,
												Code:     30000,
												Description: `#### **TAGS_PROVIDERS_VALID_TIMING_TAGS**

- $.message.catalog['bpp/providers'][*].tags[?(@.code=='timing')].list[?(@.code=='type')].value must be present in the payload

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].tags[?(@.code=='timing')].list[?(@.code=='type')].value is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_PROVIDERS_VALID_TIMING_TAGS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_PROVIDERS_SERVICEABILITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDERS_SERVICEABILITY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_PROVIDER_SERVICABILITY_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_SERVICABILITY_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].tags[?(@.code=='serviceability')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												tag_enum := validationutils.StringSliceToInterface([]string{`location`, `category`, `type`, `val`, `day_from`, `day_to`, `time_from`, `time_to`, `unit`})
												validationutils.UnusedFunction(tag_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, tag_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_PROVIDER_SERVICABILITY_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].tags[?(@.code=='serviceability')].list[*].code","tag_enum":["location","category","type","val","day_from","day_to","time_from","time_to","unit"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDER_SERVICABILITY_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_PROVIDER_SERVICABILITY_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].tags[?(@.code=='serviceability')].list[*].code must be in ["location", "category", "type", "val", "day_from", "day_to", "time_from", "time_to", "unit"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].tags[?(@.code=='serviceability')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDER_SERVICABILITY_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_PROVIDERS_SERVICEABILITY_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDERS_SERVICEABILITY_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].tags[?(@.code=='serviceability')].list[?(@.code=='type')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`10`, `11`, `12`, `13`})
												validationutils.UnusedFunction(var_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_PROVIDERS_SERVICEABILITY_TYPE","attr":"$.message.catalog['bpp/providers'][*].tags[?(@.code=='serviceability')].list[?(@.code=='type')].value","var_enum":["10","11","12","13"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDERS_SERVICEABILITY_TYPE",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_PROVIDERS_SERVICEABILITY_TYPE**

- All elements of $.message.catalog['bpp/providers'][*].tags[?(@.code=='serviceability')].list[?(@.code=='type')].value must be in ["10", "11", "12", "13"]`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDERS_SERVICEABILITY_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_PROVIDERS_SERVICEABILITY_UNIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDERS_SERVICEABILITY_UNIT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].tags[?(@.code=='serviceability')].list[?(@.code=='unit')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`km`, `geojson`, `country`, `pincode`})
												validationutils.UnusedFunction(var_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_PROVIDERS_SERVICEABILITY_UNIT","attr":"$.message.catalog['bpp/providers'][*].tags[?(@.code=='serviceability')].list[?(@.code=='unit')].value","var_enum":["km","geojson","country","pincode"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDERS_SERVICEABILITY_UNIT",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_PROVIDERS_SERVICEABILITY_UNIT**

- All elements of $.message.catalog['bpp/providers'][*].tags[?(@.code=='serviceability')].list[?(@.code=='unit')].value must be in ["km", "geojson", "country", "pincode"]`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDERS_SERVICEABILITY_UNIT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_PROVIDER_SERVICABILITY_VALID_TAGS,
											TAGS_PROVIDERS_SERVICEABILITY_TYPE,
											TAGS_PROVIDERS_SERVICEABILITY_UNIT,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_PROVIDERS_SERVICEABILITY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_PROVIDERS_ORDER_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDERS_ORDER_VALUE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_PROVIDER_ORDER_VALUE_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_ORDER_VALUE_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].tags[?(@.code=='order_value')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												tag_enum := validationutils.StringSliceToInterface([]string{`min_value`})
												validationutils.UnusedFunction(tag_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, tag_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_PROVIDER_ORDER_VALUE_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].tags[?(@.code=='order_value')].list[*].code","tag_enum":["min_value"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDER_ORDER_VALUE_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_PROVIDER_ORDER_VALUE_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].tags[?(@.code=='order_value')].list[*].code must be in ["min_value"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].tags[?(@.code=='order_value')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDER_ORDER_VALUE_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_PROVIDERS_ORDER_VALUE_MIN_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDERS_ORDER_VALUE_MIN_VALUE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].tags[?(@.code=='order_value')].list[?(@.code=='min_value')].value", true)
												validationutils.UnusedFunction(attr)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"TAGS_PROVIDERS_ORDER_VALUE_MIN_VALUE","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].tags[?(@.code=='order_value')].list[?(@.code=='min_value')].value","_RETURN_":"attr are present","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDERS_ORDER_VALUE_MIN_VALUE",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_PROVIDERS_ORDER_VALUE_MIN_VALUE**

- $.message.catalog['bpp/providers'][*].tags[?(@.code=='order_value')].list[?(@.code=='min_value')].value must be present in the payload

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].tags[?(@.code=='order_value')].list[?(@.code=='min_value')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDERS_ORDER_VALUE_MIN_VALUE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_PROVIDER_ORDER_VALUE_VALID_TAGS,
											TAGS_PROVIDERS_ORDER_VALUE_MIN_VALUE,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_PROVIDERS_ORDER_VALUE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_PROVIDERS_CATALOG_LINK = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDERS_CATALOG_LINK")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_PROVIDERS_CATALOG_LINK_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDERS_CATALOG_LINK_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].tags[?(@.code=='catalog_link')].list[?(@.code=='type')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`link`, `inline`})
												validationutils.UnusedFunction(var_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_PROVIDERS_CATALOG_LINK_TYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].tags[?(@.code=='catalog_link')].list[?(@.code=='type')].value","var_enum":["link","inline"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDERS_CATALOG_LINK_TYPE",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_PROVIDERS_CATALOG_LINK_TYPE**

- All elements of $.message.catalog['bpp/providers'][*].tags[?(@.code=='catalog_link')].list[?(@.code=='type')].value must be in ["link", "inline"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].tags[?(@.code=='catalog_link')].list[?(@.code=='type')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDERS_CATALOG_LINK_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_PROVIDERS_CATALOG_LINK_TYPE,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_PROVIDERS_CATALOG_LINK",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_PROVIDERS_TIMING = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDERS_TIMING")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_PROVIDER_TIMING_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_TIMING_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].tags[?(@.code=='timing')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												tag_enum := validationutils.StringSliceToInterface([]string{`type`, `location`, `day_from`, `day_to`, `time_from`, `time_to`})
												validationutils.UnusedFunction(tag_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, tag_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_PROVIDER_TIMING_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].tags[?(@.code=='timing')].list[*].code","tag_enum":["type","location","day_from","day_to","time_from","time_to"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDER_TIMING_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_PROVIDER_TIMING_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].tags[?(@.code=='timing')].list[*].code must be in ["type", "location", "day_from", "day_to", "time_from", "time_to"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].tags[?(@.code=='timing')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDER_TIMING_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_PROVIDER_TIMING_VALID_TAGS,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_PROVIDERS_TIMING",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_PROVIDERS_NP_FEES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDERS_NP_FEES")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_PROVIDER_NP_FEES_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDER_NP_FEES_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].tags[?(@.code=='np_fees')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												tag_enum := validationutils.StringSliceToInterface([]string{`channel_margin_type`, `channel_margin_value`})
												validationutils.UnusedFunction(tag_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, tag_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_PROVIDER_NP_FEES_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].tags[?(@.code=='np_fees')].list[*].code","tag_enum":["channel_margin_type","channel_margin_value"],"_RETURN_":"attr all in tag_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDER_NP_FEES_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_PROVIDER_NP_FEES_VALID_TAGS**

- All elements of $.message.catalog['bpp/providers'][*].tags[?(@.code=='np_fees')].list[*].code must be in ["channel_margin_type", "channel_margin_value"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].tags[?(@.code=='np_fees')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDER_NP_FEES_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TAGS_PROVIDERS_NP_FEES_CHANNEL_MARGIN_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_PROVIDERS_NP_FEES_CHANNEL_MARGIN_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/providers'][*].tags[?(@.code=='np_fees')].list[?(@.code=='channel_margin_type')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`percent`, `amount`})
												validationutils.UnusedFunction(var_enum)
												var_star := validationutils.StringSliceToInterface([]string{`*`})
												validationutils.UnusedFunction(var_star)
												verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
												validationutils.UnusedFunction(verification_attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"TAGS_PROVIDERS_NP_FEES_CHANNEL_MARGIN_TYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.catalog['bpp/providers'][*].tags[?(@.code=='np_fees')].list[?(@.code=='channel_margin_type')].value","var_enum":["percent","amount"],"_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_PROVIDERS_NP_FEES_CHANNEL_MARGIN_TYPE",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_PROVIDERS_NP_FEES_CHANNEL_MARGIN_TYPE**

- All elements of $.message.catalog['bpp/providers'][*].tags[?(@.code=='np_fees')].list[?(@.code=='channel_margin_type')].value must be in ["percent", "amount"]

> **Skip if:**
>
>     - $.message.catalog['bpp/providers'][*].tags[?(@.code=='np_fees')].list[?(@.code=='channel_margin_type')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_PROVIDERS_NP_FEES_CHANNEL_MARGIN_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_PROVIDER_NP_FEES_VALID_TAGS,
											TAGS_PROVIDERS_NP_FEES_CHANNEL_MARGIN_TYPE,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_PROVIDERS_NP_FEES",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									TAGS_PROVIDERS_VALID_TIMING_TAGS,
									TAGS_PROVIDERS_SERVICEABILITY,
									TAGS_PROVIDERS_ORDER_VALUE,
									TAGS_PROVIDERS_CATALOG_LINK,
									TAGS_PROVIDERS_TIMING,
									TAGS_PROVIDERS_NP_FEES,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PROVIDERS_TAGS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							PROVIDERS_ID,
							PROVIDERS_RATING,
							PROVIDERS_TIME_LABEL,
							PROVIDERS_TIME_TIMESTAMP,
							PROVIDERS_TAGS_VALID_ENUMS,
							PROVIDERS_FULFILLMENTS,
							PROVIDERS_DESCRIPTOR,
							PROVIDERS_TTL,
							PROVIDERS_LOCATIONS,
							PROVIDERS_CATEGORIES,
							PROVIDERS_ITEMS,
							PROVIDERS_OFFERS,
							PROVIDERS_TAGS,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CATALOG_BPP_PROVIDERS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var CATALOG_BPP_FULFILLMENTS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CATALOG_BPP_FULFILLMENTS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var BPP_FULFILLMENTS_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BPP_FULFILLMENTS_TYPE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.catalog['bpp/fulfillments'][*].type", true)
								validationutils.UnusedFunction(attr)
								var_enum := validationutils.StringSliceToInterface([]string{`Delivery`, `Self-Pickup`, `Buyer-Delivery`})
								validationutils.UnusedFunction(var_enum)
								var_star := validationutils.StringSliceToInterface([]string{`*`})
								validationutils.UnusedFunction(var_star)
								verification_attr := validationutils.GetJsonPath(testObjMap, "$._EXTERNAL._SELF.context.city", true)
								validationutils.UnusedFunction(verification_attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, var_enum)

								configureDebugInfo = `{"_NAME_":"BPP_FULFILLMENTS_TYPE","attr":"$.message.catalog['bpp/fulfillments'][*].type","var_enum":["Delivery","Self-Pickup","Buyer-Delivery"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum","var_star":["*"],"verification_attr":"$._EXTERNAL._SELF.context.city"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "BPP_FULFILLMENTS_TYPE",
										Valid:    false,
										Code:     30000,
										Description: `#### **BPP_FULFILLMENTS_TYPE**

- All elements of $.message.catalog['bpp/fulfillments'][*].type must be in ["Delivery", "Self-Pickup", "Buyer-Delivery"]

> **Skip if:**
>
>     - $.message.catalog['bpp/fulfillments'][*].type is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BPP_FULFILLMENTS_TYPE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							BPP_FULFILLMENTS_TYPE,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CATALOG_BPP_FULFILLMENTS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					CATALOG_BPP_DESCRIPTOR,
					CATALOG_BPP_PROVIDERS,
					CATALOG_BPP_FULFILLMENTS,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "ON_SEARCH_CATALOG",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}

		var testFunctions = validationutils.TestFunctionArray{
			ON_SEARCH_CONTEXT,
			ON_SEARCH_CATALOG,
		}

		allResults := make([]validationutils.ValidationOutput, 0)

		for _, testFunc := range testFunctions {
			results, err := testFunc(input)
			if err != nil {
				return nil, err
			}
			allResults = append(allResults, results...)
		}

		subResults = allResults
		// if all subResults are valid, then valid is true
		valid = true
		for _, res := range subResults {
			if !res.Valid {
				valid = false
				break
			}
		}

		configureDebugInfo = `NESTED_TEST_OBJECT`

		delete(testObjMap, "_EXTERNAL")
	}

	result := validationutils.ValidationOutput{
		TestName: "On_searchValidations",
		Valid:    valid,
		Code:     0,
		DebugInfo: &validationutils.DebugInfo{
			FedConfig: configureDebugInfo,
		},
	}

	if valid {
		result.Code = 200
	} else {
		result.Code = 30000
	}

	results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
	results = append(results, result)
	results = append(results, subResults...)

	return results, nil
}
