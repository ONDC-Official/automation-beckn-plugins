// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.

package jsonvalidations

import (
	"fmt"
	"validationpkg/validationutils"
)

func Update_Tests(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	totalResults, err := UpdateValidations(input)
	if err != nil {
		return nil, err
	}

	if !input.Config.Debug {
		for i := range totalResults {
			totalResults[i].DebugInfo = nil
		}
	}

	if input.Config.HideParentErrors {
		// Delete results with valid false and no description
		filtered := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid && r.Description == "" {
				continue
			}
			filtered = append(filtered, r)
		}
		totalResults = filtered
	}

	if input.Config.OnlyInvalid {
		res := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid {
				res = append(res, r)
			}
		}

		if len(res) == 0 {
			// Find the overall test result
			var targetSuccess *validationutils.ValidationOutput
			for i := range totalResults {
				if totalResults[i].TestName == "UpdateValidations" {
					targetSuccess = &totalResults[i]
					break
				}
			}

			if targetSuccess == nil {
				panic("Critical: Overall test result not found")
			}

			return []validationutils.ValidationOutput{*targetSuccess}, nil
		}

		return res, nil
	}

	return totalResults, nil
}

var UpdateValidations = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	scope := validationutils.GetJsonPath(input.Payload, "$", true)

	subResults := make([]validationutils.ValidationOutput, 0)
	valid := true
	configureDebugInfo := ""
	for _, testObj := range scope {
		testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("Invalid object structure in scope for test UpdateValidations")
		}

		testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

		var UPDATE_CONTEXT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test UPDATE_CONTEXT")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				action := validationutils.StringSliceToInterface([]string{`update`})
				validationutils.UnusedFunction(action)

				var CONTEXT_REQUIRED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CONTEXT_REQUIRED_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_DOMAIN")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_DOMAIN","attr":"$.context.domain","_RETURN_":"attr are present","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_DOMAIN",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_DOMAIN**

- $.context.domain must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_DOMAIN",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_ACTION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_ACTION","attr":"$.context.action","_RETURN_":"attr are present","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_ACTION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_ACTION**

- $.context.action must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_ACTION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_COUNTRY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_COUNTRY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.country", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_COUNTRY","attr":"$.context.country","_RETURN_":"attr are present","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_COUNTRY",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_COUNTRY**

- $.context.country must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_COUNTRY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_CONTEXT_CODE_14 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_CODE_14")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.city", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^(std:\d{3,5}|\*)$`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_CODE_14","attr":"$.context.city","reg":["^(std:\\\\d{3,5}|\\\\*)$"],"_RETURN_":"attr follow regex reg","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_CONTEXT_CODE_14",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_CONTEXT_CODE_14**

- All elements of $.context.city must follow every regex in ["^(std:\\d{3,5}|\\*)$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_CODE_14",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_VERSION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.core_version", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_VERSION","attr":"$.context.core_version","_RETURN_":"attr are present","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_VERSION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_VERSION**

- $.context.core_version must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_VERSION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BAP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BAP_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BAP_ID","attr":"$.context.bap_id","_RETURN_":"attr are present","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BAP_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BAP_ID**

- $.context.bap_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BAP_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BAP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BAP_URI","attr":"$.context.bap_uri","_RETURN_":"attr are present","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BAP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BAP_URI**

- $.context.bap_uri must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BAP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BPP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BPP_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BPP_ID","search":["search"],"attr":"$.context.bpp_id","_CONTINUE_":"(action equal to search)","_RETURN_":"attr are present","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BPP_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BPP_ID**

- $.context.bpp_id must be present in the payload

> **Skip if:**
>
>     - ["update"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BPP_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BPP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BPP_URI","search":["search"],"_CONTINUE_":"(action equal to search)","attr":"$.context.bpp_uri","_RETURN_":"attr are present","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BPP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BPP_URI**

- $.context.bpp_uri must be present in the payload

> **Skip if:**
>
>     - ["update"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BPP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TRANSACTION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TRANSACTION_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.transaction_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TRANSACTION_ID","attr":"$.context.transaction_id","_RETURN_":"attr are present","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TRANSACTION_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TRANSACTION_ID**

- $.context.transaction_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TRANSACTION_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_MESSAGE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_MESSAGE_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.message_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_MESSAGE_ID","attr":"$.context.message_id","_RETURN_":"attr are present","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_MESSAGE_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_MESSAGE_ID**

- $.context.message_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_MESSAGE_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TIMESTAMP")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.timestamp", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TIMESTAMP","attr":"$.context.timestamp","reg":["^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}Z$"],"_RETURN_":"attr follow regex reg","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TIMESTAMP",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TIMESTAMP**

- All elements of $.context.timestamp must follow every regex in ["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TIMESTAMP",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
								validationutils.UnusedFunction(attr)
								optional_vars := validationutils.StringSliceToInterface([]string{`on_search`, `on_select`, `on_confirm`, `on_init`, `on_cancel`, `on_track`, `on_update`, `on_status`})
								validationutils.UnusedFunction(optional_vars)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.AllIn(action, optional_vars)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TTL","attr":"$.context.ttl","optional_vars":["on_search","on_select","on_confirm","on_init","on_cancel","on_track","on_update","on_status"],"_CONTINUE_":"(action all in optional_vars)","_RETURN_":"attr are present","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TTL**

- $.context.ttl must be present in the payload

> **Skip if:**
>
>     - all elements of ["update"] are in ["on_search", "on_select", "on_confirm", "on_init", "on_cancel", "on_track", "on_update", "on_status"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CONTEXT_REQUIRED_DOMAIN,
							CONTEXT_REQUIRED_ACTION,
							CONTEXT_REQUIRED_COUNTRY,
							REQUIRED_CONTEXT_CODE_14,
							CONTEXT_REQUIRED_VERSION,
							CONTEXT_REQUIRED_BAP_ID,
							CONTEXT_REQUIRED_BAP_URI,
							CONTEXT_REQUIRED_BPP_ID,
							CONTEXT_REQUIRED_BPP_URI,
							CONTEXT_REQUIRED_TRANSACTION_ID,
							CONTEXT_REQUIRED_MESSAGE_ID,
							CONTEXT_REQUIRED_TIMESTAMP,
							CONTEXT_REQUIRED_TTL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CONTEXT_REQUIRED",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var CONTEXT_ENUM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CONTEXT_ENUM_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_DOMAIN")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								domain := validationutils.StringSliceToInterface([]string{`ONDC:RET10`})
								validationutils.UnusedFunction(domain)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.EqualTo(attr, domain)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_DOMAIN","domain":["ONDC:RET10"],"attr":"$.context.domain","_RETURN_":"attr equal to domain","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_DOMAIN",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_DOMAIN**

- $.context.domain must equal ["ONDC:RET10"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_DOMAIN",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_ENUM_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_ACTION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.EqualTo(attr, action)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_ACTION","attr":"$.context.action","_RETURN_":"attr equal to action","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_ACTION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_ACTION**

- $.context.action must equal ["update"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_ACTION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_ENUM_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_VERSION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								version := validationutils.StringSliceToInterface([]string{`1.2.5`})
								validationutils.UnusedFunction(version)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.core_version", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.AllIn(attr, version)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_VERSION","version":["1.2.5"],"attr":"$.context.core_version","_RETURN_":"attr all in version","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_VERSION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_VERSION**

- All elements of $.context.core_version must be in ["1.2.5"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_VERSION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_BAP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^https?\:\/\/`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_BAP_URI","attr":"$.context.bap_uri","reg":["^https?\\:\\/\\/"],"_RETURN_":"attr follow regex reg","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_BAP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_BAP_URI**

- All elements of $.context.bap_uri must follow every regex in ["^https?\:\/\/"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_BAP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_BPP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^https?\:\/\/`})
								validationutils.UnusedFunction(reg)
								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_BPP_URI","attr":"$.context.bpp_uri","reg":["^https?\\:\\/\\/"],"_RETURN_":"attr follow regex reg","search":["search"],"_CONTINUE_":"(action equal to search)","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_BPP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_BPP_URI**

- All elements of $.context.bpp_uri must follow every regex in ["^https?\:\/\/"]

> **Skip if:**
>
>     - ["update"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_BPP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^P(?=\d|T)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$`})
								validationutils.UnusedFunction(reg)
								optional_vars := validationutils.StringSliceToInterface([]string{`on_search`, `on_select`, `on_confirm`, `on_init`, `on_cancel`, `on_track`, `on_update`, `on_status`})
								validationutils.UnusedFunction(optional_vars)
								action := validationutils.StringSliceToInterface([]string{`update`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.AllIn(action, optional_vars)
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_TTL","attr":"$.context.ttl","reg":["^P(?=\\\\d|T)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?(\\\\d+S)?)?$"],"optional_vars":["on_search","on_select","on_confirm","on_init","on_cancel","on_track","on_update","on_status"],"_CONTINUE_":"(action all in optional_vars)","_RETURN_":"attr follow regex reg","action":["update"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_TTL**

- All elements of $.context.ttl must follow every regex in ["^P(?=\\d|T)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$"]

> **Skip if:**
>
>     - all elements of ["update"] are in ["on_search", "on_select", "on_confirm", "on_init", "on_cancel", "on_track", "on_update", "on_status"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CONTEXT_ENUM_DOMAIN,
							CONTEXT_ENUM_ACTION,
							CONTEXT_ENUM_VERSION,
							CONTEXT_REG_BAP_URI,
							CONTEXT_REG_BPP_URI,
							CONTEXT_REG_TTL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CONTEXT_ENUM",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					CONTEXT_REQUIRED,
					CONTEXT_ENUM,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "UPDATE_CONTEXT",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var UPDATE_TARGET = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test UPDATE_TARGET")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				attr := validationutils.GetJsonPath(testObjMap, "$.message.update_target", true)
				validationutils.UnusedFunction(attr)
				var_enum := validationutils.StringSliceToInterface([]string{`payment`, `item`, `billing`, `fulfillment`})
				validationutils.UnusedFunction(var_enum)

				validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, var_enum))

				configureDebugInfo = `{"_NAME_":"UPDATE_TARGET","attr":"$.message.update_target","var_enum":["payment","item","billing","fulfillment"],"_RETURN_":"attr are present && attr all in var_enum"}`

				if !validate {
					result := validationutils.ValidationOutput{
						TestName: "UPDATE_TARGET",
						Valid:    false,
						Code:     30000,
						Description: `#### **UPDATE_TARGET**

**All of the following must be true:**
  - $.message.update_target must be present in the payload
  - All elements of $.message.update_target must be in ["payment", "item", "billing", "fulfillment"]`,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}
					delete(testObjMap, "_EXTERNAL")
					return []validationutils.ValidationOutput{result}, nil
				}

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "UPDATE_TARGET",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var UPDATE_ORDER = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test UPDATE_ORDER")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				var ORDER_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.order.id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"ORDER_ID","attr":"$.message.order.id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "ORDER_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **ORDER_ID**

- $.message.order.id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_FULFILLMENTS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_FULFILLMENTS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var FULFILLMENTS_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].id", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"FULFILLMENTS_ID","attr":"$.message.order.fulfillments[*].id","_RETURN_":"attr are present","_CONTINUE_":"!(attr are present)"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **FULFILLMENTS_ID**

- $.message.order.fulfillments[*].id must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].id is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_TYPE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].type", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"FULFILLMENTS_TYPE","attr":"$.message.order.fulfillments[*].type","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_TYPE",
										Valid:    false,
										Code:     30000,
										Description: `#### **FULFILLMENTS_TYPE**

- $.message.order.fulfillments[*].type must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].type is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_TYPE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_END = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var FULFILLMENTS_END_INSTRUCTIONS_ADDITIONAL_DESC_CONTENT_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_INSTRUCTIONS_ADDITIONAL_DESC_CONTENT_TYPE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.instructions.additional_desc.content_type", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`text/plain`, `text/html`})
										validationutils.UnusedFunction(var_enum)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_INSTRUCTIONS_ADDITIONAL_DESC_CONTENT_TYPE","attr":"$.message.order.fulfillments[*].end.instructions.additional_desc.content_type","var_enum":["text/plain","text/html"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_INSTRUCTIONS_ADDITIONAL_DESC_CONTENT_TYPE",
												Valid:    false,
												Code:     30000,
												Description: `#### **FULFILLMENTS_END_INSTRUCTIONS_ADDITIONAL_DESC_CONTENT_TYPE**

- $.message.order.fulfillments[*].end.instructions.additional_desc.content_type must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.instructions.additional_desc.content_type is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_END_INSTRUCTIONS_ADDITIONAL_DESC_CONTENT_TYPE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									FULFILLMENTS_END_INSTRUCTIONS_ADDITIONAL_DESC_CONTENT_TYPE,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_END",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_TAGS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var FULFILLMENTS_TAGS_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_TAGS_VALID_TAGS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[*].code", true)
										validationutils.UnusedFunction(attr)
										valid := validationutils.StringSliceToInterface([]string{`return_request`, `update_state`, `cancel_request`, `update_fulfillment_time`, `update_agent_details`, `update_label`, `reverseqc_output`, `bnp_receivables_claim`, `bnp_diff_weight`, `bnp_diff_length`, `bnp_diff_breadth`, `bnp_diff_height`, `update_verification`, `update_state`, `update_fulfillment_delay`, `linked_order_diff`, `update_sale_invoice`, `linked_order_diff_proof`})
										validationutils.UnusedFunction(valid)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.AllIn(attr, valid)

										configureDebugInfo = `{"_NAME_":"FULFILLMENTS_TAGS_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[*].code","valid":["return_request","update_state","cancel_request","update_fulfillment_time","update_agent_details","update_label","reverseqc_output","bnp_receivables_claim","bnp_diff_weight","bnp_diff_length","bnp_diff_breadth","bnp_diff_height","update_verification","update_state","update_fulfillment_delay","linked_order_diff","update_sale_invoice","linked_order_diff_proof"],"_RETURN_":"attr all in valid"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_TAGS_VALID_TAGS",
												Valid:    false,
												Code:     30000,
												Description: `#### **FULFILLMENTS_TAGS_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[*].code must be in ["return_request", "update_state", "cancel_request", "update_fulfillment_time", "update_agent_details", "update_label", "reverseqc_output", "bnp_receivables_claim", "bnp_diff_weight", "bnp_diff_length", "bnp_diff_breadth", "bnp_diff_height", "update_verification", "update_state", "update_fulfillment_delay", "linked_order_diff", "update_sale_invoice", "linked_order_diff_proof"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[*].code is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_TAGS_VALID_TAGS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_RETURN_REQUEST = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_RETURN_REQUEST")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_RETURN_REQUEST_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_RETURN_REQUEST_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`id`, `item_id`, `parent_item_id`, `item_quantity`, `reason_id`, `reason_desc`, `images`, `ttl_approval`, `ttl_reverseqc`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_RETURN_REQUEST_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[*].code","valid":["id","item_id","parent_item_id","item_quantity","reason_id","reason_desc","images","ttl_approval","ttl_reverseqc"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_RETURN_REQUEST_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_RETURN_REQUEST_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[*].code must be in ["id", "item_id", "parent_item_id", "item_quantity", "reason_id", "reason_desc", "images", "ttl_approval", "ttl_reverseqc"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_RETURN_REQUEST_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RETURN_REQUEST_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RETURN_REQUEST_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='id')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"RETURN_REQUEST_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='id')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RETURN_REQUEST_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **RETURN_REQUEST_ID**

- $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='id')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='id')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RETURN_REQUEST_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RETURN_REQUEST_ITEM_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RETURN_REQUEST_ITEM_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='item_id')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"RETURN_REQUEST_ITEM_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='item_id')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RETURN_REQUEST_ITEM_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **RETURN_REQUEST_ITEM_ID**

- $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='item_id')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='item_id')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RETURN_REQUEST_ITEM_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RETURN_REQUEST_PARENT_ITEM_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RETURN_REQUEST_PARENT_ITEM_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='parent_item_id')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"RETURN_REQUEST_PARENT_ITEM_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='parent_item_id')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RETURN_REQUEST_PARENT_ITEM_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **RETURN_REQUEST_PARENT_ITEM_ID**

- $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='parent_item_id')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='parent_item_id')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RETURN_REQUEST_PARENT_ITEM_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RETURN_REQUEST_ITEM_QUANTITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RETURN_REQUEST_ITEM_QUANTITY")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='item_quantity')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"RETURN_REQUEST_ITEM_QUANTITY","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='item_quantity')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RETURN_REQUEST_ITEM_QUANTITY",
														Valid:    false,
														Code:     30000,
														Description: `#### **RETURN_REQUEST_ITEM_QUANTITY**

- $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='item_quantity')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='item_quantity')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RETURN_REQUEST_ITEM_QUANTITY",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RETURN_REQUEST_REASON_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RETURN_REQUEST_REASON_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='reason_id')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^\d{3}$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"RETURN_REQUEST_REASON_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='reason_id')].value","reg":["^\\\\d{3}$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RETURN_REQUEST_REASON_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **RETURN_REQUEST_REASON_ID**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='reason_id')].value must follow every regex in ["^\\d{3}$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='reason_id')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RETURN_REQUEST_REASON_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RETURN_REQUEST_REASON_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RETURN_REQUEST_REASON_DESC")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='reason_desc')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"RETURN_REQUEST_REASON_DESC","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='reason_desc')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RETURN_REQUEST_REASON_DESC",
														Valid:    false,
														Code:     30000,
														Description: `#### **RETURN_REQUEST_REASON_DESC**

- $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='reason_desc')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='reason_desc')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RETURN_REQUEST_REASON_DESC",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RETURN_REQUEST_IMAGES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RETURN_REQUEST_IMAGES")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='images')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"RETURN_REQUEST_IMAGES","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='images')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RETURN_REQUEST_IMAGES",
														Valid:    false,
														Code:     30000,
														Description: `#### **RETURN_REQUEST_IMAGES**

- $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='images')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='images')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RETURN_REQUEST_IMAGES",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RETURN_REQUEST_TTL_APPROVAL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RETURN_REQUEST_TTL_APPROVAL")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='ttl_approval')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^PT[0-9]+H$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"RETURN_REQUEST_TTL_APPROVAL","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='ttl_approval')].value","reg":["^PT[0-9]+H$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RETURN_REQUEST_TTL_APPROVAL",
														Valid:    false,
														Code:     30000,
														Description: `#### **RETURN_REQUEST_TTL_APPROVAL**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='ttl_approval')].value must follow every regex in ["^PT[0-9]+H$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='ttl_approval')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RETURN_REQUEST_TTL_APPROVAL",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RETURN_REQUEST_TTL_REVERSEQC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RETURN_REQUEST_TTL_REVERSEQC")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='ttl_reverseqc')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^P[0-9]+D$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"RETURN_REQUEST_TTL_REVERSEQC","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='ttl_reverseqc')].value","reg":["^P[0-9]+D$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RETURN_REQUEST_TTL_REVERSEQC",
														Valid:    false,
														Code:     30000,
														Description: `#### **RETURN_REQUEST_TTL_REVERSEQC**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='ttl_reverseqc')].value must follow every regex in ["^P[0-9]+D$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='return_request')].list[?(@.code=='ttl_reverseqc')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RETURN_REQUEST_TTL_REVERSEQC",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_RETURN_REQUEST_VALID_TAGS,
											RETURN_REQUEST_ID,
											RETURN_REQUEST_ITEM_ID,
											RETURN_REQUEST_PARENT_ITEM_ID,
											RETURN_REQUEST_ITEM_QUANTITY,
											RETURN_REQUEST_REASON_ID,
											RETURN_REQUEST_REASON_DESC,
											RETURN_REQUEST_IMAGES,
											RETURN_REQUEST_TTL_APPROVAL,
											RETURN_REQUEST_TTL_REVERSEQC,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_RETURN_REQUEST",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_UPDATE_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_STATE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_UPDATE_STATE_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_STATE_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`state`, `reason_id`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_UPDATE_STATE_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[*].code","valid":["state","reason_id"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_UPDATE_STATE_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_UPDATE_STATE_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[*].code must be in ["state", "reason_id"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_UPDATE_STATE_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var UPDATE_STATE_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test UPDATE_STATE_STATE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='state')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`Order-picked-up`, `Order-delivered`})
												validationutils.UnusedFunction(var_enum)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"UPDATE_STATE_STATE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='state')].value","var_enum":["Order-picked-up","Order-delivered"],"_RETURN_":"attr all in var_enum"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "UPDATE_STATE_STATE",
														Valid:    false,
														Code:     30000,
														Description: `#### **UPDATE_STATE_STATE**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='state')].value must be in ["Order-picked-up", "Order-delivered"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='state')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "UPDATE_STATE_STATE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var UPDATE_STATE_REASON_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test UPDATE_STATE_REASON_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='reason_id')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"UPDATE_STATE_REASON_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='reason_id')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "UPDATE_STATE_REASON_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **UPDATE_STATE_REASON_ID**

- $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='reason_id')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='reason_id')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "UPDATE_STATE_REASON_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_UPDATE_STATE_VALID_TAGS,
											UPDATE_STATE_STATE,
											UPDATE_STATE_REASON_ID,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_UPDATE_STATE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_CANCEL_REQUEST = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_CANCEL_REQUEST")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_CANCEL_REQUEST_RETRY_COUNT_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_CANCEL_REQUEST_RETRY_COUNT_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`retry_count`, `reason_id`, `initiated_by`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_CANCEL_REQUEST_RETRY_COUNT_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[*].code","valid":["retry_count","reason_id","initiated_by"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_CANCEL_REQUEST_RETRY_COUNT_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_CANCEL_REQUEST_RETRY_COUNT_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[*].code must be in ["retry_count", "reason_id", "initiated_by"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_CANCEL_REQUEST_RETRY_COUNT_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var CANCEL_REQUEST_RETRY_COUNT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_REQUEST_RETRY_COUNT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='retry_count')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"CANCEL_REQUEST_RETRY_COUNT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='retry_count')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "CANCEL_REQUEST_RETRY_COUNT",
														Valid:    false,
														Code:     30000,
														Description: `#### **CANCEL_REQUEST_RETRY_COUNT**

- $.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='retry_count')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='retry_count')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "CANCEL_REQUEST_RETRY_COUNT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var CANCEL_REQUEST_REASON_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_REQUEST_REASON_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='reason_id')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"CANCEL_REQUEST_REASON_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='reason_id')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "CANCEL_REQUEST_REASON_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **CANCEL_REQUEST_REASON_ID**

- $.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='reason_id')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='reason_id')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "CANCEL_REQUEST_REASON_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var CANCEL_REQUEST_INITIATED_BY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_REQUEST_INITIATED_BY")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='initiated_by')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"CANCEL_REQUEST_INITIATED_BY","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='initiated_by')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "CANCEL_REQUEST_INITIATED_BY",
														Valid:    false,
														Code:     30000,
														Description: `#### **CANCEL_REQUEST_INITIATED_BY**

- $.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='initiated_by')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='cancel_request')].list[?(@.code=='initiated_by')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "CANCEL_REQUEST_INITIATED_BY",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_CANCEL_REQUEST_RETRY_COUNT_VALID_TAGS,
											CANCEL_REQUEST_RETRY_COUNT,
											CANCEL_REQUEST_REASON_ID,
											CANCEL_REQUEST_INITIATED_BY,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_CANCEL_REQUEST",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_UPDATE_FULFILLMENT_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_FULFILLMENT_TIME")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_UPDATE_FULFILLMENT_TIME_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_FULFILLMENT_TIME_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`state`, `timestamp`, `start_time`, `end_time`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_UPDATE_FULFILLMENT_TIME_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[*].code","valid":["state","timestamp","start_time","end_time"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_UPDATE_FULFILLMENT_TIME_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_UPDATE_FULFILLMENT_TIME_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[*].code must be in ["state", "timestamp", "start_time", "end_time"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_UPDATE_FULFILLMENT_TIME_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var UPDATE_FULFILLMENT_TIME_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test UPDATE_FULFILLMENT_TIME_STATE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='state')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`Order-picked-up`, `Order-delivered`})
												validationutils.UnusedFunction(var_enum)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"UPDATE_FULFILLMENT_TIME_STATE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='state')].value","var_enum":["Order-picked-up","Order-delivered"],"_RETURN_":"attr all in var_enum"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "UPDATE_FULFILLMENT_TIME_STATE",
														Valid:    false,
														Code:     30000,
														Description: `#### **UPDATE_FULFILLMENT_TIME_STATE**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='state')].value must be in ["Order-picked-up", "Order-delivered"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='state')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "UPDATE_FULFILLMENT_TIME_STATE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var UPDATE_FULFILLMENT_TIME_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test UPDATE_FULFILLMENT_TIME_TIMESTAMP")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='timestamp')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"UPDATE_FULFILLMENT_TIME_TIMESTAMP","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='timestamp')].value","reg":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*Z$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "UPDATE_FULFILLMENT_TIME_TIMESTAMP",
														Valid:    false,
														Code:     30000,
														Description: `#### **UPDATE_FULFILLMENT_TIME_TIMESTAMP**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='timestamp')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='timestamp')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "UPDATE_FULFILLMENT_TIME_TIMESTAMP",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var UPDATE_FULFILLMENT_TIME_START = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test UPDATE_FULFILLMENT_TIME_START")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='start_time')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"UPDATE_FULFILLMENT_TIME_START","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='start_time')].value","reg":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*Z$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "UPDATE_FULFILLMENT_TIME_START",
														Valid:    false,
														Code:     30000,
														Description: `#### **UPDATE_FULFILLMENT_TIME_START**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='start_time')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='start_time')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "UPDATE_FULFILLMENT_TIME_START",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var UPDATE_FULFILLMENT_TIME_END = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test UPDATE_FULFILLMENT_TIME_END")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='end_time')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"UPDATE_FULFILLMENT_TIME_END","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='end_time')].value","reg":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*Z$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "UPDATE_FULFILLMENT_TIME_END",
														Valid:    false,
														Code:     30000,
														Description: `#### **UPDATE_FULFILLMENT_TIME_END**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='end_time')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_time')].list[?(@.code=='end_time')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "UPDATE_FULFILLMENT_TIME_END",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_UPDATE_FULFILLMENT_TIME_VALID_TAGS,
											UPDATE_FULFILLMENT_TIME_STATE,
											UPDATE_FULFILLMENT_TIME_TIMESTAMP,
											UPDATE_FULFILLMENT_TIME_START,
											UPDATE_FULFILLMENT_TIME_END,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_UPDATE_FULFILLMENT_TIME",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_UPDATE_AGENT_DETAILS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_AGENT_DETAILS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_UPDATE_AGENT_DETAILS_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_AGENT_DETAILS_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`name`, `phone`, `provider_id`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_UPDATE_AGENT_DETAILS_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[*].code","valid":["name","phone","provider_id"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_UPDATE_AGENT_DETAILS_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_UPDATE_AGENT_DETAILS_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[*].code must be in ["name", "phone", "provider_id"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_UPDATE_AGENT_DETAILS_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var AGENT_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test AGENT_NAME")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='name')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"AGENT_NAME","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='name')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "AGENT_NAME",
														Valid:    false,
														Code:     30000,
														Description: `#### **AGENT_NAME**

- $.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='name')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='name')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "AGENT_NAME",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var AGENT_PHONE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test AGENT_PHONE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='phone')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"AGENT_PHONE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='phone')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "AGENT_PHONE",
														Valid:    false,
														Code:     30000,
														Description: `#### **AGENT_PHONE**

- $.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='phone')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='phone')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "AGENT_PHONE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var AGENT_PROVIDER_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test AGENT_PROVIDER_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='provider_id')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"AGENT_PROVIDER_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='provider_id')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "AGENT_PROVIDER_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **AGENT_PROVIDER_ID**

- $.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='provider_id')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_agent_details')].list[?(@.code=='provider_id')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "AGENT_PROVIDER_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_UPDATE_AGENT_DETAILS_VALID_TAGS,
											AGENT_NAME,
											AGENT_PHONE,
											AGENT_PROVIDER_ID,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_UPDATE_AGENT_DETAILS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_UPDATE_LABEL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_LABEL")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_UPDATE_LABEL_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_LABEL_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`type`, `url`, `shipping`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_UPDATE_LABEL_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[*].code","valid":["type","url","shipping"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_UPDATE_LABEL_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_UPDATE_LABEL_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[*].code must be in ["type", "url", "shipping"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_UPDATE_LABEL_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var LABEL_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test LABEL_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='type')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`webp`, `png`, `jpeg`, `pdf`})
												validationutils.UnusedFunction(var_enum)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"LABEL_TYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='type')].value","var_enum":["webp","png","jpeg","pdf"],"_RETURN_":"attr all in var_enum"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "LABEL_TYPE",
														Valid:    false,
														Code:     30000,
														Description: `#### **LABEL_TYPE**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='type')].value must be in ["webp", "png", "jpeg", "pdf"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='type')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "LABEL_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var LABEL_URL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test LABEL_URL")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='url')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"LABEL_URL","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='url')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "LABEL_URL",
														Valid:    false,
														Code:     30000,
														Description: `#### **LABEL_URL**

- $.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='url')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='url')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "LABEL_URL",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var LABEL_SHIPPING = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test LABEL_SHIPPING")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='shipping')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"LABEL_SHIPPING","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='shipping')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "LABEL_SHIPPING",
														Valid:    false,
														Code:     30000,
														Description: `#### **LABEL_SHIPPING**

- $.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='shipping')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_label')].list[?(@.code=='shipping')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "LABEL_SHIPPING",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_UPDATE_LABEL_VALID_TAGS,
											LABEL_TYPE,
											LABEL_URL,
											LABEL_SHIPPING,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_UPDATE_LABEL",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_REVERSEQC_OUTPUT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_REVERSEQC_OUTPUT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_REVERSEQC_OUTPUT_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_REVERSEQC_OUTPUT_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`P001`, `P003`, `Q001`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_REVERSEQC_OUTPUT_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[*].code","valid":["P001","P003","Q001"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_REVERSEQC_OUTPUT_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_REVERSEQC_OUTPUT_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[*].code must be in ["P001", "P003", "Q001"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_REVERSEQC_OUTPUT_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RQC_P001 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RQC_P001")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='P001')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"RQC_P001","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='P001')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RQC_P001",
														Valid:    false,
														Code:     30000,
														Description: `#### **RQC_P001**

- $.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='P001')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='P001')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RQC_P001",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RQC_P003 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RQC_P003")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='P003')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"RQC_P003","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='P003')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RQC_P003",
														Valid:    false,
														Code:     30000,
														Description: `#### **RQC_P003**

- $.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='P003')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='P003')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RQC_P003",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var RQC_Q001 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test RQC_Q001")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='Q001')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`yes`, `no`})
												validationutils.UnusedFunction(var_enum)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"RQC_Q001","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='Q001')].value","var_enum":["yes","no"],"_RETURN_":"attr all in var_enum"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "RQC_Q001",
														Valid:    false,
														Code:     30000,
														Description: `#### **RQC_Q001**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='Q001')].value must be in ["yes", "no"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='reverseqc_output')].list[?(@.code=='Q001')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "RQC_Q001",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_REVERSEQC_OUTPUT_VALID_TAGS,
											RQC_P001,
											RQC_P003,
											RQC_Q001,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_REVERSEQC_OUTPUT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_BNP_RECEIVABLES_CLAIM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_RECEIVABLES_CLAIM")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_BNP_RECIEVABLES_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_RECIEVABLES_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`type`, `currency`, `value`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_BNP_RECIEVABLES_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[*].code","valid":["type","currency","value"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_BNP_RECIEVABLES_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_BNP_RECIEVABLES_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[*].code must be in ["type", "currency", "value"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_BNP_RECIEVABLES_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var CLAIM_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test CLAIM_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='type')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"CLAIM_TYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='type')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "CLAIM_TYPE",
														Valid:    false,
														Code:     30000,
														Description: `#### **CLAIM_TYPE**

- $.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='type')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='type')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "CLAIM_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var CLAIM_CURRENCY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test CLAIM_CURRENCY")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='currency')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"CLAIM_CURRENCY","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='currency')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "CLAIM_CURRENCY",
														Valid:    false,
														Code:     30000,
														Description: `#### **CLAIM_CURRENCY**

- $.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='currency')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='currency')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "CLAIM_CURRENCY",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var CLAIM_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test CLAIM_VALUE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='value')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"CLAIM_VALUE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='value')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "CLAIM_VALUE",
														Valid:    false,
														Code:     30000,
														Description: `#### **CLAIM_VALUE**

- $.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='value')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_receivables_claim')].list[?(@.code=='value')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "CLAIM_VALUE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_BNP_RECIEVABLES_VALID_TAGS,
											CLAIM_TYPE,
											CLAIM_CURRENCY,
											CLAIM_VALUE,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_BNP_RECEIVABLES_CLAIM",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_BNP_DIFF_WEIGHT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_DIFF_WEIGHT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_BNP_DIFF_WEIGHT_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_DIFF_WEIGHT_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`unit`, `value`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_BNP_DIFF_WEIGHT_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[*].code","valid":["unit","value"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_BNP_DIFF_WEIGHT_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_BNP_DIFF_WEIGHT_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[*].code must be in ["unit", "value"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_BNP_DIFF_WEIGHT_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DIFF_WEIGHT_UNIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DIFF_WEIGHT_UNIT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[?(@.code=='unit')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`unit`, `dozen`, `gram`, `kilogram`, `tonne`, `litre`, `millilitre`})
												validationutils.UnusedFunction(var_enum)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"DIFF_WEIGHT_UNIT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[?(@.code=='unit')].value","var_enum":["unit","dozen","gram","kilogram","tonne","litre","millilitre"],"_RETURN_":"attr all in var_enum"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DIFF_WEIGHT_UNIT",
														Valid:    false,
														Code:     30000,
														Description: `#### **DIFF_WEIGHT_UNIT**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[?(@.code=='unit')].value must be in ["unit", "dozen", "gram", "kilogram", "tonne", "litre", "millilitre"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[?(@.code=='unit')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DIFF_WEIGHT_UNIT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DIFF_WEIGHT_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DIFF_WEIGHT_VALUE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[?(@.code=='value')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"DIFF_WEIGHT_VALUE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[?(@.code=='value')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DIFF_WEIGHT_VALUE",
														Valid:    false,
														Code:     30000,
														Description: `#### **DIFF_WEIGHT_VALUE**

- $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[?(@.code=='value')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_weight')].list[?(@.code=='value')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DIFF_WEIGHT_VALUE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_BNP_DIFF_WEIGHT_VALID_TAGS,
											DIFF_WEIGHT_UNIT,
											DIFF_WEIGHT_VALUE,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_BNP_DIFF_WEIGHT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_BNP_DIFF_LENGTH = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_DIFF_LENGTH")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_BNP_DIFF_LENGTH_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_DIFF_LENGTH_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`unit`, `value`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_BNP_DIFF_LENGTH_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[*].code","valid":["unit","value"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_BNP_DIFF_LENGTH_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_BNP_DIFF_LENGTH_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[*].code must be in ["unit", "value"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_BNP_DIFF_LENGTH_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DIFF_LENGTH_UNIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DIFF_LENGTH_UNIT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[?(@.code=='unit')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`centimeter`, `meter`})
												validationutils.UnusedFunction(var_enum)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"DIFF_LENGTH_UNIT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[?(@.code=='unit')].value","var_enum":["centimeter","meter"],"_RETURN_":"attr all in var_enum"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DIFF_LENGTH_UNIT",
														Valid:    false,
														Code:     30000,
														Description: `#### **DIFF_LENGTH_UNIT**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[?(@.code=='unit')].value must be in ["centimeter", "meter"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[?(@.code=='unit')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DIFF_LENGTH_UNIT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DIFF_LENGTH_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DIFF_LENGTH_VALUE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[?(@.code=='value')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"DIFF_LENGTH_VALUE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[?(@.code=='value')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DIFF_LENGTH_VALUE",
														Valid:    false,
														Code:     30000,
														Description: `#### **DIFF_LENGTH_VALUE**

- $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[?(@.code=='value')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_length')].list[?(@.code=='value')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DIFF_LENGTH_VALUE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_BNP_DIFF_LENGTH_VALID_TAGS,
											DIFF_LENGTH_UNIT,
											DIFF_LENGTH_VALUE,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_BNP_DIFF_LENGTH",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_BNP_DIFF_BREADTH = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_DIFF_BREADTH")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_BNP_DIFF_BREADTH_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_DIFF_BREADTH_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`unit`, `value`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_BNP_DIFF_BREADTH_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[*].code","valid":["unit","value"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_BNP_DIFF_BREADTH_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_BNP_DIFF_BREADTH_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[*].code must be in ["unit", "value"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_BNP_DIFF_BREADTH_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DIFF_BREADTH_UNIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DIFF_BREADTH_UNIT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[?(@.code=='unit')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"DIFF_BREADTH_UNIT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[?(@.code=='unit')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DIFF_BREADTH_UNIT",
														Valid:    false,
														Code:     30000,
														Description: `#### **DIFF_BREADTH_UNIT**

- $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[?(@.code=='unit')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[?(@.code=='unit')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DIFF_BREADTH_UNIT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DIFF_BREADTH_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DIFF_BREADTH_VALUE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[?(@.code=='value')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"DIFF_BREADTH_VALUE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[?(@.code=='value')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DIFF_BREADTH_VALUE",
														Valid:    false,
														Code:     30000,
														Description: `#### **DIFF_BREADTH_VALUE**

- $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[?(@.code=='value')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_breadth')].list[?(@.code=='value')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DIFF_BREADTH_VALUE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_BNP_DIFF_BREADTH_VALID_TAGS,
											DIFF_BREADTH_UNIT,
											DIFF_BREADTH_VALUE,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_BNP_DIFF_BREADTH",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_BNP_DIFF_HEIGHT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_DIFF_HEIGHT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_BNP_DIFF_HEIGHT_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_DIFF_HEIGHT_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`unit`, `value`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_BNP_DIFF_HEIGHT_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[*].code","valid":["unit","value"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_BNP_DIFF_HEIGHT_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_BNP_DIFF_HEIGHT_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[*].code must be in ["unit", "value"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_BNP_DIFF_HEIGHT_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DIFF_HEIGHT_UNIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DIFF_HEIGHT_UNIT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[?(@.code=='unit')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"DIFF_HEIGHT_UNIT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[?(@.code=='unit')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DIFF_HEIGHT_UNIT",
														Valid:    false,
														Code:     30000,
														Description: `#### **DIFF_HEIGHT_UNIT**

- $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[?(@.code=='unit')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[?(@.code=='unit')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DIFF_HEIGHT_UNIT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DIFF_HEIGHT_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DIFF_HEIGHT_VALUE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[?(@.code=='value')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"DIFF_HEIGHT_VALUE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[?(@.code=='value')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DIFF_HEIGHT_VALUE",
														Valid:    false,
														Code:     30000,
														Description: `#### **DIFF_HEIGHT_VALUE**

- $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[?(@.code=='value')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='bnp_diff_height')].list[?(@.code=='value')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DIFF_HEIGHT_VALUE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_BNP_DIFF_HEIGHT_VALID_TAGS,
											DIFF_HEIGHT_UNIT,
											DIFF_HEIGHT_VALUE,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_BNP_DIFF_HEIGHT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_UPDATE_VERIFICATION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_VERIFICATION")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_UPDATE_VERIFICATION_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_VERIFICATION_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`type`, `value`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_UPDATE_VERIFICATION_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[*].code","valid":["type","value"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_UPDATE_VERIFICATION_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_UPDATE_VERIFICATION_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[*].code must be in ["type", "value"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_UPDATE_VERIFICATION_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var VERIFICATION_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test VERIFICATION_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[?(@.code=='type')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"VERIFICATION_TYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[?(@.code=='type')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "VERIFICATION_TYPE",
														Valid:    false,
														Code:     30000,
														Description: `#### **VERIFICATION_TYPE**

- $.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[?(@.code=='type')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[?(@.code=='type')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "VERIFICATION_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var VERIFICATION_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test VERIFICATION_VALUE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[?(@.code=='value')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"VERIFICATION_VALUE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[?(@.code=='value')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "VERIFICATION_VALUE",
														Valid:    false,
														Code:     30000,
														Description: `#### **VERIFICATION_VALUE**

- $.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[?(@.code=='value')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_verification')].list[?(@.code=='value')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "VERIFICATION_VALUE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_UPDATE_VERIFICATION_VALID_TAGS,
											VERIFICATION_TYPE,
											VERIFICATION_VALUE,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_UPDATE_VERIFICATION",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_UPDATE_STATE_TIMESTAMPS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_STATE_TIMESTAMPS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_UPDATE_STATE_TIMESTAMPS_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_STATE_TIMESTAMPS_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`timestamp`, `start_time`, `end_time`, `state`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_UPDATE_STATE_TIMESTAMPS_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[*].code","valid":["timestamp","start_time","end_time","state"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_UPDATE_STATE_TIMESTAMPS_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_UPDATE_STATE_TIMESTAMPS_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[*].code must be in ["timestamp", "start_time", "end_time", "state"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_UPDATE_STATE_TIMESTAMPS_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var STATE_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test STATE_TIMESTAMP")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='timestamp')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"STATE_TIMESTAMP","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='timestamp')].value","reg":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*Z$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "STATE_TIMESTAMP",
														Valid:    false,
														Code:     30000,
														Description: `#### **STATE_TIMESTAMP**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='timestamp')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='timestamp')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "STATE_TIMESTAMP",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var STATE_START_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test STATE_START_TIME")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='start_time')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"STATE_START_TIME","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='start_time')].value","reg":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*Z$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "STATE_START_TIME",
														Valid:    false,
														Code:     30000,
														Description: `#### **STATE_START_TIME**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='start_time')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='start_time')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "STATE_START_TIME",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var STATE_END_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test STATE_END_TIME")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='end_time')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"STATE_END_TIME","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='end_time')].value","reg":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*Z$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "STATE_END_TIME",
														Valid:    false,
														Code:     30000,
														Description: `#### **STATE_END_TIME**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='end_time')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_state')].list[?(@.code=='end_time')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "STATE_END_TIME",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_UPDATE_STATE_TIMESTAMPS_VALID_TAGS,
											STATE_TIMESTAMP,
											STATE_START_TIME,
											STATE_END_TIME,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_UPDATE_STATE_TIMESTAMPS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_UPDATE_FULFILLMENT_DELAY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_FULFILLMENT_DELAY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_UPDATE_FULFILLMENT_DELAY_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_FULFILLMENT_DELAY_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`state`, `start_time`, `end_time`, `reason_id`, `attempt`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_UPDATE_FULFILLMENT_DELAY_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[*].code","valid":["state","start_time","end_time","reason_id","attempt"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_UPDATE_FULFILLMENT_DELAY_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_UPDATE_FULFILLMENT_DELAY_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[*].code must be in ["state", "start_time", "end_time", "reason_id", "attempt"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_UPDATE_FULFILLMENT_DELAY_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DELAY_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DELAY_STATE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='state')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`Order-picked-up`, `Order-delivered`})
												validationutils.UnusedFunction(var_enum)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"DELAY_STATE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='state')].value","var_enum":["Order-picked-up","Order-delivered"],"_RETURN_":"attr all in var_enum"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DELAY_STATE",
														Valid:    false,
														Code:     30000,
														Description: `#### **DELAY_STATE**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='state')].value must be in ["Order-picked-up", "Order-delivered"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='state')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DELAY_STATE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DELAY_REASON_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DELAY_REASON_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='reason_id')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"DELAY_REASON_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='reason_id')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DELAY_REASON_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **DELAY_REASON_ID**

- $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='reason_id')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='reason_id')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DELAY_REASON_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DELAY_START_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DELAY_START_TIME")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='start_time')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"DELAY_START_TIME","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='start_time')].value","reg":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*Z$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DELAY_START_TIME",
														Valid:    false,
														Code:     30000,
														Description: `#### **DELAY_START_TIME**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='start_time')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='start_time')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DELAY_START_TIME",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DELAY_END_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DELAY_END_TIME")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='end_time')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"DELAY_END_TIME","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='end_time')].value","reg":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*Z$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DELAY_END_TIME",
														Valid:    false,
														Code:     30000,
														Description: `#### **DELAY_END_TIME**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='end_time')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='end_time')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DELAY_END_TIME",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DELAY_ATTEMPT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DELAY_ATTEMPT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='attempt')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`yes`, `no`})
												validationutils.UnusedFunction(var_enum)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"DELAY_ATTEMPT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='attempt')].value","var_enum":["yes","no"],"_RETURN_":"attr all in var_enum"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DELAY_ATTEMPT",
														Valid:    false,
														Code:     30000,
														Description: `#### **DELAY_ATTEMPT**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='attempt')].value must be in ["yes", "no"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_fulfillment_delay')].list[?(@.code=='attempt')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DELAY_ATTEMPT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_UPDATE_FULFILLMENT_DELAY_VALID_TAGS,
											DELAY_STATE,
											DELAY_REASON_ID,
											DELAY_START_TIME,
											DELAY_END_TIME,
											DELAY_ATTEMPT,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_UPDATE_FULFILLMENT_DELAY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_LINKED_ORDER_DIFF = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_LINKED_ORDER_DIFF")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_LINKED_ORDER_DIFF_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_LINKED_ORDER_DIFF_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`id`, `weight_unit`, `weight_value`, `dim_unit`, `length`, `breadth`, `height`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_LINKED_ORDER_DIFF_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[*].code","valid":["id","weight_unit","weight_value","dim_unit","length","breadth","height"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_LINKED_ORDER_DIFF_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_LINKED_ORDER_DIFF_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[*].code must be in ["id", "weight_unit", "weight_value", "dim_unit", "length", "breadth", "height"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_LINKED_ORDER_DIFF_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var LINKED_ORDER_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test LINKED_ORDER_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='id')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"LINKED_ORDER_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='id')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "LINKED_ORDER_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **LINKED_ORDER_ID**

- $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='id')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='id')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "LINKED_ORDER_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var LINKED_WEIGHT_UNIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test LINKED_WEIGHT_UNIT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='weight_unit')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"LINKED_WEIGHT_UNIT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='weight_unit')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "LINKED_WEIGHT_UNIT",
														Valid:    false,
														Code:     30000,
														Description: `#### **LINKED_WEIGHT_UNIT**

- $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='weight_unit')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='weight_unit')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "LINKED_WEIGHT_UNIT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var LINKED_WEIGHT_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test LINKED_WEIGHT_VALUE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='weight_value')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"LINKED_WEIGHT_VALUE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='weight_value')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "LINKED_WEIGHT_VALUE",
														Valid:    false,
														Code:     30000,
														Description: `#### **LINKED_WEIGHT_VALUE**

- $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='weight_value')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='weight_value')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "LINKED_WEIGHT_VALUE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var LINKED_DIM_UNIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test LINKED_DIM_UNIT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='dim_unit')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"LINKED_DIM_UNIT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='dim_unit')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "LINKED_DIM_UNIT",
														Valid:    false,
														Code:     30000,
														Description: `#### **LINKED_DIM_UNIT**

- $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='dim_unit')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='dim_unit')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "LINKED_DIM_UNIT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var LINKED_LENGTH = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test LINKED_LENGTH")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='length')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"LINKED_LENGTH","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='length')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "LINKED_LENGTH",
														Valid:    false,
														Code:     30000,
														Description: `#### **LINKED_LENGTH**

- $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='length')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='length')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "LINKED_LENGTH",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var LINKED_BREADTH = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test LINKED_BREADTH")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='breadth')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"LINKED_BREADTH","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='breadth')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "LINKED_BREADTH",
														Valid:    false,
														Code:     30000,
														Description: `#### **LINKED_BREADTH**

- $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='breadth')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='breadth')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "LINKED_BREADTH",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var LINKED_HEIGHT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test LINKED_HEIGHT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='height')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"LINKED_HEIGHT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='height')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "LINKED_HEIGHT",
														Valid:    false,
														Code:     30000,
														Description: `#### **LINKED_HEIGHT**

- $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='height')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff')].list[?(@.code=='height')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "LINKED_HEIGHT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_LINKED_ORDER_DIFF_VALID_TAGS,
											LINKED_ORDER_ID,
											LINKED_WEIGHT_UNIT,
											LINKED_WEIGHT_VALUE,
											LINKED_DIM_UNIT,
											LINKED_LENGTH,
											LINKED_BREADTH,
											LINKED_HEIGHT,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_LINKED_ORDER_DIFF",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_LINKED_ORDER_DIFF_PROOF = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_LINKED_ORDER_DIFF_PROOF")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_LINKED_ORDER_DIFF_PROOF_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_LINKED_ORDER_DIFF_PROOF_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`type`, `url`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_LINKED_ORDER_DIFF_PROOF_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[*].code","valid":["type","url"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_LINKED_ORDER_DIFF_PROOF_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_LINKED_ORDER_DIFF_PROOF_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[*].code must be in ["type", "url"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_LINKED_ORDER_DIFF_PROOF_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var PROOF_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test PROOF_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[?(@.code=='type')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"PROOF_TYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[?(@.code=='type')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "PROOF_TYPE",
														Valid:    false,
														Code:     30000,
														Description: `#### **PROOF_TYPE**

- $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[?(@.code=='type')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[?(@.code=='type')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "PROOF_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var PROOF_URL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test PROOF_URL")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[?(@.code=='url')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^https?://.*$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"PROOF_URL","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[?(@.code=='url')].value","reg":["^https?://.*$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "PROOF_URL",
														Valid:    false,
														Code:     30000,
														Description: `#### **PROOF_URL**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[?(@.code=='url')].value must follow every regex in ["^https?://.*$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='linked_order_diff_proof')].list[?(@.code=='url')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "PROOF_URL",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_LINKED_ORDER_DIFF_PROOF_VALID_TAGS,
											PROOF_TYPE,
											PROOF_URL,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_LINKED_ORDER_DIFF_PROOF",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_UPDATE_SALE_INVOICE_URL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_UPDATE_SALE_INVOICE_URL")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='update_sale_invoice')].list[?(@.code=='url')].value", true)
										validationutils.UnusedFunction(attr)
										reg := validationutils.StringSliceToInterface([]string{`^https?://.*$`})
										validationutils.UnusedFunction(reg)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := (validationutils.ArePresent(attr)) && (validationutils.FollowRegex(attr, reg))

										configureDebugInfo = `{"_NAME_":"TAGS_UPDATE_SALE_INVOICE_URL","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='update_sale_invoice')].list[?(@.code=='url')].value","reg":["^https?://.*$"],"_RETURN_":"attr are present && attr follow regex reg"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "TAGS_UPDATE_SALE_INVOICE_URL",
												Valid:    false,
												Code:     30000,
												Description: `#### **TAGS_UPDATE_SALE_INVOICE_URL**

**All of the following must be true:**
  - $.message.order.fulfillments[*].tags[?(@.code=='update_sale_invoice')].list[?(@.code=='url')].value must be present in the payload
  - All elements of $.message.order.fulfillments[*].tags[?(@.code=='update_sale_invoice')].list[?(@.code=='url')].value must follow every regex in ["^https?://.*$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='update_sale_invoice')].list[?(@.code=='url')].value is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_UPDATE_SALE_INVOICE_URL",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									FULFILLMENTS_TAGS_VALID_TAGS,
									TAGS_RETURN_REQUEST,
									TAGS_UPDATE_STATE,
									TAGS_CANCEL_REQUEST,
									TAGS_UPDATE_FULFILLMENT_TIME,
									TAGS_UPDATE_AGENT_DETAILS,
									TAGS_UPDATE_LABEL,
									TAGS_REVERSEQC_OUTPUT,
									TAGS_BNP_RECEIVABLES_CLAIM,
									TAGS_BNP_DIFF_WEIGHT,
									TAGS_BNP_DIFF_LENGTH,
									TAGS_BNP_DIFF_BREADTH,
									TAGS_BNP_DIFF_HEIGHT,
									TAGS_UPDATE_VERIFICATION,
									TAGS_UPDATE_STATE_TIMESTAMPS,
									TAGS_UPDATE_FULFILLMENT_DELAY,
									TAGS_LINKED_ORDER_DIFF,
									TAGS_LINKED_ORDER_DIFF_PROOF,
									TAGS_UPDATE_SALE_INVOICE_URL,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_TAGS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							FULFILLMENTS_ID,
							FULFILLMENTS_TYPE,
							FULFILLMENTS_END,
							FULFILLMENTS_TAGS,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_FULFILLMENTS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_PAYMENT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_PAYMENT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_details'][*].settlement_counterparty", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY","attr":"$.message.order.payment['@ondc/org/settlement_details'][*].settlement_counterparty","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY**

- $.message.order.payment['@ondc/org/settlement_details'][*].settlement_counterparty must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_details'][*].settlement_counterparty is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_details'][*].settlement_phase", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE","attr":"$.message.order.payment['@ondc/org/settlement_details'][*].settlement_phase","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE**

- $.message.order.payment['@ondc/org/settlement_details'][*].settlement_phase must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_details'][*].settlement_phase is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_details'][*].settlement_type", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`upi`, `neft`, `rtgs`, `wallet`, `netbanking`, `paylater`, `card`})
										validationutils.UnusedFunction(var_enum)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE","attr":"$.message.order.payment['@ondc/org/settlement_details'][*].settlement_type","_CONTINUE_":"!(attr are present)","var_enum":["upi","neft","rtgs","wallet","netbanking","paylater","card"],"_RETURN_":"attr all in var_enum"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE**

- All elements of $.message.order.payment['@ondc/org/settlement_details'][*].settlement_type must be in ["upi", "neft", "rtgs", "wallet", "netbanking", "paylater", "card"]

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_details'][*].settlement_type is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_AMOUNT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_AMOUNT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_details'][*].settlement_amount", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_AMOUNT","attr":"$.message.order.payment['@ondc/org/settlement_details'][*].settlement_amount","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_AMOUNT",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_AMOUNT**

- $.message.order.payment['@ondc/org/settlement_details'][*].settlement_amount must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_details'][*].settlement_amount is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_AMOUNT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TIMESTAMP")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_details'][*].settlement_timestamp", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TIMESTAMP","attr":"$.message.order.payment['@ondc/org/settlement_details'][*].settlement_timestamp","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TIMESTAMP",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TIMESTAMP**

- $.message.order.payment['@ondc/org/settlement_details'][*].settlement_timestamp must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_details'][*].settlement_timestamp is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TIMESTAMP",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY,
									PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE,
									PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE,
									PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_AMOUNT,
									PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TIMESTAMP,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_PAYMENT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					ORDER_ID,
					ORDER_FULFILLMENTS,
					ORDER_PAYMENT,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "UPDATE_ORDER",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}

		var testFunctions = validationutils.TestFunctionArray{
			UPDATE_CONTEXT,
			UPDATE_TARGET,
			UPDATE_ORDER,
		}

		allResults := make([]validationutils.ValidationOutput, 0)

		for _, testFunc := range testFunctions {
			results, err := testFunc(input)
			if err != nil {
				return nil, err
			}
			allResults = append(allResults, results...)
		}

		subResults = allResults
		// if all subResults are valid, then valid is true
		valid = true
		for _, res := range subResults {
			if !res.Valid {
				valid = false
				break
			}
		}

		configureDebugInfo = `NESTED_TEST_OBJECT`

		delete(testObjMap, "_EXTERNAL")
	}

	result := validationutils.ValidationOutput{
		TestName: "UpdateValidations",
		Valid:    valid,
		Code:     0,
		DebugInfo: &validationutils.DebugInfo{
			FedConfig: configureDebugInfo,
		},
	}

	if valid {
		result.Code = 200
	} else {
		result.Code = 30000
	}

	results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
	results = append(results, result)
	results = append(results, subResults...)

	return results, nil
}
