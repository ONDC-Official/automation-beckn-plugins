// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.
package validationpkg

import (
	"encoding/json"
	"fmt"
	"validationpkg/jsonvalidations"
	"validationpkg/storageutils"
	"validationpkg/validationutils"
)

// PerformL1Validations performs Level-1 validations against a payload for a given action.
//
// Output shape - ValidationOutput is a slice of:
//   - TestName: string
//   - Valid: boolean
//   - Code: number
//   - Description: *string (optional)
//   - DebugInfo: *DebugInfo (optional) with FedConfig
//
// Config - ValidationConfig (all fields optional):
//   - OnlyInvalid (default true)
//   - HideParentErrors (default true)
//   - Debug (default false)
//   - StateFullValidations (default false)
//   - UniqueKey (optional)
//   - Store (optional)
//
// Parameters:
//   - action: The action name to validate against
//   - payload: The JSON payload to validate (map[string]interface{} or struct)
//   - config: Partial ValidationConfig. Merged with defaults
//   - externalData: Extra data accessible to rules (Self will be set to normalized payload)
//
// Returns: []ValidationOutput
//
// Example:
//
//	results := PerformL1Validations("search", payload, ValidationConfig{OnlyInvalid: false}, ExternalData{})
//	// results[0] => ValidationOutput{ TestName, Valid, Code, Description, DebugInfo }
func PerformL1validations(
	action string,
	payload interface{},
	config *validationutils.ValidationConfig,
	externalData validationutils.ExternalData,
) ([]validationutils.ValidationOutput, error) {
	completeConfig := getCompleteConfig(config)

	// Validate stateful requirements
	if completeConfig.StateFullValidations {
		if completeConfig.Store == nil {
			return nil, fmt.Errorf("stateful validations require a storage interface to be provided in the config")
		}
		if completeConfig.UniqueKey == nil || *completeConfig.UniqueKey == "" {
			return nil, fmt.Errorf("stateful validations require a uniqueKey to be provided in the config")
		}
	}

	normalizedPayload := validationutils.NormalizeKeys(payload)

	// Set _SELF
	externalData.Self = normalizedPayload

	// Load stateful data if needed
	if completeConfig.StateFullValidations {
		loadedData, err := PerformL1validationsLoad(action, *completeConfig.UniqueKey, completeConfig.Store)
		if err != nil {
			return nil, fmt.Errorf("failed to load stateful data: %w", err)
		}
		// Merge loaded data with external data
		externalData = mergeExternalData(loadedData, externalData)
	}

	// Create validation input
	input := validationutils.ValidationInput{
		Payload:      normalizedPayload,
		ExternalData: externalData,
		Config:       completeConfig,
	}

	// Route to action-specific validation
	switch action {

	case "search":
		return jsonvalidations.Search_Tests(input)

	case "on_search":
		return jsonvalidations.On_search_Tests(input)

	case "select":
		return jsonvalidations.Select_Tests(input)

	case "on_select":
		return jsonvalidations.On_select_Tests(input)

	case "init":
		return jsonvalidations.Init_Tests(input)

	case "on_init":
		return jsonvalidations.On_init_Tests(input)

	case "confirm":
		return jsonvalidations.Confirm_Tests(input)

	case "on_confirm":
		return jsonvalidations.On_confirm_Tests(input)

	case "status":
		return jsonvalidations.Status_Tests(input)

	case "on_status":
		return jsonvalidations.On_status_Tests(input)

	case "update":
		return jsonvalidations.Update_Tests(input)

	case "track":
		return jsonvalidations.Track_Tests(input)

	case "on_track":
		return jsonvalidations.On_track_Tests(input)

	case "cancel":
		return jsonvalidations.Cancel_Tests(input)

	case "on_cancel":
		return jsonvalidations.On_cancel_Tests(input)

	case "issue":
		return jsonvalidations.Issue_Tests(input)

	case "on_issue":
		return jsonvalidations.On_issue_Tests(input)

	case "on_issue_status":
		return jsonvalidations.On_issue_status_Tests(input)

	case "on_update":
		return jsonvalidations.On_update_Tests(input)

	default:
		return nil, fmt.Errorf("action not found: %s", action)
	}
}

// getCompleteConfig returns a complete config with defaults
func getCompleteConfig(config *validationutils.ValidationConfig) validationutils.ValidationConfig {
	if config == nil {
		return validationutils.ValidationConfig{
			OnlyInvalid:          true,
			HideParentErrors:     true,
			StateFullValidations: false,
			Debug:                false,
		}
	}

	// Return copy with defaults for unset fields
	completeConfig := *config
	// Go doesn't have a clean way to check if bool was explicitly set,
	// so we assume false means "use default true" only if it seems intentional
	// In practice, you might want to use pointers for optional bools
	return completeConfig
}

// mergeExternalData merges loaded data with provided external data
// using JSON marshal/unmarshal for a generic merge strategy.
// Non-null fields in provided override loaded fields.
func mergeExternalData(loaded, provided validationutils.ExternalData) validationutils.ExternalData {
	// Convert to maps
	loadedBytes, _ := json.Marshal(loaded)
	providedBytes, _ := json.Marshal(provided)

	var loadedMap, providedMap map[string]interface{}
	json.Unmarshal(loadedBytes, &loadedMap)
	json.Unmarshal(providedBytes, &providedMap)

	// Merge provided into loaded
	for key, value := range providedMap {
		if value != nil {
			loadedMap[key] = value
		}
	}

	// Convert back
	var result validationutils.ExternalData
	mergedBytes, _ := json.Marshal(loadedMap)
	json.Unmarshal(mergedBytes, &result)

	return result
}

var PerformL1validationsLoad = storageutils.PerformL1validationsLoad
var PerformL1validationsSave = storageutils.PerformL1validationsSave
