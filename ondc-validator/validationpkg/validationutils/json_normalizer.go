// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.

package validationutils

import (
	"github.com/bytedance/sonic"
)

// NormalizeKeys normalizes JSON structures so that:
//   - All objects with the same property name share the union of keys seen anywhere
//   - All objects inside the same array share the union of keys at that array level
//   - Missing keys are filled with nil
func NormalizeKeys(input interface{}) interface{} {
	// Step 1: Collect templates by property name
	templatesByPropName := make(map[string]map[string]struct{})
	collectTemplates(input, templatesByPropName)

	// Step 2: Apply templates and within-array unions
	return applyTemplates(input, templatesByPropName)
}

// collectTemplates walks the data structure and collects all keys for each property name
func collectTemplates(node interface{}, templates map[string]map[string]struct{}) {
	switch v := node.(type) {
	case []interface{}:
		// Recurse into array items
		for _, item := range v {
			collectTemplates(item, templates)
		}

	case map[string]interface{}:
		// For each property: if it's an object (non-array), record its keys
		for propName, propValue := range v {
			if obj, ok := propValue.(map[string]interface{}); ok {
				// Initialize set for this property name if needed
				if templates[propName] == nil {
					templates[propName] = make(map[string]struct{})
				}
				// Add all keys from this object to the template
				for childKey := range obj {
					templates[propName][childKey] = struct{}{}
				}
			}
			// Recurse into the value
			collectTemplates(propValue, templates)
		}
	}
}

// applyTemplates applies the collected templates and array-level unions
func applyTemplates(node interface{}, templates map[string]map[string]struct{}) interface{} {
	switch v := node.(type) {
	case []interface{}:
		// Compute union of keys across all object elements at this array level
		arrayUnion := make(map[string]struct{})
		for _, item := range v {
			if obj, ok := item.(map[string]interface{}); ok {
				for key := range obj {
					arrayUnion[key] = struct{}{}
				}
			}
		}

		// Apply union to each array element
		result := make([]interface{}, len(v))
		for i, item := range v {
			if obj, ok := item.(map[string]interface{}); ok {
				// Create new object with array union keys
				next := make(map[string]interface{})

				// Copy existing keys
				for k, val := range obj {
					next[k] = val
				}

				// Add missing keys from array union
				for key := range arrayUnion {
					if _, exists := next[key]; !exists {
						next[key] = nil
					}
				}

				// Now apply templates per property name for nested objects
				for propName, propValue := range next {
					if nestedObj, ok := propValue.(map[string]interface{}); ok {
						// Align to template for this property name
						next[propName] = fillFromTemplate(propName, nestedObj, templates)
					} else {
						// Recurse for arrays or other structures
						next[propName] = applyTemplates(propValue, templates)
					}
				}
				result[i] = next
			} else {
				// Not an object, just recurse
				result[i] = applyTemplates(item, templates)
			}
		}
		return result

	case map[string]interface{}:
		out := make(map[string]interface{})
		for propName, propValue := range v {
			if nestedObj, ok := propValue.(map[string]interface{}); ok {
				// Align object to the template for this property name
				out[propName] = fillFromTemplate(propName, nestedObj, templates)
			} else {
				out[propName] = applyTemplates(propValue, templates)
			}
		}
		return out

	default:
		// Primitives unchanged
		return v
	}
}

// fillFromTemplate applies the template for a given property name
func fillFromTemplate(propName string, obj map[string]interface{}, templates map[string]map[string]struct{}) interface{} {
	// First recurse on children so nested arrays/objects also normalize
	base := applyTemplates(obj, templates).(map[string]interface{})

	// Get template for this property name
	template, hasTemplate := templates[propName]
	if !hasTemplate {
		return base // No known template keys for this prop
	}

	// Fill missing keys with nil
	filled := make(map[string]interface{})
	for k, v := range base {
		filled[k] = v
	}
	for key := range template {
		if _, exists := filled[key]; !exists {
			filled[key] = nil
		}
	}

	return filled
}

// DeepCloneJSON creates a deep clone of a JSON-serializable structure using sonic
func DeepCloneJSON(v interface{}) interface{} {
	b, err := sonic.Marshal(v)
	if err != nil {
		panic(err) // or handle error
	}
	var out interface{}
	if err := sonic.Unmarshal(b, &out); err != nil {
		panic(err)
	}
	return out
}
