// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.

package validationutils

// StorageInterface provides a standardized abstraction layer for storage operations
// that can be implemented by different storage backends (Redis, Memory, File, etc.).
//
// Implementation Notes:
//   - Keys should be strings and values are stored as strings
//   - Implementations should handle serialization/deserialization as needed
//   - Prefix-based operations allow for namespacing and bulk operations
//
// Example:
//
//	type RedisStorage struct {
//	    client *redis.Client
//	}
//
//	func (r *RedisStorage) SaveKey(uniquePrefix, key, value string) error {
//	    fullKey := fmt.Sprintf("%s:%s", uniquePrefix, key)
//	    return r.client.Set(ctx, fullKey, value, 0).Err()
//	}
//
//	storage := &RedisStorage{client: redisClient}
//	userData, _ := json.Marshal(user)
//	storage.SaveKey("app1", "user:123", string(userData))
type StorageInterface interface {
	// SaveKey saves a key-value pair to storage with a unique prefix for namespacing.
	//
	// Parameters:
	//   - uniquePrefix: A unique identifier/namespace prefix to prevent key collisions
	//   - key: The unique identifier for the stored value within the prefix namespace
	//   - value: The string value to store
	//
	// Returns error if the operation fails
	//
	// Example:
	//   sessionData, _ := json.Marshal(session)
	//   err := storage.SaveKey("app1", "session:abc123", string(sessionData))
	SaveKey(uniquePrefix string, key string, value string) error

	// GetKey retrieves a value by its key from storage within a specific namespace.
	//
	// Parameters:
	//   - uniquePrefix: The unique identifier/namespace prefix used when storing
	//   - key: The unique identifier for the value to retrieve within the prefix namespace
	//
	// Returns the stored value and error if the key does not exist
	//
	// Example:
	//   sessionData, err := storage.GetKey("app1", "session:abc123")
	//   if err != nil {
	//       // handle key not found
	//   }
	GetKey(uniquePrefix string, key string) (string, error)

	// DeleteKey removes a key-value pair from storage within a specific namespace.
	//
	// Parameters:
	//   - uniquePrefix: The unique identifier/namespace prefix used when storing
	//   - key: The unique identifier for the value to delete within the prefix namespace
	//
	// Returns error if the operation fails
	//
	// Example:
	//   err := storage.DeleteKey("app1", "session:abc123")
	DeleteKey(uniquePrefix string, key string) error

	// ListKeys lists all keys within a specific namespace/prefix.
	//
	// Parameters:
	//   - uniquePrefix: The unique identifier/namespace prefix to list keys from
	//
	// Returns an array of keys within that namespace
	//
	// Example:
	//   app1Keys, err := storage.ListKeys("app1")
	//   // Returns keys stored under the "app1" namespace
	//   // e.g., []string{"session:abc123", "user:456", "config:settings"}
	ListKeys(uniquePrefix string) ([]string, error)

	// ClearStorage clears all stored data from the storage backend.
	//
	// WARNING: This operation is destructive and cannot be undone.
	// Use with caution, especially in production environments.
	//
	// Returns error if the operation fails
	//
	// Example:
	//   err := storage.ClearStorage() // All data is now removed
	ClearStorage() error

	// KeyExists checks if a key exists in storage within a specific namespace.
	//
	// Parameters:
	//   - uniquePrefix: The unique identifier/namespace prefix to check within
	//   - key: The unique identifier to check for existence within the prefix namespace
	//
	// Returns true if the key exists, false otherwise
	//
	// Example:
	//   exists, err := storage.KeyExists("app1", "user:123")
	//   if err == nil && exists {
	//       userData, _ := storage.GetKey("app1", "user:123")
	//   }
	KeyExists(uniquePrefix string, key string) (bool, error)
}
