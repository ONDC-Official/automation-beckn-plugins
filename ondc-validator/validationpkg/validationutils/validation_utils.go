// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.

package validationutils

import (
	"fmt"
	"strconv"
	"time"

	"github.com/dlclark/regexp2"
)

// toStringSlice converts []interface{} to []string, returns false if any element is not a string
func toStringSlice(operand []interface{}) ([]string, bool) {
	result := make([]string, len(operand))
	for i, v := range operand {
		str, ok := v.(string)
		if !ok {
			// Try to convert to string
			if v == nil {
				result[i] = "null"
			} else {
				result[i] = fmt.Sprintf("%v", v)
			}
		} else {
			result[i] = str
		}
	}
	return result, true
}

func AreUnique(operand []interface{}) bool {
	strs, ok := toStringSlice(operand)
	if !ok {
		return false
	}

	valuesSet := make(map[string]struct{})
	for _, v := range strs {
		valuesSet[v] = struct{}{}
	}
	return len(valuesSet) == len(strs)
}

func ArePresent(operand []interface{}) bool {
	strs, ok := toStringSlice(operand)
	if !ok {
		return false
	}
	return NoneIn(operand, []interface{}{"null", "undefined"}) && len(strs) > 0
}

func AllIn(left []interface{}, right []interface{}) bool {
	leftStrs, ok1 := toStringSlice(left)
	rightStrs, ok2 := toStringSlice(right)
	if !ok1 || !ok2 {
		return false
	}

	if len(leftStrs) == 0 && len(rightStrs) != 0 {
		return false
	}
	for _, v := range leftStrs {
		if !contains(rightStrs, v) {
			return false
		}
	}
	return true
}

func AnyIn(left []interface{}, right []interface{}) bool {
	leftStrs, ok1 := toStringSlice(left)
	rightStrs, ok2 := toStringSlice(right)
	if !ok1 || !ok2 {
		return false
	}

	if len(leftStrs) == 0 && len(rightStrs) != 0 {
		return false
	}
	for _, v := range leftStrs {
		if contains(rightStrs, v) {
			return true
		}
	}
	return false
}

func NoneIn(left []interface{}, right []interface{}) bool {
	leftStrs, ok1 := toStringSlice(left)
	rightStrs, ok2 := toStringSlice(right)
	if !ok1 || !ok2 {
		return false
	}

	for _, v := range leftStrs {
		if contains(rightStrs, v) {
			return false
		}
	}
	return true
}

func EqualTo(left []interface{}, right []interface{}) bool {
	leftStrs, ok1 := toStringSlice(left)
	rightStrs, ok2 := toStringSlice(right)
	if !ok1 || !ok2 {
		return false
	}

	if len(leftStrs) != len(rightStrs) {
		return false
	}
	for i, v := range leftStrs {
		if v != rightStrs[i] {
			return false
		}
	}
	return true
}

func GreaterThan(left []interface{}, right []interface{}) bool {
	leftStrs, ok1 := toStringSlice(left)
	rightStrs, ok2 := toStringSlice(right)
	if !ok1 || !ok2 {
		return false
	}

	areAllISO := func(arr []string) bool {
		for _, v := range arr {
			if !isISO8601(v) {
				return false
			}
		}
		return true
	}

	areAllNumbers := func(arr []string) bool {
		for _, v := range arr {
			if _, err := strconv.ParseFloat(v, 64); err != nil {
				return false
			}
		}
		return true
	}

	if areAllISO(leftStrs) && areAllISO(rightStrs) {
		leftDates := make([]int64, len(leftStrs))
		for i, date := range leftStrs {
			t, _ := time.Parse(time.RFC3339, date)
			leftDates[i] = t.UnixMilli()
		}

		rightDates := make([]int64, len(rightStrs))
		for i, date := range rightStrs {
			t, _ := time.Parse(time.RFC3339, date)
			rightDates[i] = t.UnixMilli()
		}

		for i, ld := range leftDates {
			if i >= len(rightDates) || ld <= rightDates[i] {
				if i < len(rightDates) {
					return false
				}
			}
		}
		return true
	} else if areAllNumbers(leftStrs) && areAllNumbers(rightStrs) {
		leftNumbers := make([]float64, len(leftStrs))
		for i, v := range leftStrs {
			leftNumbers[i], _ = strconv.ParseFloat(v, 64)
		}

		rightNumbers := make([]float64, len(rightStrs))
		for i, v := range rightStrs {
			rightNumbers[i], _ = strconv.ParseFloat(v, 64)
		}

		for i, ln := range leftNumbers {
			if i >= len(rightNumbers) || ln <= rightNumbers[i] {
				if i < len(rightNumbers) {
					return false
				}
			}
		}
		return true
	}

	return false
}

func LessThan(left []interface{}, right []interface{}) bool {
	leftStrs, ok1 := toStringSlice(left)
	rightStrs, ok2 := toStringSlice(right)
	if !ok1 || !ok2 {
		return false
	}

	areAllISO := func(arr []string) bool {
		for _, v := range arr {
			if !isISO8601(v) {
				return false
			}
		}
		return true
	}

	areAllNumbers := func(arr []string) bool {
		for _, v := range arr {
			if _, err := strconv.ParseFloat(v, 64); err != nil {
				return false
			}
		}
		return true
	}

	if areAllISO(leftStrs) && areAllISO(rightStrs) {
		leftDates := make([]int64, len(leftStrs))
		for i, date := range leftStrs {
			t, _ := time.Parse(time.RFC3339, date)
			leftDates[i] = t.UnixMilli()
		}

		rightDates := make([]int64, len(rightStrs))
		for i, date := range rightStrs {
			t, _ := time.Parse(time.RFC3339, date)
			rightDates[i] = t.UnixMilli()
		}

		for i, ld := range leftDates {
			if i >= len(rightDates) || ld >= rightDates[i] {
				if i < len(rightDates) {
					return false
				}
			}
		}
		return true
	} else if areAllNumbers(leftStrs) && areAllNumbers(rightStrs) {
		leftNumbers := make([]float64, len(leftStrs))
		for i, v := range leftStrs {
			leftNumbers[i], _ = strconv.ParseFloat(v, 64)
		}

		rightNumbers := make([]float64, len(rightStrs))
		for i, v := range rightStrs {
			rightNumbers[i], _ = strconv.ParseFloat(v, 64)
		}

		for i, ln := range leftNumbers {
			if i >= len(rightNumbers) || ln >= rightNumbers[i] {
				if i < len(rightNumbers) {
					return false
				}
			}
		}
		return true
	}

	return false
}

func FollowRegex(left []interface{}, regexArray []interface{}) bool {
	leftStrs, ok1 := toStringSlice(left)
	regexStrs, ok2 := toStringSlice(regexArray)
	if !ok1 || !ok2 {
		return false
	}

	if len(leftStrs) == 0 && len(regexStrs) != 0 {
		return false
	}
	for _, regexStr := range regexStrs {
		re, err := regexp2.Compile(regexStr, 0)
		if err != nil {
			return false
		}
		for _, v := range leftStrs {
			match, err := re.MatchString(v)
			if err != nil || !match {
				return false
			}
		}
	}
	return true
}

func isISO8601(str string) bool {
	iso8601Regex, err := regexp2.Compile(`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})$`, 0)
	if err != nil {
		return false
	}

	match, err := iso8601Regex.MatchString(str)
	if err != nil || !match {
		return false
	}

	_, err = time.Parse(time.RFC3339, str)
	return err == nil
}

func contains(slice []string, item string) bool {
	for _, v := range slice {
		if v == item {
			return true
		}
	}
	return false
}

// StringSliceToInterface converts []string to []interface{}
func StringSliceToInterface(strs []string) []interface{} {
	result := make([]interface{}, len(strs))
	for i, v := range strs {
		result[i] = v
	}
	return result
}

// UnusedFunction to avoid unused variable errors
func UnusedFunction(item interface{}) {}
