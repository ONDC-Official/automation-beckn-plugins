// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.

package jsonvalidations

import (
	"fmt"
	"validationpkg/validationutils"
)

func Cancel_Tests(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	totalResults, err := CancelValidations(input)
	if err != nil {
		return nil, err
	}

	if !input.Config.Debug {
		for i := range totalResults {
			totalResults[i].DebugInfo = nil
		}
	}

	if input.Config.HideParentErrors {
		// Delete results with valid false and no description
		filtered := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid && r.Description == "" {
				continue
			}
			filtered = append(filtered, r)
		}
		totalResults = filtered
	}

	if input.Config.OnlyInvalid {
		res := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid {
				res = append(res, r)
			}
		}

		if len(res) == 0 {
			// Find the overall test result
			var targetSuccess *validationutils.ValidationOutput
			for i := range totalResults {
				if totalResults[i].TestName == "CancelValidations" {
					targetSuccess = &totalResults[i]
					break
				}
			}

			if targetSuccess == nil {
				panic("Critical: Overall test result not found")
			}

			return []validationutils.ValidationOutput{*targetSuccess}, nil
		}

		return res, nil
	}

	return totalResults, nil
}

var CancelValidations = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	scope := validationutils.GetJsonPath(input.Payload, "$", true)

	subResults := make([]validationutils.ValidationOutput, 0)
	valid := true
	configureDebugInfo := ""
	for _, testObj := range scope {
		testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("Invalid object structure in scope for test CancelValidations")
		}

		testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

		var CANCEL_CONTEXT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_CONTEXT")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				action := validationutils.StringSliceToInterface([]string{`cancel`})
				validationutils.UnusedFunction(action)

				var CONTEXT_REQUIRED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CONTEXT_REQUIRED_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_DOMAIN")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_DOMAIN","attr":"$.context.domain","_RETURN_":"attr are present","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_DOMAIN",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_DOMAIN**

- $.context.domain must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_DOMAIN",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_ACTION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_ACTION","attr":"$.context.action","_RETURN_":"attr are present","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_ACTION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_ACTION**

- $.context.action must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_ACTION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_COUNTRY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_COUNTRY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.country", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_COUNTRY","attr":"$.context.country","_RETURN_":"attr are present","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_COUNTRY",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_COUNTRY**

- $.context.country must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_COUNTRY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_CONTEXT_CODE_14 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_CODE_14")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.city", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^(std:\d{3,5}|\*)$`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_CODE_14","attr":"$.context.city","reg":["^(std:\\\\d{3,5}|\\\\*)$"],"_RETURN_":"attr follow regex reg","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_CONTEXT_CODE_14",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_CONTEXT_CODE_14**

- All elements of $.context.city must follow every regex in ["^(std:\\d{3,5}|\\*)$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_CODE_14",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_VERSION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.core_version", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_VERSION","attr":"$.context.core_version","_RETURN_":"attr are present","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_VERSION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_VERSION**

- $.context.core_version must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_VERSION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BAP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BAP_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BAP_ID","attr":"$.context.bap_id","_RETURN_":"attr are present","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BAP_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BAP_ID**

- $.context.bap_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BAP_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BAP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BAP_URI","attr":"$.context.bap_uri","_RETURN_":"attr are present","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BAP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BAP_URI**

- $.context.bap_uri must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BAP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BPP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BPP_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BPP_ID","search":["search"],"attr":"$.context.bpp_id","_CONTINUE_":"(action equal to search)","_RETURN_":"attr are present","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BPP_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BPP_ID**

- $.context.bpp_id must be present in the payload

> **Skip if:**
>
>     - ["cancel"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BPP_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BPP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BPP_URI","search":["search"],"_CONTINUE_":"(action equal to search)","attr":"$.context.bpp_uri","_RETURN_":"attr are present","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BPP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BPP_URI**

- $.context.bpp_uri must be present in the payload

> **Skip if:**
>
>     - ["cancel"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BPP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TRANSACTION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TRANSACTION_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.transaction_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TRANSACTION_ID","attr":"$.context.transaction_id","_RETURN_":"attr are present","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TRANSACTION_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TRANSACTION_ID**

- $.context.transaction_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TRANSACTION_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_MESSAGE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_MESSAGE_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.message_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_MESSAGE_ID","attr":"$.context.message_id","_RETURN_":"attr are present","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_MESSAGE_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_MESSAGE_ID**

- $.context.message_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_MESSAGE_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TIMESTAMP")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.timestamp", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TIMESTAMP","attr":"$.context.timestamp","reg":["^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}Z$"],"_RETURN_":"attr follow regex reg","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TIMESTAMP",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TIMESTAMP**

- All elements of $.context.timestamp must follow every regex in ["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TIMESTAMP",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
								validationutils.UnusedFunction(attr)
								optional_vars := validationutils.StringSliceToInterface([]string{`on_search`, `on_select`, `on_confirm`, `on_init`, `on_cancel`, `on_track`, `on_update`, `on_status`})
								validationutils.UnusedFunction(optional_vars)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.AllIn(action, optional_vars)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TTL","attr":"$.context.ttl","optional_vars":["on_search","on_select","on_confirm","on_init","on_cancel","on_track","on_update","on_status"],"_CONTINUE_":"(action all in optional_vars)","_RETURN_":"attr are present","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TTL**

- $.context.ttl must be present in the payload

> **Skip if:**
>
>     - all elements of ["cancel"] are in ["on_search", "on_select", "on_confirm", "on_init", "on_cancel", "on_track", "on_update", "on_status"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CONTEXT_REQUIRED_DOMAIN,
							CONTEXT_REQUIRED_ACTION,
							CONTEXT_REQUIRED_COUNTRY,
							REQUIRED_CONTEXT_CODE_14,
							CONTEXT_REQUIRED_VERSION,
							CONTEXT_REQUIRED_BAP_ID,
							CONTEXT_REQUIRED_BAP_URI,
							CONTEXT_REQUIRED_BPP_ID,
							CONTEXT_REQUIRED_BPP_URI,
							CONTEXT_REQUIRED_TRANSACTION_ID,
							CONTEXT_REQUIRED_MESSAGE_ID,
							CONTEXT_REQUIRED_TIMESTAMP,
							CONTEXT_REQUIRED_TTL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CONTEXT_REQUIRED",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var CONTEXT_ENUM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CONTEXT_ENUM_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_DOMAIN")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								domain := validationutils.StringSliceToInterface([]string{`ONDC:RET10`})
								validationutils.UnusedFunction(domain)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.EqualTo(attr, domain)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_DOMAIN","domain":["ONDC:RET10"],"attr":"$.context.domain","_RETURN_":"attr equal to domain","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_DOMAIN",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_DOMAIN**

- $.context.domain must equal ["ONDC:RET10"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_DOMAIN",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_ENUM_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_ACTION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.EqualTo(attr, action)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_ACTION","attr":"$.context.action","_RETURN_":"attr equal to action","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_ACTION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_ACTION**

- $.context.action must equal ["cancel"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_ACTION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_ENUM_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_VERSION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								version := validationutils.StringSliceToInterface([]string{`1.2.5`})
								validationutils.UnusedFunction(version)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.core_version", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.AllIn(attr, version)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_VERSION","version":["1.2.5"],"attr":"$.context.core_version","_RETURN_":"attr all in version","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_VERSION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_VERSION**

- All elements of $.context.core_version must be in ["1.2.5"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_VERSION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_BAP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^https?\:\/\/`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_BAP_URI","attr":"$.context.bap_uri","reg":["^https?\\:\\/\\/"],"_RETURN_":"attr follow regex reg","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_BAP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_BAP_URI**

- All elements of $.context.bap_uri must follow every regex in ["^https?\:\/\/"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_BAP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_BPP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^https?\:\/\/`})
								validationutils.UnusedFunction(reg)
								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_BPP_URI","attr":"$.context.bpp_uri","reg":["^https?\\:\\/\\/"],"_RETURN_":"attr follow regex reg","search":["search"],"_CONTINUE_":"(action equal to search)","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_BPP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_BPP_URI**

- All elements of $.context.bpp_uri must follow every regex in ["^https?\:\/\/"]

> **Skip if:**
>
>     - ["cancel"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_BPP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^P(?=\d|T)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$`})
								validationutils.UnusedFunction(reg)
								optional_vars := validationutils.StringSliceToInterface([]string{`on_search`, `on_select`, `on_confirm`, `on_init`, `on_cancel`, `on_track`, `on_update`, `on_status`})
								validationutils.UnusedFunction(optional_vars)
								action := validationutils.StringSliceToInterface([]string{`cancel`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.AllIn(action, optional_vars)
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_TTL","attr":"$.context.ttl","reg":["^P(?=\\\\d|T)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?(\\\\d+S)?)?$"],"optional_vars":["on_search","on_select","on_confirm","on_init","on_cancel","on_track","on_update","on_status"],"_CONTINUE_":"(action all in optional_vars)","_RETURN_":"attr follow regex reg","action":["cancel"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_TTL**

- All elements of $.context.ttl must follow every regex in ["^P(?=\\d|T)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$"]

> **Skip if:**
>
>     - all elements of ["cancel"] are in ["on_search", "on_select", "on_confirm", "on_init", "on_cancel", "on_track", "on_update", "on_status"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CONTEXT_ENUM_DOMAIN,
							CONTEXT_ENUM_ACTION,
							CONTEXT_ENUM_VERSION,
							CONTEXT_REG_BAP_URI,
							CONTEXT_REG_BPP_URI,
							CONTEXT_REG_TTL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CONTEXT_ENUM",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					CONTEXT_REQUIRED,
					CONTEXT_ENUM,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "CANCEL_CONTEXT",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var CANCEL_ORDER_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_ORDER_ID")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				attr := validationutils.GetJsonPath(testObjMap, "$.message.order_id", true)
				validationutils.UnusedFunction(attr)

				validate := validationutils.ArePresent(attr)

				configureDebugInfo = `{"_NAME_":"CANCEL_ORDER_ID","attr":"$.message.order_id","_RETURN_":"attr are present"}`

				if !validate {
					result := validationutils.ValidationOutput{
						TestName: "CANCEL_ORDER_ID",
						Valid:    false,
						Code:     30000,
						Description: `#### **CANCEL_ORDER_ID**

- $.message.order_id must be present in the payload`,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}
					delete(testObjMap, "_EXTERNAL")
					return []validationutils.ValidationOutput{result}, nil
				}

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "CANCEL_ORDER_ID",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var CANCELLATION_REASON_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test CANCELLATION_REASON_ID")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				attr := validationutils.GetJsonPath(testObjMap, "$.message.cancellation_reason_id", true)
				validationutils.UnusedFunction(attr)
				var_enum := validationutils.StringSliceToInterface([]string{`001`, `002`, `003`, `004`, `005`, `051`, `052`, `053`, `009`, `010`, `011`, `013`, `014`, `016`, `017`, `018`, `020`, `998`, `999`})
				validationutils.UnusedFunction(var_enum)

				validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, var_enum))

				configureDebugInfo = `{"_NAME_":"CANCELLATION_REASON_ID","attr":"$.message.cancellation_reason_id","var_enum":["001","002","003","004","005","051","052","053","009","010","011","013","014","016","017","018","020","998","999"],"_RETURN_":"attr are present && attr all in var_enum"}`

				if !validate {
					result := validationutils.ValidationOutput{
						TestName: "CANCELLATION_REASON_ID",
						Valid:    false,
						Code:     30000,
						Description: `#### **CANCELLATION_REASON_ID**

**All of the following must be true:**
  - $.message.cancellation_reason_id must be present in the payload
  - All elements of $.message.cancellation_reason_id must be in ["001", "002", "003", "004", "005", "051", "052", "053", "009", "010", "011", "013", "014", "016", "017", "018", "020", "998", "999"]`,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}
					delete(testObjMap, "_EXTERNAL")
					return []validationutils.ValidationOutput{result}, nil
				}

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "CANCELLATION_REASON_ID",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var CANCEL_DESCRIPTOR = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_DESCRIPTOR")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				var CANCEL_DESCRIPTOR_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_DESCRIPTOR_NAME")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.descriptor.name", true)
						validationutils.UnusedFunction(attr)

						skipCheck := !(validationutils.ArePresent(attr))
						if skipCheck {
							continue
						}

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"CANCEL_DESCRIPTOR_NAME","attr":"$.message.descriptor.name","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "CANCEL_DESCRIPTOR_NAME",
								Valid:    false,
								Code:     30000,
								Description: `#### **CANCEL_DESCRIPTOR_NAME**

- $.message.descriptor.name must be present in the payload

> **Skip if:**
>
>     - $.message.descriptor.name is not in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CANCEL_DESCRIPTOR_NAME",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var CANCEL_DESCRIPTOR_SHORT_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_DESCRIPTOR_SHORT_DESC")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.descriptor.short_desc", true)
						validationutils.UnusedFunction(attr)

						skipCheck := !(validationutils.ArePresent(attr))
						if skipCheck {
							continue
						}

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"CANCEL_DESCRIPTOR_SHORT_DESC","attr":"$.message.descriptor.short_desc","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "CANCEL_DESCRIPTOR_SHORT_DESC",
								Valid:    false,
								Code:     30000,
								Description: `#### **CANCEL_DESCRIPTOR_SHORT_DESC**

- $.message.descriptor.short_desc must be present in the payload

> **Skip if:**
>
>     - $.message.descriptor.short_desc is not in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CANCEL_DESCRIPTOR_SHORT_DESC",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var CANCEL_DESCRIPTOR_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_DESCRIPTOR_TAGS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var PARAMS_FORCE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PARAMS_FORCE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.descriptor.tags[*].code", true)
								validationutils.UnusedFunction(attr)
								var_enum := validationutils.StringSliceToInterface([]string{`params`, `cancel_request`})
								validationutils.UnusedFunction(var_enum)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, var_enum)

								configureDebugInfo = `{"_NAME_":"PARAMS_FORCE","attr":"$.message.descriptor.tags[*].code","var_enum":["params","cancel_request"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PARAMS_FORCE",
										Valid:    false,
										Code:     30000,
										Description: `#### **PARAMS_FORCE**

- All elements of $.message.descriptor.tags[*].code must be in ["params", "cancel_request"]

> **Skip if:**
>
>     - $.message.descriptor.tags[*].code is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PARAMS_FORCE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PARAMS_TAG = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PARAMS_TAG")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var PARAMS_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PARAMS_VALID_TAGS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.descriptor.tags[?(@.code=='params')].list[*].code", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`force`, `ttl_response`})
										validationutils.UnusedFunction(var_enum)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"PARAMS_VALID_TAGS","attr":"$.message.descriptor.tags[?(@.code=='params')].list[*].code","var_enum":["force","ttl_response"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PARAMS_VALID_TAGS",
												Valid:    false,
												Code:     30000,
												Description: `#### **PARAMS_VALID_TAGS**

- All elements of $.message.descriptor.tags[?(@.code=='params')].list[*].code must be in ["force", "ttl_response"]

> **Skip if:**
>
>     - $.message.descriptor.tags[?(@.code=='params')].list[*].code is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PARAMS_VALID_TAGS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PARAMS_FORCE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PARAMS_FORCE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.descriptor.tags[?(@.code=='params')].list[?(@.code=='force')].value", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`yes`, `no`})
										validationutils.UnusedFunction(var_enum)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"PARAMS_FORCE","attr":"$.message.descriptor.tags[?(@.code=='params')].list[?(@.code=='force')].value","var_enum":["yes","no"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PARAMS_FORCE",
												Valid:    false,
												Code:     30000,
												Description: `#### **PARAMS_FORCE**

- All elements of $.message.descriptor.tags[?(@.code=='params')].list[?(@.code=='force')].value must be in ["yes", "no"]

> **Skip if:**
>
>     - $.message.descriptor.tags[?(@.code=='params')].list[?(@.code=='force')].value is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PARAMS_FORCE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PARAMS_TTL_RESPONSE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PARAMS_TTL_RESPONSE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.descriptor.tags[?(@.code=='params')].list[?(@.code=='ttl_response')].value", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PARAMS_TTL_RESPONSE","attr":"$.message.descriptor.tags[?(@.code=='params')].list[?(@.code=='ttl_response')].value","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PARAMS_TTL_RESPONSE",
												Valid:    false,
												Code:     30000,
												Description: `#### **PARAMS_TTL_RESPONSE**

- $.message.descriptor.tags[?(@.code=='params')].list[?(@.code=='ttl_response')].value must be present in the payload

> **Skip if:**
>
>     - $.message.descriptor.tags[?(@.code=='params')].list[?(@.code=='ttl_response')].value is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PARAMS_TTL_RESPONSE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									PARAMS_VALID_TAGS,
									PARAMS_FORCE,
									PARAMS_TTL_RESPONSE,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PARAMS_TAG",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CANCEL_REQUEST_TAG = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_REQUEST_TAG")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var CANCEL_REQUEST_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_REQUEST_VALID_TAGS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.descriptor.tags[?(@.code=='cancel_request')].list[*].code", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`initiated_by`})
										validationutils.UnusedFunction(var_enum)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"CANCEL_REQUEST_VALID_TAGS","attr":"$.message.descriptor.tags[?(@.code=='cancel_request')].list[*].code","var_enum":["initiated_by"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "CANCEL_REQUEST_VALID_TAGS",
												Valid:    false,
												Code:     30000,
												Description: `#### **CANCEL_REQUEST_VALID_TAGS**

- All elements of $.message.descriptor.tags[?(@.code=='cancel_request')].list[*].code must be in ["initiated_by"]

> **Skip if:**
>
>     - $.message.descriptor.tags[?(@.code=='cancel_request')].list[*].code is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "CANCEL_REQUEST_VALID_TAGS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var CANCEL_REQUEST_INITIATED_BY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test CANCEL_REQUEST_INITIATED_BY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.descriptor.tags[?(@.code=='cancel_request')].list[?(@.code=='initiated_by')].value", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"CANCEL_REQUEST_INITIATED_BY","attr":"$.message.descriptor.tags[?(@.code=='cancel_request')].list[?(@.code=='initiated_by')].value","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "CANCEL_REQUEST_INITIATED_BY",
												Valid:    false,
												Code:     30000,
												Description: `#### **CANCEL_REQUEST_INITIATED_BY**

- $.message.descriptor.tags[?(@.code=='cancel_request')].list[?(@.code=='initiated_by')].value must be present in the payload

> **Skip if:**
>
>     - $.message.descriptor.tags[?(@.code=='cancel_request')].list[?(@.code=='initiated_by')].value is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "CANCEL_REQUEST_INITIATED_BY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									CANCEL_REQUEST_VALID_TAGS,
									CANCEL_REQUEST_INITIATED_BY,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CANCEL_REQUEST_TAG",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							PARAMS_FORCE,
							PARAMS_TAG,
							CANCEL_REQUEST_TAG,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CANCEL_DESCRIPTOR_TAGS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					CANCEL_DESCRIPTOR_NAME,
					CANCEL_DESCRIPTOR_SHORT_DESC,
					CANCEL_DESCRIPTOR_TAGS,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "CANCEL_DESCRIPTOR",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}

		var testFunctions = validationutils.TestFunctionArray{
			CANCEL_CONTEXT,
			CANCEL_ORDER_ID,
			CANCELLATION_REASON_ID,
			CANCEL_DESCRIPTOR,
		}

		allResults := make([]validationutils.ValidationOutput, 0)

		for _, testFunc := range testFunctions {
			results, err := testFunc(input)
			if err != nil {
				return nil, err
			}
			allResults = append(allResults, results...)
		}

		subResults = allResults
		// if all subResults are valid, then valid is true
		valid = true
		for _, res := range subResults {
			if !res.Valid {
				valid = false
				break
			}
		}

		configureDebugInfo = `NESTED_TEST_OBJECT`

		delete(testObjMap, "_EXTERNAL")
	}

	result := validationutils.ValidationOutput{
		TestName: "CancelValidations",
		Valid:    valid,
		Code:     0,
		DebugInfo: &validationutils.DebugInfo{
			FedConfig: configureDebugInfo,
		},
	}

	if valid {
		result.Code = 200
	} else {
		result.Code = 30000
	}

	results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
	results = append(results, result)
	results = append(results, subResults...)

	return results, nil
}
