// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.

package jsonvalidations

import (
	"fmt"
	"validationpkg/validationutils"
)

func Issue_Tests(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	totalResults, err := IssueValidations(input)
	if err != nil {
		return nil, err
	}

	if !input.Config.Debug {
		for i := range totalResults {
			totalResults[i].DebugInfo = nil
		}
	}

	if input.Config.HideParentErrors {
		// Delete results with valid false and no description
		filtered := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid && r.Description == "" {
				continue
			}
			filtered = append(filtered, r)
		}
		totalResults = filtered
	}

	if input.Config.OnlyInvalid {
		res := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid {
				res = append(res, r)
			}
		}

		if len(res) == 0 {
			// Find the overall test result
			var targetSuccess *validationutils.ValidationOutput
			for i := range totalResults {
				if totalResults[i].TestName == "IssueValidations" {
					targetSuccess = &totalResults[i]
					break
				}
			}

			if targetSuccess == nil {
				panic("Critical: Overall test result not found")
			}

			return []validationutils.ValidationOutput{*targetSuccess}, nil
		}

		return res, nil
	}

	return totalResults, nil
}

var IssueValidations = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	scope := validationutils.GetJsonPath(input.Payload, "$", true)

	subResults := make([]validationutils.ValidationOutput, 0)
	valid := true
	configureDebugInfo := ""
	for _, testObj := range scope {
		testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("Invalid object structure in scope for test IssueValidations")
		}

		testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

		var REQUIRED_CONTEXT_FIELDS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_FIELDS")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				var REQUIRED_CONTEXT_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_DOMAIN")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_DOMAIN","attr":"$.context.domain","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_DOMAIN",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_DOMAIN**

- $.context.domain must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_DOMAIN",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_COUNTRY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_COUNTRY")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.context.location.country.code`})
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_COUNTRY","attr":["$.context.location.country.code"],"_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_COUNTRY",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_COUNTRY**

- ["$.context.location.country.code"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_COUNTRY",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_CITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_CITY")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.context.location.city.code`})
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_CITY","attr":["$.context.location.city.code"],"_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_CITY",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_CITY**

- ["$.context.location.city.code"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_CITY",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_TRANSACTION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_TRANSACTION_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.transaction_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_TRANSACTION_ID","attr":"$.context.transaction_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_TRANSACTION_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_TRANSACTION_ID**

- $.context.transaction_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_TRANSACTION_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_MESSAGE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_MESSAGE_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.message_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_MESSAGE_ID","attr":"$.context.message_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_MESSAGE_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_MESSAGE_ID**

- $.context.message_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_MESSAGE_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_ACTION")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_ACTION","attr":"$.context.action","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_ACTION",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_ACTION**

- $.context.action must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_ACTION",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_TIMESTAMP")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.timestamp", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_TIMESTAMP","attr":"$.context.timestamp","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_TIMESTAMP",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_TIMESTAMP**

- $.context.timestamp must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_TIMESTAMP",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_VERSION")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.context.version`})
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_VERSION","attr":["$.context.version"],"_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_VERSION",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_VERSION**

- ["$.context.version"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_VERSION",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BAP_URI")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BAP_URI","attr":"$.context.bap_uri","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BAP_URI",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BAP_URI**

- $.context.bap_uri must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BAP_URI",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BAP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BAP_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BAP_ID","attr":"$.context.bap_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BAP_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BAP_ID**

- $.context.bap_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BAP_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BPP_URI")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BPP_URI","attr":"$.context.bpp_uri","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BPP_URI",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BPP_URI**

- $.context.bpp_uri must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BPP_URI",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BPP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BPP_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BPP_ID","attr":"$.context.bpp_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BPP_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BPP_ID**

- $.context.bpp_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BPP_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_TTL")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_TTL","attr":"$.context.ttl","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_TTL",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_TTL**

- $.context.ttl must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_TTL",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var VALID_CONTEXT_COUNTRY_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test VALID_CONTEXT_COUNTRY_CODE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.country", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"VALID_CONTEXT_COUNTRY_CODE","attr":"$.context.country","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "VALID_CONTEXT_COUNTRY_CODE",
								Valid:    false,
								Code:     30000,
								Description: `#### **VALID_CONTEXT_COUNTRY_CODE**

- $.context.country must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "VALID_CONTEXT_COUNTRY_CODE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					REQUIRED_CONTEXT_DOMAIN,
					REQUIRED_CONTEXT_COUNTRY,
					REQUIRED_CONTEXT_CITY,
					REQUIRED_CONTEXT_TRANSACTION_ID,
					REQUIRED_CONTEXT_MESSAGE_ID,
					REQUIRED_CONTEXT_ACTION,
					REQUIRED_CONTEXT_TIMESTAMP,
					REQUIRED_CONTEXT_VERSION,
					REQUIRED_CONTEXT_BAP_URI,
					REQUIRED_CONTEXT_BAP_ID,
					REQUIRED_CONTEXT_BPP_URI,
					REQUIRED_CONTEXT_BPP_ID,
					REQUIRED_CONTEXT_TTL,
					VALID_CONTEXT_COUNTRY_CODE,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "REQUIRED_CONTEXT_FIELDS",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var ISSUE_VALIDATION_VERSION_200 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$.message.issue.actions", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test ISSUE_VALIDATION_VERSION_200")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				action := validationutils.StringSliceToInterface([]string{`issue`})
				validationutils.UnusedFunction(action)

				var REQUIRED_MESSAGE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_ID","attr":"$.message.issue.id","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_ID**

- $.message.issue.id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_STATUS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_STATUS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.status", true)
						validationutils.UnusedFunction(attr)
						enumList := validationutils.StringSliceToInterface([]string{`OPEN`, `CLOSED`, `PROCESSING`, `RESOLVED`, `NEED_MORE_INFO`, `INFO_PROVIDED`})
						validationutils.UnusedFunction(enumList)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := ((validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, enumList))) && (validationutils.AreUnique(attr))

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_STATUS","attr":"$.message.issue.status","_RETURN_":"attr are present && attr all in enumList && attr are unique","enumList":["OPEN","CLOSED","PROCESSING","RESOLVED","NEED_MORE_INFO","INFO_PROVIDED"],"action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_STATUS",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_STATUS**

**All of the following must be true:**
  - **All of the following must be true:**
    - $.message.issue.status must be present in the payload
    - All elements of $.message.issue.status must be in ["OPEN", "CLOSED", "PROCESSING", "RESOLVED", "NEED_MORE_INFO", "INFO_PROVIDED"]
  - All values of $.message.issue.status are unique`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_STATUS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_LEVEL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_LEVEL")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.level", true)
						validationutils.UnusedFunction(attr)
						enumList := validationutils.StringSliceToInterface([]string{`ISSUE`, `GREVIENCE`, `DISPUTE`})
						validationutils.UnusedFunction(enumList)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, enumList))

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_LEVEL","attr":"$.message.issue.level","_RETURN_":"attr are present && attr all in enumList","enumList":["ISSUE","GREVIENCE","DISPUTE"],"action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_LEVEL",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_LEVEL**

**All of the following must be true:**
  - $.message.issue.level must be present in the payload
  - All elements of $.message.issue.level must be in ["ISSUE", "GREVIENCE", "DISPUTE"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_LEVEL",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_CREATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_CREATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.created_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_CREATED_AT","attr":"$.message.issue.created_at","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_CREATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_CREATED_AT**

- $.message.issue.created_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_CREATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_UPDATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_UPDATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.updated_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_UPDATED_AT","attr":"$.message.issue.updated_at","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_UPDATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_UPDATED_AT**

- $.message.issue.updated_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_UPDATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_REF_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_REF_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.refs[*].ref_id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_REF_ID","attr":"$.message.issue.refs[*].ref_id","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_REF_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_REF_ID**

- $.message.issue.refs[*].ref_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_REF_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_REF_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_REF_TYPE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.refs[*].ref_type", true)
						validationutils.UnusedFunction(attr)
						enumList := validationutils.StringSliceToInterface([]string{`ORDER`, `ITEM`, `FULFILLMENT`, `TRANSACTION_ID`, `MESSAGE_ID`, `PROVIDER`, `COMPLAINT`, `ACTION`, `PAYMENT`, `CUSTOMER`, `AGENT`})
						validationutils.UnusedFunction(enumList)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, enumList))

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_REF_TYPE","attr":"$.message.issue.refs[*].ref_type","_RETURN_":"attr are present && attr all in enumList","enumList":["ORDER","ITEM","FULFILLMENT","TRANSACTION_ID","MESSAGE_ID","PROVIDER","COMPLAINT","ACTION","PAYMENT","CUSTOMER","AGENT"],"action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_REF_TYPE",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_REF_TYPE**

**All of the following must be true:**
  - $.message.issue.refs[*].ref_type must be present in the payload
  - All elements of $.message.issue.refs[*].ref_type must be in ["ORDER", "ITEM", "FULFILLMENT", "TRANSACTION_ID", "MESSAGE_ID", "PROVIDER", "COMPLAINT", "ACTION", "PAYMENT", "CUSTOMER", "AGENT"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_REF_TYPE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_ID_10 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_ID_10")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_ID_10","attr":"$.message.issue.actors[*].id","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_ID_10",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_ID_10**

- $.message.issue.actors[*].id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_ID_10",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_TYPE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].type", true)
						validationutils.UnusedFunction(attr)
						enumList := validationutils.StringSliceToInterface([]string{`INTERFACING_NP`, `COUNTERPARTY_NP`, `CASCADED_NP`, `PROVIDER`, `AGENT`, `CUSTOMER`, `INTERFACING_NP_GRO`, `COUNTERPARTY_NP_GRO`, `CASCADED_NP_GRO`, `CONSUMER`})
						validationutils.UnusedFunction(enumList)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, enumList))

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_TYPE","attr":"$.message.issue.actors[*].type","_RETURN_":"attr are present && attr all in enumList","enumList":["INTERFACING_NP","COUNTERPARTY_NP","CASCADED_NP","PROVIDER","AGENT","CUSTOMER","INTERFACING_NP_GRO","COUNTERPARTY_NP_GRO","CASCADED_NP_GRO","CONSUMER"],"action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_TYPE",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_TYPE**

**All of the following must be true:**
  - $.message.issue.actors[*].type must be present in the payload
  - All elements of $.message.issue.actors[*].type must be in ["INTERFACING_NP", "COUNTERPARTY_NP", "CASCADED_NP", "PROVIDER", "AGENT", "CUSTOMER", "INTERFACING_NP_GRO", "COUNTERPARTY_NP_GRO", "CASCADED_NP_GRO", "CONSUMER"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_TYPE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_NAME")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].info.person.name", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_NAME","attr":"$.message.issue.actors[*].info.person.name","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_NAME",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_NAME**

- $.message.issue.actors[*].info.person.name must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_NAME",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_NAME_13 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_NAME_13")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].info.person.name", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_NAME_13","attr":"$.message.issue.actors[*].info.person.name","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_NAME_13",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_NAME_13**

- $.message.issue.actors[*].info.person.name must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_NAME_13",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_PHONE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_PHONE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].info.contact.phone", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_PHONE","attr":"$.message.issue.actors[*].info.contact.phone","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_PHONE",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_PHONE**

- $.message.issue.actors[*].info.contact.phone must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_PHONE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_EMAIL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_EMAIL")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].info.contact.email", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_EMAIL","attr":"$.message.issue.actors[*].info.contact.email","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_EMAIL",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_EMAIL**

- $.message.issue.actors[*].info.contact.email must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_EMAIL",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_SOURCE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_SOURCE_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.source_id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_SOURCE_ID","attr":"$.message.issue.source_id","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_SOURCE_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_SOURCE_ID**

- $.message.issue.source_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_SOURCE_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_CODE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.descriptor.code", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_CODE","attr":"$.message.issue.descriptor.code","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_CODE",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_CODE**

- $.message.issue.descriptor.code must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_CODE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_SHORT_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_SHORT_DESC")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.descriptor.short_desc", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_SHORT_DESC","attr":"$.message.issue.descriptor.short_desc","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_SHORT_DESC",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_SHORT_DESC**

- $.message.issue.descriptor.short_desc must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_SHORT_DESC",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_LONG_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_LONG_DESC")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.descriptor.long_desc", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_LONG_DESC","attr":"$.message.issue.descriptor.long_desc","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_LONG_DESC",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_LONG_DESC**

- $.message.issue.descriptor.long_desc must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_LONG_DESC",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_URL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_URL")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.descriptor.additional_desc.url", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_URL","attr":"$.message.issue.descriptor.additional_desc.url","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_URL",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_URL**

- $.message.issue.descriptor.additional_desc.url must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_URL",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_CONTENT_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_CONTENT_TYPE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.descriptor.additional_desc.content_type", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_CONTENT_TYPE","attr":"$.message.issue.descriptor.additional_desc.content_type","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_CONTENT_TYPE",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_CONTENT_TYPE**

- $.message.issue.descriptor.additional_desc.content_type must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_CONTENT_TYPE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_LAST_ACTION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_LAST_ACTION_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.last_action_id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_LAST_ACTION_ID","attr":"$.message.issue.last_action_id","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_LAST_ACTION_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_LAST_ACTION_ID**

- $.message.issue.last_action_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_LAST_ACTION_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_ID_25 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_ID_25")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actions[*].id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_ID_25","attr":"$.message.issue.actions[*].id","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_ID_25",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_ID_25**

- $.message.issue.actions[*].id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_ID_25",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_CODE_26 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_CODE_26")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actions[*].descriptor.code", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_CODE_26","attr":"$.message.issue.actions[*].descriptor.code","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_CODE_26",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_CODE_26**

- $.message.issue.actions[*].descriptor.code must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_CODE_26",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_SHORT_DESC_27 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_SHORT_DESC_27")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actions[*].descriptor.short_desc", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_SHORT_DESC_27","attr":"$.message.issue.actions[*].descriptor.short_desc","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_SHORT_DESC_27",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_SHORT_DESC_27**

- $.message.issue.actions[*].descriptor.short_desc must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_SHORT_DESC_27",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_UPDATED_AT_28 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_UPDATED_AT_28")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actions[*].updated_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_UPDATED_AT_28","attr":"$.message.issue.actions[*].updated_at","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_UPDATED_AT_28",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_UPDATED_AT_28**

- $.message.issue.actions[*].updated_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_UPDATED_AT_28",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_MESSAGE_ACTION_BY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_MESSAGE_ACTION_BY")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.actions[*].action_by", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_MESSAGE_ACTION_BY","attr":"$.message.issue.actions[*].action_by","_RETURN_":"attr are present","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_MESSAGE_ACTION_BY",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_MESSAGE_ACTION_BY**

- $.message.issue.actions[*].action_by must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_MESSAGE_ACTION_BY",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var VALID_ENUM_MESSAGE_STATUS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test VALID_ENUM_MESSAGE_STATUS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						enumList := validationutils.StringSliceToInterface([]string{`OPEN`, `CLOSED`, `PROCESSING`, `RESOLVED`, `INFO_PROVIDED`})
						validationutils.UnusedFunction(enumList)
						enumPath := validationutils.GetJsonPath(testObjMap, "$.message.issue.status", true)
						validationutils.UnusedFunction(enumPath)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						skipCheck := !(validationutils.ArePresent(enumPath))
						if skipCheck {
							continue
						}

						validate := validationutils.AllIn(enumPath, enumList)

						configureDebugInfo = `{"_NAME_":"VALID_ENUM_MESSAGE_STATUS","enumList":["OPEN","CLOSED","PROCESSING","RESOLVED","INFO_PROVIDED"],"enumPath":"$.message.issue.status","_CONTINUE_":"!(enumPath are present)","_RETURN_":"enumPath all in enumList","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "VALID_ENUM_MESSAGE_STATUS",
								Valid:    false,
								Code:     30000,
								Description: `#### **VALID_ENUM_MESSAGE_STATUS**

- All elements of $.message.issue.status must be in ["OPEN", "CLOSED", "PROCESSING", "RESOLVED", "INFO_PROVIDED"]

> **Skip if:**
>
>     - $.message.issue.status is not in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "VALID_ENUM_MESSAGE_STATUS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var VALID_ENUM_MESSAGE_LEVEL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test VALID_ENUM_MESSAGE_LEVEL")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						enumList := validationutils.StringSliceToInterface([]string{`ISSUE`, `GREVIENCE`, `DISPUTE`})
						validationutils.UnusedFunction(enumList)
						enumPath := validationutils.GetJsonPath(testObjMap, "$.message.issue.level", true)
						validationutils.UnusedFunction(enumPath)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						skipCheck := !(validationutils.ArePresent(enumPath))
						if skipCheck {
							continue
						}

						validate := validationutils.AllIn(enumPath, enumList)

						configureDebugInfo = `{"_NAME_":"VALID_ENUM_MESSAGE_LEVEL","enumList":["ISSUE","GREVIENCE","DISPUTE"],"enumPath":"$.message.issue.level","_CONTINUE_":"!(enumPath are present)","_RETURN_":"enumPath all in enumList","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "VALID_ENUM_MESSAGE_LEVEL",
								Valid:    false,
								Code:     30000,
								Description: `#### **VALID_ENUM_MESSAGE_LEVEL**

- All elements of $.message.issue.level must be in ["ISSUE", "GREVIENCE", "DISPUTE"]

> **Skip if:**
>
>     - $.message.issue.level is not in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "VALID_ENUM_MESSAGE_LEVEL",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var VALID_ENUM_MESSAGE_REF_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test VALID_ENUM_MESSAGE_REF_TYPE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						enumList := validationutils.StringSliceToInterface([]string{`ORDER`, `ITEM`, `FULFILLMENT`, `TRANSACTION_ID`, `MESSAGE_ID`, `PROVIDER`, `COMPLAINT`, `ACTION`, `PAYMENT`, `CUSTOMER`, `AGENT`})
						validationutils.UnusedFunction(enumList)
						enumPath := validationutils.GetJsonPath(testObjMap, "$.message.issue.refs[*].ref_type", true)
						validationutils.UnusedFunction(enumPath)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						skipCheck := !(validationutils.ArePresent(enumPath))
						if skipCheck {
							continue
						}

						validate := validationutils.AllIn(enumPath, enumList)

						configureDebugInfo = `{"_NAME_":"VALID_ENUM_MESSAGE_REF_TYPE","enumList":["ORDER","ITEM","FULFILLMENT","TRANSACTION_ID","MESSAGE_ID","PROVIDER","COMPLAINT","ACTION","PAYMENT","CUSTOMER","AGENT"],"enumPath":"$.message.issue.refs[*].ref_type","_CONTINUE_":"!(enumPath are present)","_RETURN_":"enumPath all in enumList","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "VALID_ENUM_MESSAGE_REF_TYPE",
								Valid:    false,
								Code:     30000,
								Description: `#### **VALID_ENUM_MESSAGE_REF_TYPE**

- All elements of $.message.issue.refs[*].ref_type must be in ["ORDER", "ITEM", "FULFILLMENT", "TRANSACTION_ID", "MESSAGE_ID", "PROVIDER", "COMPLAINT", "ACTION", "PAYMENT", "CUSTOMER", "AGENT"]

> **Skip if:**
>
>     - $.message.issue.refs[*].ref_type is not in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "VALID_ENUM_MESSAGE_REF_TYPE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var VALID_ENUM_MESSAGE_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test VALID_ENUM_MESSAGE_TYPE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						enumList := validationutils.StringSliceToInterface([]string{`INTERFACING_NP`, `COUNTERPARTY_NP`, `CASCADED_NP`, `PROVIDER`, `AGENT`, `CUSTOMER`, `INTERFACING_NP_GRO`, `COUNTERPARTY_NP_GRO`, `CASCADED_NP_GRO`, `CONSUMER`})
						validationutils.UnusedFunction(enumList)
						enumPath := validationutils.GetJsonPath(testObjMap, "$.message.issue.actors[*].type", true)
						validationutils.UnusedFunction(enumPath)
						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						skipCheck := !(validationutils.ArePresent(enumPath))
						if skipCheck {
							continue
						}

						validate := validationutils.AllIn(enumPath, enumList)

						configureDebugInfo = `{"_NAME_":"VALID_ENUM_MESSAGE_TYPE","enumList":["INTERFACING_NP","COUNTERPARTY_NP","CASCADED_NP","PROVIDER","AGENT","CUSTOMER","INTERFACING_NP_GRO","COUNTERPARTY_NP_GRO","CASCADED_NP_GRO","CONSUMER"],"enumPath":"$.message.issue.actors[*].type","_CONTINUE_":"!(enumPath are present)","_RETURN_":"enumPath all in enumList","action":["issue"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "VALID_ENUM_MESSAGE_TYPE",
								Valid:    false,
								Code:     30000,
								Description: `#### **VALID_ENUM_MESSAGE_TYPE**

- All elements of $.message.issue.actors[*].type must be in ["INTERFACING_NP", "COUNTERPARTY_NP", "CASCADED_NP", "PROVIDER", "AGENT", "CUSTOMER", "INTERFACING_NP_GRO", "COUNTERPARTY_NP_GRO", "CASCADED_NP_GRO", "CONSUMER"]

> **Skip if:**
>
>     - $.message.issue.actors[*].type is not in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "VALID_ENUM_MESSAGE_TYPE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					REQUIRED_MESSAGE_ID,
					REQUIRED_MESSAGE_STATUS,
					REQUIRED_MESSAGE_LEVEL,
					REQUIRED_MESSAGE_CREATED_AT,
					REQUIRED_MESSAGE_UPDATED_AT,
					REQUIRED_MESSAGE_REF_ID,
					REQUIRED_MESSAGE_REF_TYPE,
					REQUIRED_MESSAGE_ID_10,
					REQUIRED_MESSAGE_TYPE,
					REQUIRED_MESSAGE_NAME,
					REQUIRED_MESSAGE_NAME_13,
					REQUIRED_MESSAGE_PHONE,
					REQUIRED_MESSAGE_EMAIL,
					REQUIRED_MESSAGE_SOURCE_ID,
					REQUIRED_MESSAGE_CODE,
					REQUIRED_MESSAGE_SHORT_DESC,
					REQUIRED_MESSAGE_LONG_DESC,
					REQUIRED_MESSAGE_URL,
					REQUIRED_MESSAGE_CONTENT_TYPE,
					REQUIRED_MESSAGE_LAST_ACTION_ID,
					REQUIRED_MESSAGE_ID_25,
					REQUIRED_MESSAGE_CODE_26,
					REQUIRED_MESSAGE_SHORT_DESC_27,
					REQUIRED_MESSAGE_UPDATED_AT_28,
					REQUIRED_MESSAGE_ACTION_BY,
					VALID_ENUM_MESSAGE_STATUS,
					VALID_ENUM_MESSAGE_LEVEL,
					VALID_ENUM_MESSAGE_REF_TYPE,
					VALID_ENUM_MESSAGE_TYPE,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "ISSUE_VALIDATION_VERSION_200",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var ISSUE_VALIDATION_VERSION_100 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$.message.issue.issue_actions", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test ISSUE_VALIDATION_VERSION_100")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				action := validationutils.StringSliceToInterface([]string{`issue`})
				validationutils.UnusedFunction(action)

				var ISSUE_VALIDATION_OPEN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$.message.issue[?(@.status=='OPEN')]", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ISSUE_VALIDATION_OPEN")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						var REQUIRED_ISSUE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_ID","attr":"$.message.issue.id","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_ISSUE_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_ISSUE_ID**

- $.message.issue.id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_ISSUE_STATUS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_STATUS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.status", true)
								validationutils.UnusedFunction(attr)
								validValues := validationutils.StringSliceToInterface([]string{`OPEN`, `CLOSED`})
								validationutils.UnusedFunction(validValues)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.AllIn(attr, validValues)

								configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_STATUS","attr":"$.message.issue.status","validValues":["OPEN","CLOSED"],"_RETURN_":"attr all in validValues","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_ISSUE_STATUS",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_ISSUE_STATUS**

- All elements of $.message.issue.status must be in ["OPEN", "CLOSED"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_STATUS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_ISSUE_CATEGORY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_CATEGORY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.category", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_CATEGORY","attr":"$.message.issue.category","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_ISSUE_CATEGORY",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_ISSUE_CATEGORY**

- $.message.issue.category must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_CATEGORY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_ISSUE_SUB_CATEGORY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_SUB_CATEGORY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.sub_category", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_SUB_CATEGORY","attr":"$.message.issue.sub_category","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_ISSUE_SUB_CATEGORY",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_ISSUE_SUB_CATEGORY**

- $.message.issue.sub_category must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_SUB_CATEGORY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_COMPLAINANT_PERSON_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_COMPLAINANT_PERSON_NAME")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.complainant_info.person.name", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_COMPLAINANT_PERSON_NAME","attr":"$.message.issue.complainant_info.person.name","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_COMPLAINANT_PERSON_NAME",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_COMPLAINANT_PERSON_NAME**

- $.message.issue.complainant_info.person.name must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_COMPLAINANT_PERSON_NAME",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_COMPLAINANT_CONTACT_PHONE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_COMPLAINANT_CONTACT_PHONE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.complainant_info.contact.phone", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_COMPLAINANT_CONTACT_PHONE","attr":"$.message.issue.complainant_info.contact.phone","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_COMPLAINANT_CONTACT_PHONE",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_COMPLAINANT_CONTACT_PHONE**

- $.message.issue.complainant_info.contact.phone must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_COMPLAINANT_CONTACT_PHONE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_ORDER_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ORDER_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.order_details.id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_ORDER_ID","attr":"$.message.issue.order_details.id","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_ORDER_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_ORDER_ID**

- $.message.issue.order_details.id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ORDER_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_ORDER_ITEMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ORDER_ITEMS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.order_details.items[*].id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_ORDER_ITEMS","attr":"$.message.issue.order_details.items[*].id","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_ORDER_ITEMS",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_ORDER_ITEMS**

- $.message.issue.order_details.items[*].id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ORDER_ITEMS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_ORDER_ITEMS_QUANTITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ORDER_ITEMS_QUANTITY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.order_details.items[*].quantity", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_ORDER_ITEMS_QUANTITY","attr":"$.message.issue.order_details.items[*].quantity","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_ORDER_ITEMS_QUANTITY",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_ORDER_ITEMS_QUANTITY**

- $.message.issue.order_details.items[*].quantity must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ORDER_ITEMS_QUANTITY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_FULFILLMENT_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_FULFILLMENT_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.order_details.fulfillments[*].id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_FULFILLMENT_ID","attr":"$.message.issue.order_details.fulfillments[*].id","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_FULFILLMENT_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_FULFILLMENT_ID**

- $.message.issue.order_details.fulfillments[*].id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_FULFILLMENT_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_PROVIDER_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_PROVIDER_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.order_details.provider_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_PROVIDER_ID","attr":"$.message.issue.order_details.provider_id","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_PROVIDER_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_PROVIDER_ID**

- $.message.issue.order_details.provider_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_PROVIDER_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_DESCRIPTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_DESCRIPTION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.StringSliceToInterface([]string{`$.message.issue.description`})
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_DESCRIPTION","attr":["$.message.issue.description"],"_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_DESCRIPTION",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_DESCRIPTION**

- ["$.message.issue.description"] must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_DESCRIPTION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_DESCRIPTION_SHORT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_DESCRIPTION_SHORT")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.StringSliceToInterface([]string{`$.message.issue.description.short_desc`})
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_DESCRIPTION_SHORT","attr":["$.message.issue.description.short_desc"],"_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_DESCRIPTION_SHORT",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_DESCRIPTION_SHORT**

- ["$.message.issue.description.short_desc"] must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_DESCRIPTION_SHORT",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_DESCRIPTION_LONG = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_DESCRIPTION_LONG")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.StringSliceToInterface([]string{`$.message.issue.description.long_desc`})
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_DESCRIPTION_LONG","attr":["$.message.issue.description.long_desc"],"_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_DESCRIPTION_LONG",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_DESCRIPTION_LONG**

- ["$.message.issue.description.long_desc"] must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_DESCRIPTION_LONG",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_DESCRIPTION_ADDITIONAL_URL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_DESCRIPTION_ADDITIONAL_URL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.StringSliceToInterface([]string{`$.message.issue.description.additional_desc.url`})
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_DESCRIPTION_ADDITIONAL_URL","attr":["$.message.issue.description.additional_desc.url"],"_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_DESCRIPTION_ADDITIONAL_URL",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_DESCRIPTION_ADDITIONAL_URL**

- ["$.message.issue.description.additional_desc.url"] must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_DESCRIPTION_ADDITIONAL_URL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_DESCRIPTION_ADDITIONAL_CONTENT_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_DESCRIPTION_ADDITIONAL_CONTENT_TYPE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.StringSliceToInterface([]string{`$.message.issue.description.additional_desc.content_type`})
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_DESCRIPTION_ADDITIONAL_CONTENT_TYPE","attr":["$.message.issue.description.additional_desc.content_type"],"_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_DESCRIPTION_ADDITIONAL_CONTENT_TYPE",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_DESCRIPTION_ADDITIONAL_CONTENT_TYPE**

- ["$.message.issue.description.additional_desc.content_type"] must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_DESCRIPTION_ADDITIONAL_CONTENT_TYPE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_DESCRIPTION_IMAGES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_DESCRIPTION_IMAGES")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.StringSliceToInterface([]string{`$.message.issue.description.images`})
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_DESCRIPTION_IMAGES","attr":["$.message.issue.description.images"],"_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_DESCRIPTION_IMAGES",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_DESCRIPTION_IMAGES**

- ["$.message.issue.description.images"] must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_DESCRIPTION_IMAGES",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_EXPECTED_RESPONSE_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_EXPECTED_RESPONSE_TIME")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.StringSliceToInterface([]string{`$.message.issue.expected_response_time.duration`})
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_EXPECTED_RESPONSE_TIME","attr":["$.message.issue.expected_response_time.duration"],"_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_EXPECTED_RESPONSE_TIME",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_EXPECTED_RESPONSE_TIME**

- ["$.message.issue.expected_response_time.duration"] must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_EXPECTED_RESPONSE_TIME",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_EXPECTED_RESOLUTION_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_EXPECTED_RESOLUTION_TIME")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.StringSliceToInterface([]string{`$.message.issue.expected_resolution_time.duration`})
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_EXPECTED_RESOLUTION_TIME","attr":["$.message.issue.expected_resolution_time.duration"],"_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_EXPECTED_RESOLUTION_TIME",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_EXPECTED_RESOLUTION_TIME**

- ["$.message.issue.expected_resolution_time.duration"] must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_EXPECTED_RESOLUTION_TIME",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_ISSUE_ACTIONS_OPEN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_ACTIONS_OPEN")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.complainant_actions[*].complainant_action", true)
								validationutils.UnusedFunction(attr)
								validValues := validationutils.StringSliceToInterface([]string{`OPEN`, `CLOSE`, `ESCALATE`})
								validationutils.UnusedFunction(validValues)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.AllIn(attr, validValues)

								configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_ACTIONS_OPEN","attr":"$.message.issue.issue_actions.complainant_actions[*].complainant_action","validValues":["OPEN","CLOSE","ESCALATE"],"_RETURN_":"attr all in validValues","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_ISSUE_ACTIONS_OPEN",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_ISSUE_ACTIONS_OPEN**

- All elements of $.message.issue.issue_actions.complainant_actions[*].complainant_action must be in ["OPEN", "CLOSE", "ESCALATE"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_ACTIONS_OPEN",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_CREATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CREATED_AT")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.created_at", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_CREATED_AT","attr":"$.message.issue.created_at","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_CREATED_AT",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_CREATED_AT**

- $.message.issue.created_at must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CREATED_AT",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_UPDATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_UPDATED_AT")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.updated_at", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_UPDATED_AT","attr":"$.message.issue.updated_at","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_UPDATED_AT",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_UPDATED_AT**

- $.message.issue.updated_at must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_UPDATED_AT",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							REQUIRED_ISSUE_ID,
							REQUIRED_ISSUE_STATUS,
							REQUIRED_ISSUE_CATEGORY,
							REQUIRED_ISSUE_SUB_CATEGORY,
							REQUIRED_COMPLAINANT_PERSON_NAME,
							REQUIRED_COMPLAINANT_CONTACT_PHONE,
							REQUIRED_ORDER_ID,
							REQUIRED_ORDER_ITEMS,
							REQUIRED_ORDER_ITEMS_QUANTITY,
							REQUIRED_FULFILLMENT_ID,
							REQUIRED_PROVIDER_ID,
							REQUIRED_DESCRIPTION,
							REQUIRED_DESCRIPTION_SHORT,
							REQUIRED_DESCRIPTION_LONG,
							REQUIRED_DESCRIPTION_ADDITIONAL_URL,
							REQUIRED_DESCRIPTION_ADDITIONAL_CONTENT_TYPE,
							REQUIRED_DESCRIPTION_IMAGES,
							REQUIRED_EXPECTED_RESPONSE_TIME,
							REQUIRED_EXPECTED_RESOLUTION_TIME,
							REQUIRED_ISSUE_ACTIONS_OPEN,
							REQUIRED_CREATED_AT,
							REQUIRED_UPDATED_AT,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ISSUE_VALIDATION_OPEN",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ISSUE_VALIDATION_CLOSED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$.message.issue[?(@.status=='CLOSED')]", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ISSUE_VALIDATION_CLOSED")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						action := validationutils.StringSliceToInterface([]string{`issue`})
						validationutils.UnusedFunction(action)

						var REQUIRED_ISSUE_ID_CLOSED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_ID_CLOSED")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_ID_CLOSED","attr":"$.message.issue.id","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_ISSUE_ID_CLOSED",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_ISSUE_ID_CLOSED**

- $.message.issue.id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_ID_CLOSED",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_ISSUE_STATUS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_STATUS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.status", true)
								validationutils.UnusedFunction(attr)
								validValues := validationutils.StringSliceToInterface([]string{`OPEN`, `CLOSED`})
								validationutils.UnusedFunction(validValues)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.AllIn(attr, validValues)

								configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_STATUS","attr":"$.message.issue.status","validValues":["OPEN","CLOSED"],"_RETURN_":"attr all in validValues","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_ISSUE_STATUS",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_ISSUE_STATUS**

- All elements of $.message.issue.status must be in ["OPEN", "CLOSED"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_STATUS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_ISSUE_ACTIONS_CLOSED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_ACTIONS_CLOSED")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.complainant_actions[*].complainant_action", true)
								validationutils.UnusedFunction(attr)
								validValues := validationutils.StringSliceToInterface([]string{`OPEN`, `CLOSE`, `ESCALATE`})
								validationutils.UnusedFunction(validValues)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.AllIn(attr, validValues)

								configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_ACTIONS_CLOSED","attr":"$.message.issue.issue_actions.complainant_actions[*].complainant_action","validValues":["OPEN","CLOSE","ESCALATE"],"_RETURN_":"attr all in validValues","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_ISSUE_ACTIONS_CLOSED",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_ISSUE_ACTIONS_CLOSED**

- All elements of $.message.issue.issue_actions.complainant_actions[*].complainant_action must be in ["OPEN", "CLOSE", "ESCALATE"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_ACTIONS_CLOSED",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_CREATED_AT_CLOSED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CREATED_AT_CLOSED")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.created_at", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_CREATED_AT_CLOSED","attr":"$.message.issue.created_at","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_CREATED_AT_CLOSED",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_CREATED_AT_CLOSED**

- $.message.issue.created_at must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CREATED_AT_CLOSED",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_UPDATED_AT_CLOSED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_UPDATED_AT_CLOSED")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.updated_at", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`issue`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"REQUIRED_UPDATED_AT_CLOSED","attr":"$.message.issue.updated_at","_RETURN_":"attr are present","action":["issue"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_UPDATED_AT_CLOSED",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_UPDATED_AT_CLOSED**

- $.message.issue.updated_at must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_UPDATED_AT_CLOSED",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							REQUIRED_ISSUE_ID_CLOSED,
							REQUIRED_ISSUE_STATUS,
							REQUIRED_ISSUE_ACTIONS_CLOSED,
							REQUIRED_CREATED_AT_CLOSED,
							REQUIRED_UPDATED_AT_CLOSED,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ISSUE_VALIDATION_CLOSED",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					ISSUE_VALIDATION_OPEN,
					ISSUE_VALIDATION_CLOSED,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "ISSUE_VALIDATION_VERSION_100",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}

		var testFunctions = validationutils.TestFunctionArray{
			REQUIRED_CONTEXT_FIELDS,
			ISSUE_VALIDATION_VERSION_200,
			ISSUE_VALIDATION_VERSION_100,
		}

		allResults := make([]validationutils.ValidationOutput, 0)

		for _, testFunc := range testFunctions {
			results, err := testFunc(input)
			if err != nil {
				return nil, err
			}
			allResults = append(allResults, results...)
		}

		subResults = allResults
		// if all subResults are valid, then valid is true
		valid = true
		for _, res := range subResults {
			if !res.Valid {
				valid = false
				break
			}
		}

		configureDebugInfo = `NESTED_TEST_OBJECT`

		delete(testObjMap, "_EXTERNAL")
	}

	result := validationutils.ValidationOutput{
		TestName: "IssueValidations",
		Valid:    valid,
		Code:     0,
		DebugInfo: &validationutils.DebugInfo{
			FedConfig: configureDebugInfo,
		},
	}

	if valid {
		result.Code = 200
	} else {
		result.Code = 30000
	}

	results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
	results = append(results, result)
	results = append(results, subResults...)

	return results, nil
}
