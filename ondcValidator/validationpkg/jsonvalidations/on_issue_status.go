// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.

package jsonvalidations

import (
	"fmt"
	"validationpkg/validationutils"
)

func On_issue_status_Tests(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	totalResults, err := On_issue_statusValidations(input)
	if err != nil {
		return nil, err
	}

	if !input.Config.Debug {
		for i := range totalResults {
			totalResults[i].DebugInfo = nil
		}
	}

	if input.Config.HideParentErrors {
		// Delete results with valid false and no description
		filtered := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid && r.Description == "" {
				continue
			}
			filtered = append(filtered, r)
		}
		totalResults = filtered
	}

	if input.Config.OnlyInvalid {
		res := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid {
				res = append(res, r)
			}
		}

		if len(res) == 0 {
			// Find the overall test result
			var targetSuccess *validationutils.ValidationOutput
			for i := range totalResults {
				if totalResults[i].TestName == "On_issue_statusValidations" {
					targetSuccess = &totalResults[i]
					break
				}
			}

			if targetSuccess == nil {
				panic("Critical: Overall test result not found")
			}

			return []validationutils.ValidationOutput{*targetSuccess}, nil
		}

		return res, nil
	}

	return totalResults, nil
}

var On_issue_statusValidations = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	scope := validationutils.GetJsonPath(input.Payload, "$", true)

	subResults := make([]validationutils.ValidationOutput, 0)
	valid := true
	configureDebugInfo := ""
	for _, testObj := range scope {
		testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("Invalid object structure in scope for test On_issue_statusValidations")
		}

		testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

		var REQUIRED_CONTEXT_FIELDS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_FIELDS")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				var REQUIRED_CONTEXT_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_DOMAIN")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_DOMAIN","attr":"$.context.domain","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_DOMAIN",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_DOMAIN**

- $.context.domain must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_DOMAIN",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_COUNTRY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_COUNTRY")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.context.location.country.code`})
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_COUNTRY","attr":["$.context.location.country.code"],"_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_COUNTRY",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_COUNTRY**

- ["$.context.location.country.code"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_COUNTRY",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_CITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_CITY")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.context.location.city.code`})
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_CITY","attr":["$.context.location.city.code"],"_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_CITY",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_CITY**

- ["$.context.location.city.code"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_CITY",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_TRANSACTION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_TRANSACTION_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.transaction_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_TRANSACTION_ID","attr":"$.context.transaction_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_TRANSACTION_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_TRANSACTION_ID**

- $.context.transaction_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_TRANSACTION_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_MESSAGE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_MESSAGE_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.message_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_MESSAGE_ID","attr":"$.context.message_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_MESSAGE_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_MESSAGE_ID**

- $.context.message_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_MESSAGE_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_ACTION")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_ACTION","attr":"$.context.action","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_ACTION",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_ACTION**

- $.context.action must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_ACTION",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_TIMESTAMP")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.timestamp", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_TIMESTAMP","attr":"$.context.timestamp","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_TIMESTAMP",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_TIMESTAMP**

- $.context.timestamp must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_TIMESTAMP",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_VERSION")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.context.version`})
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_VERSION","attr":["$.context.version"],"_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_VERSION",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_VERSION**

- ["$.context.version"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_VERSION",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BAP_URI")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BAP_URI","attr":"$.context.bap_uri","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BAP_URI",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BAP_URI**

- $.context.bap_uri must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BAP_URI",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BAP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BAP_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BAP_ID","attr":"$.context.bap_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BAP_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BAP_ID**

- $.context.bap_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BAP_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BPP_URI")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BPP_URI","attr":"$.context.bpp_uri","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BPP_URI",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BPP_URI**

- $.context.bpp_uri must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BPP_URI",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_BPP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_BPP_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_id", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_BPP_ID","attr":"$.context.bpp_id","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_BPP_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_BPP_ID**

- $.context.bpp_id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_BPP_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_CONTEXT_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_TTL")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_TTL","attr":"$.context.ttl","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_TTL",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_CONTEXT_TTL**

- $.context.ttl must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_CONTEXT_TTL",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var VALID_CONTEXT_COUNTRY_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test VALID_CONTEXT_COUNTRY_CODE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.context.country", true)
						validationutils.UnusedFunction(attr)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"VALID_CONTEXT_COUNTRY_CODE","attr":"$.context.country","_RETURN_":"attr are present"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "VALID_CONTEXT_COUNTRY_CODE",
								Valid:    false,
								Code:     30000,
								Description: `#### **VALID_CONTEXT_COUNTRY_CODE**

- $.context.country must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "VALID_CONTEXT_COUNTRY_CODE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					REQUIRED_CONTEXT_DOMAIN,
					REQUIRED_CONTEXT_COUNTRY,
					REQUIRED_CONTEXT_CITY,
					REQUIRED_CONTEXT_TRANSACTION_ID,
					REQUIRED_CONTEXT_MESSAGE_ID,
					REQUIRED_CONTEXT_ACTION,
					REQUIRED_CONTEXT_TIMESTAMP,
					REQUIRED_CONTEXT_VERSION,
					REQUIRED_CONTEXT_BAP_URI,
					REQUIRED_CONTEXT_BAP_ID,
					REQUIRED_CONTEXT_BPP_URI,
					REQUIRED_CONTEXT_BPP_ID,
					REQUIRED_CONTEXT_TTL,
					VALID_CONTEXT_COUNTRY_CODE,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "REQUIRED_CONTEXT_FIELDS",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var ISSUE_ON_ISSUE_STATUS_VALIDATION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test ISSUE_ON_ISSUE_STATUS_VALIDATION")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
				validationutils.UnusedFunction(action)

				var REQUIRED_ISSUE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.id", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_ID","attr":"$.message.issue.id","_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_ISSUE_ID**

- $.message.issue.id must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_ISSUE_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESPONDENT_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESPONDENT_ACTION")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.respondent_actions[*].respondent_action", true)
						validationutils.UnusedFunction(attr)
						enumList := validationutils.StringSliceToInterface([]string{`OPEN`, `PROCESSING`, `RESOLVED`, `CLOSED`, `INFO_PROVIDED`, `NEED_MORE_INFO`})
						validationutils.UnusedFunction(enumList)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, enumList))

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESPONDENT_ACTION","attr":"$.message.issue.issue_actions.respondent_actions[*].respondent_action","_RETURN_":"attr are present && attr all in enumList","enumList":["OPEN","PROCESSING","RESOLVED","CLOSED","INFO_PROVIDED","NEED_MORE_INFO"],"action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESPONDENT_ACTION",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESPONDENT_ACTION**

**All of the following must be true:**
  - $.message.issue.issue_actions.respondent_actions[*].respondent_action must be present in the payload
  - All elements of $.message.issue.issue_actions.respondent_actions[*].respondent_action must be in ["OPEN", "PROCESSING", "RESOLVED", "CLOSED", "INFO_PROVIDED", "NEED_MORE_INFO"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESPONDENT_ACTION",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESPONDENT_SHORT_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESPONDENT_SHORT_DESC")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.respondent_actions[*].short_desc", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESPONDENT_SHORT_DESC","attr":"$.message.issue.issue_actions.respondent_actions[*].short_desc","_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESPONDENT_SHORT_DESC",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESPONDENT_SHORT_DESC**

- $.message.issue.issue_actions.respondent_actions[*].short_desc must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESPONDENT_SHORT_DESC",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESPONDENT_UPDATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESPONDENT_UPDATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.respondent_actions[*].updated_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESPONDENT_UPDATED_AT","attr":"$.message.issue.issue_actions.respondent_actions[*].updated_at","_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESPONDENT_UPDATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESPONDENT_UPDATED_AT**

- $.message.issue.issue_actions.respondent_actions[*].updated_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESPONDENT_UPDATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESPONDENT_UPDATED_BY_PERSON = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESPONDENT_UPDATED_BY_PERSON")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.respondent_actions[*].updated_by.person.name", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESPONDENT_UPDATED_BY_PERSON","attr":"$.message.issue.issue_actions.respondent_actions[*].updated_by.person.name","_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESPONDENT_UPDATED_BY_PERSON",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESPONDENT_UPDATED_BY_PERSON**

- $.message.issue.issue_actions.respondent_actions[*].updated_by.person.name must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESPONDENT_UPDATED_BY_PERSON",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESPONDENT_UPDATED_BY_ORG = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESPONDENT_UPDATED_BY_ORG")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.issue_actions.respondent_actions[*].updated_by.org.name", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESPONDENT_UPDATED_BY_ORG","attr":"$.message.issue.issue_actions.respondent_actions[*].updated_by.org.name","_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESPONDENT_UPDATED_BY_ORG",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESPONDENT_UPDATED_BY_ORG**

- $.message.issue.issue_actions.respondent_actions[*].updated_by.org.name must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESPONDENT_UPDATED_BY_ORG",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_ISSUE_CREATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_CREATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.created_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_CREATED_AT","attr":"$.message.issue.created_at","_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_CREATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_ISSUE_CREATED_AT**

- $.message.issue.created_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_ISSUE_CREATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_ISSUE_UPDATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_ISSUE_UPDATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.updated_at", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_ISSUE_UPDATED_AT","attr":"$.message.issue.updated_at","_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_ISSUE_UPDATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_ISSUE_UPDATED_AT**

- $.message.issue.updated_at must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_ISSUE_UPDATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESOLUTION_SHORT_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESOLUTION_SHORT_DESC")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.message.issue.resolution.short_desc`})
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESOLUTION_SHORT_DESC","attr":["$.message.issue.resolution.short_desc"],"_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESOLUTION_SHORT_DESC",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESOLUTION_SHORT_DESC**

- ["$.message.issue.resolution.short_desc"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESOLUTION_SHORT_DESC",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESOLUTION_LONG_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESOLUTION_LONG_DESC")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.message.issue.resolution.long_desc`})
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESOLUTION_LONG_DESC","attr":["$.message.issue.resolution.long_desc"],"_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESOLUTION_LONG_DESC",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESOLUTION_LONG_DESC**

- ["$.message.issue.resolution.long_desc"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESOLUTION_LONG_DESC",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESOLUTION_ACTION_TRIGGERED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESOLUTION_ACTION_TRIGGERED")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.StringSliceToInterface([]string{`$.message.issue.resolution.action_triggered`})
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESOLUTION_ACTION_TRIGGERED","attr":["$.message.issue.resolution.action_triggered"],"_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESOLUTION_ACTION_TRIGGERED",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESOLUTION_ACTION_TRIGGERED**

- ["$.message.issue.resolution.action_triggered"] must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESOLUTION_ACTION_TRIGGERED",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESOLUTION_PROVIDER_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESOLUTION_PROVIDER_TYPE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.resolution_provider.respondent_info.type", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESOLUTION_PROVIDER_TYPE","attr":"$.message.issue.resolution_provider.respondent_info.type","_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESOLUTION_PROVIDER_TYPE",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESOLUTION_PROVIDER_TYPE**

- $.message.issue.resolution_provider.respondent_info.type must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESOLUTION_PROVIDER_TYPE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESOLUTION_PROVIDER_ORG_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESOLUTION_PROVIDER_ORG_NAME")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.resolution_provider.respondent_info.organization.org.name", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESOLUTION_PROVIDER_ORG_NAME","attr":"$.message.issue.resolution_provider.respondent_info.organization.org.name","_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESOLUTION_PROVIDER_ORG_NAME",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESOLUTION_PROVIDER_ORG_NAME**

- $.message.issue.resolution_provider.respondent_info.organization.org.name must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESOLUTION_PROVIDER_ORG_NAME",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var REQUIRED_RESOLUTION_PROVIDER_PERSON_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_RESOLUTION_PROVIDER_PERSON_NAME")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.issue.resolution_provider.respondent_info.organization.person.name", true)
						validationutils.UnusedFunction(attr)
						action := validationutils.StringSliceToInterface([]string{`on_issue_status`})
						validationutils.UnusedFunction(action)

						validate := validationutils.ArePresent(attr)

						configureDebugInfo = `{"_NAME_":"REQUIRED_RESOLUTION_PROVIDER_PERSON_NAME","attr":"$.message.issue.resolution_provider.respondent_info.organization.person.name","_RETURN_":"attr are present","action":["on_issue_status"]}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_RESOLUTION_PROVIDER_PERSON_NAME",
								Valid:    false,
								Code:     30000,
								Description: `#### **REQUIRED_RESOLUTION_PROVIDER_PERSON_NAME**

- $.message.issue.resolution_provider.respondent_info.organization.person.name must be present in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "REQUIRED_RESOLUTION_PROVIDER_PERSON_NAME",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					REQUIRED_ISSUE_ID,
					REQUIRED_RESPONDENT_ACTION,
					REQUIRED_RESPONDENT_SHORT_DESC,
					REQUIRED_RESPONDENT_UPDATED_AT,
					REQUIRED_RESPONDENT_UPDATED_BY_PERSON,
					REQUIRED_RESPONDENT_UPDATED_BY_ORG,
					REQUIRED_ISSUE_CREATED_AT,
					REQUIRED_ISSUE_UPDATED_AT,
					REQUIRED_RESOLUTION_SHORT_DESC,
					REQUIRED_RESOLUTION_LONG_DESC,
					REQUIRED_RESOLUTION_ACTION_TRIGGERED,
					REQUIRED_RESOLUTION_PROVIDER_TYPE,
					REQUIRED_RESOLUTION_PROVIDER_ORG_NAME,
					REQUIRED_RESOLUTION_PROVIDER_PERSON_NAME,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "ISSUE_ON_ISSUE_STATUS_VALIDATION",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}

		var testFunctions = validationutils.TestFunctionArray{
			REQUIRED_CONTEXT_FIELDS,
			ISSUE_ON_ISSUE_STATUS_VALIDATION,
		}

		allResults := make([]validationutils.ValidationOutput, 0)

		for _, testFunc := range testFunctions {
			results, err := testFunc(input)
			if err != nil {
				return nil, err
			}
			allResults = append(allResults, results...)
		}

		subResults = allResults
		// if all subResults are valid, then valid is true
		valid = true
		for _, res := range subResults {
			if !res.Valid {
				valid = false
				break
			}
		}

		configureDebugInfo = `NESTED_TEST_OBJECT`

		delete(testObjMap, "_EXTERNAL")
	}

	result := validationutils.ValidationOutput{
		TestName: "On_issue_statusValidations",
		Valid:    valid,
		Code:     0,
		DebugInfo: &validationutils.DebugInfo{
			FedConfig: configureDebugInfo,
		},
	}

	if valid {
		result.Code = 200
	} else {
		result.Code = 30000
	}

	results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
	results = append(results, result)
	results = append(results, subResults...)

	return results, nil
}
