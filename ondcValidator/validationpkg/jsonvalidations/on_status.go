// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.

package jsonvalidations

import (
	"fmt"
	"validationpkg/validationutils"
)

func On_status_Tests(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	totalResults, err := On_statusValidations(input)
	if err != nil {
		return nil, err
	}

	if !input.Config.Debug {
		for i := range totalResults {
			totalResults[i].DebugInfo = nil
		}
	}

	if input.Config.HideParentErrors {
		// Delete results with valid false and no description
		filtered := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid && r.Description == "" {
				continue
			}
			filtered = append(filtered, r)
		}
		totalResults = filtered
	}

	if input.Config.OnlyInvalid {
		res := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid {
				res = append(res, r)
			}
		}

		if len(res) == 0 {
			// Find the overall test result
			var targetSuccess *validationutils.ValidationOutput
			for i := range totalResults {
				if totalResults[i].TestName == "On_statusValidations" {
					targetSuccess = &totalResults[i]
					break
				}
			}

			if targetSuccess == nil {
				panic("Critical: Overall test result not found")
			}

			return []validationutils.ValidationOutput{*targetSuccess}, nil
		}

		return res, nil
	}

	return totalResults, nil
}

var On_statusValidations = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	scope := validationutils.GetJsonPath(input.Payload, "$", true)

	subResults := make([]validationutils.ValidationOutput, 0)
	valid := true
	configureDebugInfo := ""
	for _, testObj := range scope {
		testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("Invalid object structure in scope for test On_statusValidations")
		}

		testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

		var ON_STATUS_CONTEXT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test ON_STATUS_CONTEXT")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				action := validationutils.StringSliceToInterface([]string{`on_status`})
				validationutils.UnusedFunction(action)

				var CONTEXT_REQUIRED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CONTEXT_REQUIRED_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_DOMAIN")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_DOMAIN","attr":"$.context.domain","_RETURN_":"attr are present","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_DOMAIN",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_DOMAIN**

- $.context.domain must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_DOMAIN",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_ACTION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_ACTION","attr":"$.context.action","_RETURN_":"attr are present","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_ACTION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_ACTION**

- $.context.action must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_ACTION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_COUNTRY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_COUNTRY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.country", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_COUNTRY","attr":"$.context.country","_RETURN_":"attr are present","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_COUNTRY",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_COUNTRY**

- $.context.country must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_COUNTRY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_CONTEXT_CODE_14 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_CODE_14")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.city", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^(std:\d{3,5}|\*)$`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_CODE_14","attr":"$.context.city","reg":["^(std:\\\\d{3,5}|\\\\*)$"],"_RETURN_":"attr follow regex reg","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_CONTEXT_CODE_14",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_CONTEXT_CODE_14**

- All elements of $.context.city must follow every regex in ["^(std:\\d{3,5}|\\*)$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_CODE_14",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_VERSION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.core_version", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_VERSION","attr":"$.context.core_version","_RETURN_":"attr are present","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_VERSION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_VERSION**

- $.context.core_version must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_VERSION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BAP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BAP_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BAP_ID","attr":"$.context.bap_id","_RETURN_":"attr are present","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BAP_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BAP_ID**

- $.context.bap_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BAP_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BAP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BAP_URI","attr":"$.context.bap_uri","_RETURN_":"attr are present","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BAP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BAP_URI**

- $.context.bap_uri must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BAP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BPP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BPP_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BPP_ID","search":["search"],"attr":"$.context.bpp_id","_CONTINUE_":"(action equal to search)","_RETURN_":"attr are present","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BPP_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BPP_ID**

- $.context.bpp_id must be present in the payload

> **Skip if:**
>
>     - ["on_status"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BPP_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BPP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BPP_URI","search":["search"],"_CONTINUE_":"(action equal to search)","attr":"$.context.bpp_uri","_RETURN_":"attr are present","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BPP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BPP_URI**

- $.context.bpp_uri must be present in the payload

> **Skip if:**
>
>     - ["on_status"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BPP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TRANSACTION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TRANSACTION_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.transaction_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TRANSACTION_ID","attr":"$.context.transaction_id","_RETURN_":"attr are present","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TRANSACTION_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TRANSACTION_ID**

- $.context.transaction_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TRANSACTION_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_MESSAGE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_MESSAGE_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.message_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_MESSAGE_ID","attr":"$.context.message_id","_RETURN_":"attr are present","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_MESSAGE_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_MESSAGE_ID**

- $.context.message_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_MESSAGE_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TIMESTAMP")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.timestamp", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TIMESTAMP","attr":"$.context.timestamp","reg":["^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}Z$"],"_RETURN_":"attr follow regex reg","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TIMESTAMP",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TIMESTAMP**

- All elements of $.context.timestamp must follow every regex in ["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TIMESTAMP",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
								validationutils.UnusedFunction(attr)
								optional_vars := validationutils.StringSliceToInterface([]string{`on_search`, `on_select`, `on_confirm`, `on_init`, `on_cancel`, `on_track`, `on_update`, `on_status`})
								validationutils.UnusedFunction(optional_vars)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.AllIn(action, optional_vars)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TTL","attr":"$.context.ttl","optional_vars":["on_search","on_select","on_confirm","on_init","on_cancel","on_track","on_update","on_status"],"_CONTINUE_":"(action all in optional_vars)","_RETURN_":"attr are present","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TTL**

- $.context.ttl must be present in the payload

> **Skip if:**
>
>     - all elements of ["on_status"] are in ["on_search", "on_select", "on_confirm", "on_init", "on_cancel", "on_track", "on_update", "on_status"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CONTEXT_REQUIRED_DOMAIN,
							CONTEXT_REQUIRED_ACTION,
							CONTEXT_REQUIRED_COUNTRY,
							REQUIRED_CONTEXT_CODE_14,
							CONTEXT_REQUIRED_VERSION,
							CONTEXT_REQUIRED_BAP_ID,
							CONTEXT_REQUIRED_BAP_URI,
							CONTEXT_REQUIRED_BPP_ID,
							CONTEXT_REQUIRED_BPP_URI,
							CONTEXT_REQUIRED_TRANSACTION_ID,
							CONTEXT_REQUIRED_MESSAGE_ID,
							CONTEXT_REQUIRED_TIMESTAMP,
							CONTEXT_REQUIRED_TTL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CONTEXT_REQUIRED",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var CONTEXT_ENUM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CONTEXT_ENUM_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_DOMAIN")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								domain := validationutils.StringSliceToInterface([]string{`ONDC:RET10`})
								validationutils.UnusedFunction(domain)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.EqualTo(attr, domain)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_DOMAIN","domain":["ONDC:RET10"],"attr":"$.context.domain","_RETURN_":"attr equal to domain","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_DOMAIN",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_DOMAIN**

- $.context.domain must equal ["ONDC:RET10"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_DOMAIN",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_ENUM_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_ACTION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.EqualTo(attr, action)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_ACTION","attr":"$.context.action","_RETURN_":"attr equal to action","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_ACTION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_ACTION**

- $.context.action must equal ["on_status"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_ACTION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_ENUM_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_VERSION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								version := validationutils.StringSliceToInterface([]string{`1.2.5`})
								validationutils.UnusedFunction(version)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.core_version", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.AllIn(attr, version)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_VERSION","version":["1.2.5"],"attr":"$.context.core_version","_RETURN_":"attr all in version","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_VERSION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_VERSION**

- All elements of $.context.core_version must be in ["1.2.5"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_VERSION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_BAP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^https?\:\/\/`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_BAP_URI","attr":"$.context.bap_uri","reg":["^https?\\:\\/\\/"],"_RETURN_":"attr follow regex reg","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_BAP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_BAP_URI**

- All elements of $.context.bap_uri must follow every regex in ["^https?\:\/\/"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_BAP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_BPP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^https?\:\/\/`})
								validationutils.UnusedFunction(reg)
								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_BPP_URI","attr":"$.context.bpp_uri","reg":["^https?\\:\\/\\/"],"_RETURN_":"attr follow regex reg","search":["search"],"_CONTINUE_":"(action equal to search)","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_BPP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_BPP_URI**

- All elements of $.context.bpp_uri must follow every regex in ["^https?\:\/\/"]

> **Skip if:**
>
>     - ["on_status"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_BPP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^P(?=\d|T)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$`})
								validationutils.UnusedFunction(reg)
								optional_vars := validationutils.StringSliceToInterface([]string{`on_search`, `on_select`, `on_confirm`, `on_init`, `on_cancel`, `on_track`, `on_update`, `on_status`})
								validationutils.UnusedFunction(optional_vars)
								action := validationutils.StringSliceToInterface([]string{`on_status`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.AllIn(action, optional_vars)
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_TTL","attr":"$.context.ttl","reg":["^P(?=\\\\d|T)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?(\\\\d+S)?)?$"],"optional_vars":["on_search","on_select","on_confirm","on_init","on_cancel","on_track","on_update","on_status"],"_CONTINUE_":"(action all in optional_vars)","_RETURN_":"attr follow regex reg","action":["on_status"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_TTL**

- All elements of $.context.ttl must follow every regex in ["^P(?=\\d|T)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$"]

> **Skip if:**
>
>     - all elements of ["on_status"] are in ["on_search", "on_select", "on_confirm", "on_init", "on_cancel", "on_track", "on_update", "on_status"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CONTEXT_ENUM_DOMAIN,
							CONTEXT_ENUM_ACTION,
							CONTEXT_ENUM_VERSION,
							CONTEXT_REG_BAP_URI,
							CONTEXT_REG_BPP_URI,
							CONTEXT_REG_TTL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CONTEXT_ENUM",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					CONTEXT_REQUIRED,
					CONTEXT_ENUM,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "ON_STATUS_CONTEXT",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var ON_STATUS_ORDER = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test ON_STATUS_ORDER")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				var ORDER_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_ID")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.order.id", true)
						validationutils.UnusedFunction(attr)
						pattern := validationutils.StringSliceToInterface([]string{`^[a-zA-Z0-9-]{1,32}$|^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`})
						validationutils.UnusedFunction(pattern)

						validate := (validationutils.ArePresent(attr)) && (validationutils.FollowRegex(attr, pattern))

						configureDebugInfo = `{"_NAME_":"ORDER_ID","attr":"$.message.order.id","pattern":["^[a-zA-Z0-9-]{1,32}$|^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"],"_RETURN_":"attr are present && attr follow regex pattern"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "ORDER_ID",
								Valid:    false,
								Code:     30000,
								Description: `#### **ORDER_ID**

**All of the following must be true:**
  - $.message.order.id must be present in the payload
  - All elements of $.message.order.id must follow every regex in ["^[a-zA-Z0-9-]{1,32}$|^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_ID",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_STATE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.order.state", true)
						validationutils.UnusedFunction(attr)
						var_enum := validationutils.StringSliceToInterface([]string{`Created`, `Accepted`, `In-progress`, `Completed`, `Cancelled`})
						validationutils.UnusedFunction(var_enum)

						validate := validationutils.AllIn(attr, var_enum)

						configureDebugInfo = `{"_NAME_":"ORDER_STATE","attr":"$.message.order.state","var_enum":["Created","Accepted","In-progress","Completed","Cancelled"],"_RETURN_":"attr all in var_enum"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "ORDER_STATE",
								Valid:    false,
								Code:     30000,
								Description: `#### **ORDER_STATE**

- All elements of $.message.order.state must be in ["Created", "Accepted", "In-progress", "Completed", "Cancelled"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_STATE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_PROVIDER = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_PROVIDER")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var ORDER_PROVIDER_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_PROVIDER_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.provider.id", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"ORDER_PROVIDER_ID","attr":"$.message.order.provider.id","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "ORDER_PROVIDER_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **ORDER_PROVIDER_ID**

- $.message.order.provider.id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "ORDER_PROVIDER_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var ORDER_PROVIDER_LOCATIONS_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_PROVIDER_LOCATIONS_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.provider.locations[*].id", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"ORDER_PROVIDER_LOCATIONS_ID","attr":"$.message.order.provider.locations[*].id","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "ORDER_PROVIDER_LOCATIONS_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **ORDER_PROVIDER_LOCATIONS_ID**

- $.message.order.provider.locations[*].id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "ORDER_PROVIDER_LOCATIONS_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							ORDER_PROVIDER_ID,
							ORDER_PROVIDER_LOCATIONS_ID,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_PROVIDER",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_CANCELLATION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_CANCELLATION")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CANCELLATION_CANCELLED_BY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CANCELLATION_CANCELLED_BY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.cancellation.cancelled_by", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CANCELLATION_CANCELLED_BY","_CONTINUE_":"!(attr are present)","attr":"$.message.order.cancellation.cancelled_by","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CANCELLATION_CANCELLED_BY",
										Valid:    false,
										Code:     30000,
										Description: `#### **CANCELLATION_CANCELLED_BY**

- $.message.order.cancellation.cancelled_by must be present in the payload

> **Skip if:**
>
>     - $.message.order.cancellation.cancelled_by is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CANCELLATION_CANCELLED_BY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CANCELLATION_REASON = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CANCELLATION_REASON")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var CANCELLATION_REASON_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test CANCELLATION_REASON_ID")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.cancellation.reason.id", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"CANCELLATION_REASON_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.cancellation.reason.id","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "CANCELLATION_REASON_ID",
												Valid:    false,
												Code:     30000,
												Description: `#### **CANCELLATION_REASON_ID**

- $.message.order.cancellation.reason.id must be present in the payload

> **Skip if:**
>
>     - $.message.order.cancellation.reason.id is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "CANCELLATION_REASON_ID",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var CANCELLATION_REASON_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test CANCELLATION_REASON_STATE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.cancellation.reason.state", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"CANCELLATION_REASON_STATE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.cancellation.reason.state","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "CANCELLATION_REASON_STATE",
												Valid:    false,
												Code:     30000,
												Description: `#### **CANCELLATION_REASON_STATE**

- $.message.order.cancellation.reason.state must be present in the payload

> **Skip if:**
>
>     - $.message.order.cancellation.reason.state is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "CANCELLATION_REASON_STATE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									CANCELLATION_REASON_ID,
									CANCELLATION_REASON_STATE,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CANCELLATION_REASON",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CANCELLATION_CANCELLED_BY,
							CANCELLATION_REASON,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_CANCELLATION",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_ITEMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_ITEMS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var ITEMS_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.items[*].id", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"ITEMS_ID","attr":"$.message.order.items[*].id","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "ITEMS_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **ITEMS_ID**

- $.message.order.items[*].id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "ITEMS_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var ITEMS_FULFILLMENT_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_FULFILLMENT_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.items[*].fulfillment_id", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"ITEMS_FULFILLMENT_ID","attr":"$.message.order.items[*].fulfillment_id","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "ITEMS_FULFILLMENT_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **ITEMS_FULFILLMENT_ID**

- $.message.order.items[*].fulfillment_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "ITEMS_FULFILLMENT_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var ITEMS_LOCATION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_LOCATION_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.items[*].location_id", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"ITEMS_LOCATION_ID","attr":"$.message.order.items[*].location_id","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "ITEMS_LOCATION_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **ITEMS_LOCATION_ID**

- $.message.order.items[*].location_id must be present in the payload

> **Skip if:**
>
>     - $.message.order.items[*].location_id is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "ITEMS_LOCATION_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var ITEMS_QUANTITY_COUNT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test ITEMS_QUANTITY_COUNT")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.items[*].quantity.count", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"ITEMS_QUANTITY_COUNT","attr":"$.message.order.items[*].quantity.count","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "ITEMS_QUANTITY_COUNT",
										Valid:    false,
										Code:     30000,
										Description: `#### **ITEMS_QUANTITY_COUNT**

- $.message.order.items[*].quantity.count must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "ITEMS_QUANTITY_COUNT",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							ITEMS_ID,
							ITEMS_FULFILLMENT_ID,
							ITEMS_LOCATION_ID,
							ITEMS_QUANTITY_COUNT,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_ITEMS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_BILLING = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_BILLING")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var BILLING_ADDRESS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_ADDRESS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var BILLING_ADDRESS_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_ADDRESS_NAME")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.billing.address.name", true)
										validationutils.UnusedFunction(attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"BILLING_ADDRESS_NAME","attr":"$.message.order.billing.address.name","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "BILLING_ADDRESS_NAME",
												Valid:    false,
												Code:     30000,
												Description: `#### **BILLING_ADDRESS_NAME**

- $.message.order.billing.address.name must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "BILLING_ADDRESS_NAME",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var BILLING_ADDRESS_BUILDING = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_ADDRESS_BUILDING")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.billing.address.building", true)
										validationutils.UnusedFunction(attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"BILLING_ADDRESS_BUILDING","attr":"$.message.order.billing.address.building","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "BILLING_ADDRESS_BUILDING",
												Valid:    false,
												Code:     30000,
												Description: `#### **BILLING_ADDRESS_BUILDING**

- $.message.order.billing.address.building must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "BILLING_ADDRESS_BUILDING",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var BILLING_ADDRESS_LOCALITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_ADDRESS_LOCALITY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.billing.address.locality", true)
										validationutils.UnusedFunction(attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"BILLING_ADDRESS_LOCALITY","attr":"$.message.order.billing.address.locality","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "BILLING_ADDRESS_LOCALITY",
												Valid:    false,
												Code:     30000,
												Description: `#### **BILLING_ADDRESS_LOCALITY**

- $.message.order.billing.address.locality must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "BILLING_ADDRESS_LOCALITY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var BILLING_ADDRESS_CITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_ADDRESS_CITY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.billing.address.city", true)
										validationutils.UnusedFunction(attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"BILLING_ADDRESS_CITY","attr":"$.message.order.billing.address.city","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "BILLING_ADDRESS_CITY",
												Valid:    false,
												Code:     30000,
												Description: `#### **BILLING_ADDRESS_CITY**

- $.message.order.billing.address.city must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "BILLING_ADDRESS_CITY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var BILLING_ADDRESS_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_ADDRESS_STATE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.billing.address.state", true)
										validationutils.UnusedFunction(attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"BILLING_ADDRESS_STATE","attr":"$.message.order.billing.address.state","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "BILLING_ADDRESS_STATE",
												Valid:    false,
												Code:     30000,
												Description: `#### **BILLING_ADDRESS_STATE**

- $.message.order.billing.address.state must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "BILLING_ADDRESS_STATE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var BILLING_ADDRESS_COUNTRY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_ADDRESS_COUNTRY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.billing.address.country", true)
										validationutils.UnusedFunction(attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"BILLING_ADDRESS_COUNTRY","attr":"$.message.order.billing.address.country","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "BILLING_ADDRESS_COUNTRY",
												Valid:    false,
												Code:     30000,
												Description: `#### **BILLING_ADDRESS_COUNTRY**

- $.message.order.billing.address.country must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "BILLING_ADDRESS_COUNTRY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var BILLING_ADDRESS_AREA_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_ADDRESS_AREA_CODE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.billing.address.area_code", true)
										validationutils.UnusedFunction(attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"BILLING_ADDRESS_AREA_CODE","attr":"$.message.order.billing.address.area_code","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "BILLING_ADDRESS_AREA_CODE",
												Valid:    false,
												Code:     30000,
												Description: `#### **BILLING_ADDRESS_AREA_CODE**

- $.message.order.billing.address.area_code must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "BILLING_ADDRESS_AREA_CODE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									BILLING_ADDRESS_NAME,
									BILLING_ADDRESS_BUILDING,
									BILLING_ADDRESS_LOCALITY,
									BILLING_ADDRESS_CITY,
									BILLING_ADDRESS_STATE,
									BILLING_ADDRESS_COUNTRY,
									BILLING_ADDRESS_AREA_CODE,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BILLING_ADDRESS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var BILLING_PHONE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_PHONE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.billing.phone", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"BILLING_PHONE","attr":"$.message.order.billing.phone","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "BILLING_PHONE",
										Valid:    false,
										Code:     30000,
										Description: `#### **BILLING_PHONE**

- $.message.order.billing.phone must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BILLING_PHONE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var BILLING_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_NAME")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.billing.name", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"BILLING_NAME","attr":"$.message.order.billing.name","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "BILLING_NAME",
										Valid:    false,
										Code:     30000,
										Description: `#### **BILLING_NAME**

- $.message.order.billing.name must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BILLING_NAME",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var BILLING_CREATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_CREATED_AT")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.billing.created_at", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"BILLING_CREATED_AT","attr":"$.message.order.billing.created_at","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "BILLING_CREATED_AT",
										Valid:    false,
										Code:     30000,
										Description: `#### **BILLING_CREATED_AT**

- $.message.order.billing.created_at must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BILLING_CREATED_AT",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var BILLING_UPDATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test BILLING_UPDATED_AT")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.billing.updated_at", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"BILLING_UPDATED_AT","attr":"$.message.order.billing.updated_at","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "BILLING_UPDATED_AT",
										Valid:    false,
										Code:     30000,
										Description: `#### **BILLING_UPDATED_AT**

- $.message.order.billing.updated_at must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "BILLING_UPDATED_AT",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							BILLING_ADDRESS,
							BILLING_PHONE,
							BILLING_NAME,
							BILLING_CREATED_AT,
							BILLING_UPDATED_AT,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_BILLING",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_FULFILLMENTS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_FULFILLMENTS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var FULFILLMENTS_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].id", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"FULFILLMENTS_ID","attr":"$.message.order.fulfillments[*].id","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **FULFILLMENTS_ID**

- $.message.order.fulfillments[*].id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_STATE_DESCRIPTOR_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_STATE_DESCRIPTOR_CODE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].state.descriptor.code", true)
								validationutils.UnusedFunction(attr)
								var_enum := validationutils.StringSliceToInterface([]string{`Pending`, `Packed`, `Agent-assigned`, `Order-picked-up`, `Out-for-delivery`, `Order-delivered`, `Cancelled`, `RTO-Initiated`, `RTO-Disposed`, `RTO-Delivered`})
								validationutils.UnusedFunction(var_enum)

								validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, var_enum))

								configureDebugInfo = `{"_NAME_":"FULFILLMENTS_STATE_DESCRIPTOR_CODE","attr":"$.message.order.fulfillments[*].state.descriptor.code","var_enum":["Pending","Packed","Agent-assigned","Order-picked-up","Out-for-delivery","Order-delivered","Cancelled","RTO-Initiated","RTO-Disposed","RTO-Delivered"],"_RETURN_":"attr are present && attr all in var_enum"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_STATE_DESCRIPTOR_CODE",
										Valid:    false,
										Code:     30000,
										Description: `#### **FULFILLMENTS_STATE_DESCRIPTOR_CODE**

**All of the following must be true:**
  - $.message.order.fulfillments[*].state.descriptor.code must be present in the payload
  - All elements of $.message.order.fulfillments[*].state.descriptor.code must be in ["Pending", "Packed", "Agent-assigned", "Order-picked-up", "Out-for-delivery", "Order-delivered", "Cancelled", "RTO-Initiated", "RTO-Disposed", "RTO-Delivered"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_STATE_DESCRIPTOR_CODE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_TYPE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].type", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"FULFILLMENTS_TYPE","attr":"$.message.order.fulfillments[*].type","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_TYPE",
										Valid:    false,
										Code:     30000,
										Description: `#### **FULFILLMENTS_TYPE**

- $.message.order.fulfillments[*].type must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_TYPE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_ONDC_ORG_PROVIDER_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_ONDC_ORG_PROVIDER_NAME")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*]['@ondc/org/provider_name']", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"FULFILLMENTS_ONDC_ORG_PROVIDER_NAME","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*]['@ondc/org/provider_name']","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_ONDC_ORG_PROVIDER_NAME",
										Valid:    false,
										Code:     30000,
										Description: `#### **FULFILLMENTS_ONDC_ORG_PROVIDER_NAME**

- $.message.order.fulfillments[*]['@ondc/org/provider_name'] must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*]['@ondc/org/provider_name'] is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_ONDC_ORG_PROVIDER_NAME",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_TRACKING = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_TRACKING")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tracking", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"FULFILLMENTS_TRACKING","attr":"$.message.order.fulfillments[*].tracking","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_TRACKING",
										Valid:    false,
										Code:     30000,
										Description: `#### **FULFILLMENTS_TRACKING**

- $.message.order.fulfillments[*].tracking must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_TRACKING",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_ONDC_ORG_TAT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_ONDC_ORG_TAT")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*]['@ondc/org/TAT']", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"FULFILLMENTS_ONDC_ORG_TAT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*]['@ondc/org/TAT']","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_ONDC_ORG_TAT",
										Valid:    false,
										Code:     30000,
										Description: `#### **FULFILLMENTS_ONDC_ORG_TAT**

- $.message.order.fulfillments[*]['@ondc/org/TAT'] must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*]['@ondc/org/TAT'] is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_ONDC_ORG_TAT",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_START = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var FULFILLMENTS_START_LOCATION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_LOCATION")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var FULFILLMENTS_START_LOCATION_DESCRIPTOR_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_LOCATION_DESCRIPTOR_NAME")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.location.descriptor.name", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_LOCATION_DESCRIPTOR_NAME","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.location.descriptor.name","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_LOCATION_DESCRIPTOR_NAME",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_START_LOCATION_DESCRIPTOR_NAME**

- $.message.order.fulfillments[*].start.location.descriptor.name must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.location.descriptor.name is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_LOCATION_DESCRIPTOR_NAME",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_START_LOCATION_GPS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_LOCATION_GPS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.location.gps", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_LOCATION_GPS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.location.gps","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_LOCATION_GPS",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_START_LOCATION_GPS**

- $.message.order.fulfillments[*].start.location.gps must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.location.gps is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_LOCATION_GPS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_START_LOCATION_ADDRESS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_LOCATION_ADDRESS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												var FULFILLMENTS_START_LOCATION_ADDRESS_LOCALITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_LOCATION_ADDRESS_LOCALITY")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.location.address.locality", true)
														validationutils.UnusedFunction(attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_LOCATION_ADDRESS_LOCALITY","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.location.address.locality","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "FULFILLMENTS_START_LOCATION_ADDRESS_LOCALITY",
																Valid:    false,
																Code:     30000,
																Description: `#### **FULFILLMENTS_START_LOCATION_ADDRESS_LOCALITY**

- $.message.order.fulfillments[*].start.location.address.locality must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.location.address.locality is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_LOCATION_ADDRESS_LOCALITY",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var FULFILLMENTS_START_LOCATION_ADDRESS_CITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_LOCATION_ADDRESS_CITY")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.location.address.city", true)
														validationutils.UnusedFunction(attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_LOCATION_ADDRESS_CITY","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.location.address.city","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "FULFILLMENTS_START_LOCATION_ADDRESS_CITY",
																Valid:    false,
																Code:     30000,
																Description: `#### **FULFILLMENTS_START_LOCATION_ADDRESS_CITY**

- $.message.order.fulfillments[*].start.location.address.city must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.location.address.city is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_LOCATION_ADDRESS_CITY",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var FULFILLMENTS_START_LOCATION_ADDRESS_AREA_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_LOCATION_ADDRESS_AREA_CODE")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.location.address.area_code", true)
														validationutils.UnusedFunction(attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_LOCATION_ADDRESS_AREA_CODE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.location.address.area_code","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "FULFILLMENTS_START_LOCATION_ADDRESS_AREA_CODE",
																Valid:    false,
																Code:     30000,
																Description: `#### **FULFILLMENTS_START_LOCATION_ADDRESS_AREA_CODE**

- $.message.order.fulfillments[*].start.location.address.area_code must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.location.address.area_code is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_LOCATION_ADDRESS_AREA_CODE",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var FULFILLMENTS_START_LOCATION_ADDRESS_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_LOCATION_ADDRESS_STATE")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.location.address.state", true)
														validationutils.UnusedFunction(attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_LOCATION_ADDRESS_STATE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.location.address.state","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "FULFILLMENTS_START_LOCATION_ADDRESS_STATE",
																Valid:    false,
																Code:     30000,
																Description: `#### **FULFILLMENTS_START_LOCATION_ADDRESS_STATE**

- $.message.order.fulfillments[*].start.location.address.state must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.location.address.state is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_LOCATION_ADDRESS_STATE",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}

												var testFunctions = validationutils.TestFunctionArray{
													FULFILLMENTS_START_LOCATION_ADDRESS_LOCALITY,
													FULFILLMENTS_START_LOCATION_ADDRESS_CITY,
													FULFILLMENTS_START_LOCATION_ADDRESS_AREA_CODE,
													FULFILLMENTS_START_LOCATION_ADDRESS_STATE,
												}

												allResults := make([]validationutils.ValidationOutput, 0)

												for _, testFunc := range testFunctions {
													results, err := testFunc(input)
													if err != nil {
														return nil, err
													}
													allResults = append(allResults, results...)
												}

												subResults = allResults
												// if all subResults are valid, then valid is true
												valid = true
												for _, res := range subResults {
													if !res.Valid {
														valid = false
														break
													}
												}

												configureDebugInfo = `NESTED_TEST_OBJECT`

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_LOCATION_ADDRESS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											FULFILLMENTS_START_LOCATION_DESCRIPTOR_NAME,
											FULFILLMENTS_START_LOCATION_GPS,
											FULFILLMENTS_START_LOCATION_ADDRESS,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_START_LOCATION",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var FULFILLMENTS_START_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_TIME")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var FULFILLMENTS_START_TIME_RANGE_START = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_TIME_RANGE_START")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.time.range.start", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_TIME_RANGE_START","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.time.range.start","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_TIME_RANGE_START",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_START_TIME_RANGE_START**

- $.message.order.fulfillments[*].start.time.range.start must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.time.range.start is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_TIME_RANGE_START",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_START_TIME_RANGE_END = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_TIME_RANGE_END")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.time.range.end", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_TIME_RANGE_END","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.time.range.end","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_TIME_RANGE_END",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_START_TIME_RANGE_END**

- $.message.order.fulfillments[*].start.time.range.end must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.time.range.end is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_TIME_RANGE_END",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_START_TIME_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_TIME_TIMESTAMP")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.time.timestamp", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_TIME_TIMESTAMP","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.time.timestamp","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_TIME_TIMESTAMP",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_START_TIME_TIMESTAMP**

- $.message.order.fulfillments[*].start.time.timestamp must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.time.timestamp is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_TIME_TIMESTAMP",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											FULFILLMENTS_START_TIME_RANGE_START,
											FULFILLMENTS_START_TIME_RANGE_END,
											FULFILLMENTS_START_TIME_TIMESTAMP,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_START_TIME",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var FULFILLMENTS_START_INSTRUCTIONS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_INSTRUCTIONS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var FULFILLMENTS_START_INSTRUCTIONS_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_INSTRUCTIONS_CODE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.instructions.code", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`1`, `2`, `3`, `4`})
												validationutils.UnusedFunction(var_enum)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, var_enum))

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_INSTRUCTIONS_CODE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.instructions.code","var_enum":["1","2","3","4"],"_RETURN_":"attr are present && attr all in var_enum"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_INSTRUCTIONS_CODE",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_START_INSTRUCTIONS_CODE**

**All of the following must be true:**
  - $.message.order.fulfillments[*].start.instructions.code must be present in the payload
  - All elements of $.message.order.fulfillments[*].start.instructions.code must be in ["1", "2", "3", "4"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.instructions.code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_INSTRUCTIONS_CODE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_START_INSTRUCTIONS_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_INSTRUCTIONS_NAME")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.instructions.name", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_INSTRUCTIONS_NAME","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.instructions.name","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_INSTRUCTIONS_NAME",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_START_INSTRUCTIONS_NAME**

- $.message.order.fulfillments[*].start.instructions.name must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.instructions.name is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_INSTRUCTIONS_NAME",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_START_INSTRUCTIONS_SHORT_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_INSTRUCTIONS_SHORT_DESC")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.instructions.short_desc", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_INSTRUCTIONS_SHORT_DESC","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.instructions.short_desc","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_INSTRUCTIONS_SHORT_DESC",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_START_INSTRUCTIONS_SHORT_DESC**

- $.message.order.fulfillments[*].start.instructions.short_desc must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.instructions.short_desc is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_INSTRUCTIONS_SHORT_DESC",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_START_INSTRUCTIONS_LONG_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_INSTRUCTIONS_LONG_DESC")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.instructions.long_desc", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_INSTRUCTIONS_LONG_DESC","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.instructions.long_desc","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_INSTRUCTIONS_LONG_DESC",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_START_INSTRUCTIONS_LONG_DESC**

- $.message.order.fulfillments[*].start.instructions.long_desc must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.instructions.long_desc is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_INSTRUCTIONS_LONG_DESC",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											FULFILLMENTS_START_INSTRUCTIONS_CODE,
											FULFILLMENTS_START_INSTRUCTIONS_NAME,
											FULFILLMENTS_START_INSTRUCTIONS_SHORT_DESC,
											FULFILLMENTS_START_INSTRUCTIONS_LONG_DESC,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_START_INSTRUCTIONS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var FULFILLMENTS_START_CONTACT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_CONTACT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var FULFILLMENTS_START_CONTACT_PHONE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_CONTACT_PHONE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.contact.phone", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_CONTACT_PHONE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.contact.phone","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_CONTACT_PHONE",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_START_CONTACT_PHONE**

- $.message.order.fulfillments[*].start.contact.phone must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.contact.phone is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_CONTACT_PHONE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_START_CONTACT_EMAIL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_START_CONTACT_EMAIL")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].start.contact.email", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_START_CONTACT_EMAIL","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].start.contact.email","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_START_CONTACT_EMAIL",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_START_CONTACT_EMAIL**

- $.message.order.fulfillments[*].start.contact.email must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].start.contact.email is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_START_CONTACT_EMAIL",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											FULFILLMENTS_START_CONTACT_PHONE,
											FULFILLMENTS_START_CONTACT_EMAIL,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_START_CONTACT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									FULFILLMENTS_START_LOCATION,
									FULFILLMENTS_START_TIME,
									FULFILLMENTS_START_INSTRUCTIONS,
									FULFILLMENTS_START_CONTACT,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_START",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_END = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var FULFILLMENTS_END_LOCATION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_LOCATION")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var FULFILLMENTS_END_LOCATION_GPS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_LOCATION_GPS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.location.gps", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_LOCATION_GPS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.location.gps","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_LOCATION_GPS",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_END_LOCATION_GPS**

- $.message.order.fulfillments[*].end.location.gps must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.location.gps is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_LOCATION_GPS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_END_LOCATION_ADDRESS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_LOCATION_ADDRESS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												var FULFILLMENTS_END_LOCATION_ADDRESS_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_LOCATION_ADDRESS_NAME")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.location.address.name", true)
														validationutils.UnusedFunction(attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_LOCATION_ADDRESS_NAME","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.location.address.name","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_NAME",
																Valid:    false,
																Code:     30000,
																Description: `#### **FULFILLMENTS_END_LOCATION_ADDRESS_NAME**

- $.message.order.fulfillments[*].end.location.address.name must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.location.address.name is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_NAME",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var FULFILLMENTS_END_LOCATION_ADDRESS_BUILDING = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_LOCATION_ADDRESS_BUILDING")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.location.address.building", true)
														validationutils.UnusedFunction(attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_LOCATION_ADDRESS_BUILDING","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.location.address.building","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_BUILDING",
																Valid:    false,
																Code:     30000,
																Description: `#### **FULFILLMENTS_END_LOCATION_ADDRESS_BUILDING**

- $.message.order.fulfillments[*].end.location.address.building must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.location.address.building is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_BUILDING",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var FULFILLMENTS_END_LOCATION_ADDRESS_LOCALITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_LOCATION_ADDRESS_LOCALITY")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.location.address.locality", true)
														validationutils.UnusedFunction(attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_LOCATION_ADDRESS_LOCALITY","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.location.address.locality","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_LOCALITY",
																Valid:    false,
																Code:     30000,
																Description: `#### **FULFILLMENTS_END_LOCATION_ADDRESS_LOCALITY**

- $.message.order.fulfillments[*].end.location.address.locality must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.location.address.locality is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_LOCALITY",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var FULFILLMENTS_END_LOCATION_ADDRESS_COUNTRY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_LOCATION_ADDRESS_COUNTRY")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.location.address.country", true)
														validationutils.UnusedFunction(attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_LOCATION_ADDRESS_COUNTRY","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.location.address.country","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_COUNTRY",
																Valid:    false,
																Code:     30000,
																Description: `#### **FULFILLMENTS_END_LOCATION_ADDRESS_COUNTRY**

- $.message.order.fulfillments[*].end.location.address.country must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.location.address.country is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_COUNTRY",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var FULFILLMENTS_END_LOCATION_ADDRESS_CITY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_LOCATION_ADDRESS_CITY")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.location.address.city", true)
														validationutils.UnusedFunction(attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_LOCATION_ADDRESS_CITY","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.location.address.city","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_CITY",
																Valid:    false,
																Code:     30000,
																Description: `#### **FULFILLMENTS_END_LOCATION_ADDRESS_CITY**

- $.message.order.fulfillments[*].end.location.address.city must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.location.address.city is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_CITY",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var FULFILLMENTS_END_LOCATION_ADDRESS_AREA_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_LOCATION_ADDRESS_AREA_CODE")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.location.address.area_code", true)
														validationutils.UnusedFunction(attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_LOCATION_ADDRESS_AREA_CODE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.location.address.area_code","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_AREA_CODE",
																Valid:    false,
																Code:     30000,
																Description: `#### **FULFILLMENTS_END_LOCATION_ADDRESS_AREA_CODE**

- $.message.order.fulfillments[*].end.location.address.area_code must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.location.address.area_code is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_AREA_CODE",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var FULFILLMENTS_END_LOCATION_ADDRESS_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_LOCATION_ADDRESS_STATE")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.location.address.state", true)
														validationutils.UnusedFunction(attr)

														skipCheck := !(validationutils.ArePresent(attr))
														if skipCheck {
															continue
														}

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_LOCATION_ADDRESS_STATE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.location.address.state","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_STATE",
																Valid:    false,
																Code:     30000,
																Description: `#### **FULFILLMENTS_END_LOCATION_ADDRESS_STATE**

- $.message.order.fulfillments[*].end.location.address.state must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.location.address.state is not in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_LOCATION_ADDRESS_STATE",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}

												var testFunctions = validationutils.TestFunctionArray{
													FULFILLMENTS_END_LOCATION_ADDRESS_NAME,
													FULFILLMENTS_END_LOCATION_ADDRESS_BUILDING,
													FULFILLMENTS_END_LOCATION_ADDRESS_LOCALITY,
													FULFILLMENTS_END_LOCATION_ADDRESS_COUNTRY,
													FULFILLMENTS_END_LOCATION_ADDRESS_CITY,
													FULFILLMENTS_END_LOCATION_ADDRESS_AREA_CODE,
													FULFILLMENTS_END_LOCATION_ADDRESS_STATE,
												}

												allResults := make([]validationutils.ValidationOutput, 0)

												for _, testFunc := range testFunctions {
													results, err := testFunc(input)
													if err != nil {
														return nil, err
													}
													allResults = append(allResults, results...)
												}

												subResults = allResults
												// if all subResults are valid, then valid is true
												valid = true
												for _, res := range subResults {
													if !res.Valid {
														valid = false
														break
													}
												}

												configureDebugInfo = `NESTED_TEST_OBJECT`

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_LOCATION_ADDRESS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											FULFILLMENTS_END_LOCATION_GPS,
											FULFILLMENTS_END_LOCATION_ADDRESS,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_END_LOCATION",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var FULFILLMENTS_END_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_TIME")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var FULFILLMENTS_END_TIME_RANGE_START = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_TIME_RANGE_START")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.time.range.start", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_TIME_RANGE_START","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.time.range.start","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_TIME_RANGE_START",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_END_TIME_RANGE_START**

- $.message.order.fulfillments[*].end.time.range.start must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.time.range.start is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_TIME_RANGE_START",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_END_TIME_RANGE_END = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_TIME_RANGE_END")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.time.range.end", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_TIME_RANGE_END","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.time.range.end","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_TIME_RANGE_END",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_END_TIME_RANGE_END**

- $.message.order.fulfillments[*].end.time.range.end must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.time.range.end is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_TIME_RANGE_END",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_END_TIME_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_TIME_TIMESTAMP")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.time.timestamp", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_TIME_TIMESTAMP","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.time.timestamp","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_TIME_TIMESTAMP",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_END_TIME_TIMESTAMP**

- $.message.order.fulfillments[*].end.time.timestamp must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.time.timestamp is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_TIME_TIMESTAMP",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											FULFILLMENTS_END_TIME_RANGE_START,
											FULFILLMENTS_END_TIME_RANGE_END,
											FULFILLMENTS_END_TIME_TIMESTAMP,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_END_TIME",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var FULFILLMENTS_END_INSTRUCTIONS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_INSTRUCTIONS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var FULFILLMENTS_END_INSTRUCTIONS_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_INSTRUCTIONS_CODE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.instructions.code", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_INSTRUCTIONS_CODE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.instructions.code","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_INSTRUCTIONS_CODE",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_END_INSTRUCTIONS_CODE**

- $.message.order.fulfillments[*].end.instructions.code must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.instructions.code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_INSTRUCTIONS_CODE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_END_INSTRUCTIONS_NAME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_INSTRUCTIONS_NAME")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.instructions.name", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_INSTRUCTIONS_NAME","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.instructions.name","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_INSTRUCTIONS_NAME",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_END_INSTRUCTIONS_NAME**

- $.message.order.fulfillments[*].end.instructions.name must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.instructions.name is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_INSTRUCTIONS_NAME",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_END_INSTRUCTIONS_SHORT_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_INSTRUCTIONS_SHORT_DESC")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.instructions.short_desc", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_INSTRUCTIONS_SHORT_DESC","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.instructions.short_desc","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_INSTRUCTIONS_SHORT_DESC",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_END_INSTRUCTIONS_SHORT_DESC**

- $.message.order.fulfillments[*].end.instructions.short_desc must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.instructions.short_desc is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_INSTRUCTIONS_SHORT_DESC",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_END_INSTRUCTIONS_LONG_DESC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_INSTRUCTIONS_LONG_DESC")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.instructions.long_desc", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_INSTRUCTIONS_LONG_DESC","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.instructions.long_desc","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_INSTRUCTIONS_LONG_DESC",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_END_INSTRUCTIONS_LONG_DESC**

- $.message.order.fulfillments[*].end.instructions.long_desc must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.instructions.long_desc is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_INSTRUCTIONS_LONG_DESC",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											FULFILLMENTS_END_INSTRUCTIONS_CODE,
											FULFILLMENTS_END_INSTRUCTIONS_NAME,
											FULFILLMENTS_END_INSTRUCTIONS_SHORT_DESC,
											FULFILLMENTS_END_INSTRUCTIONS_LONG_DESC,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_END_INSTRUCTIONS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var FULFILLMENTS_END_CONTACT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_CONTACT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var FULFILLMENTS_END_CONTACT_PHONE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_CONTACT_PHONE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.contact.phone", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_CONTACT_PHONE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.contact.phone","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_CONTACT_PHONE",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_END_CONTACT_PHONE**

- $.message.order.fulfillments[*].end.contact.phone must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.contact.phone is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_CONTACT_PHONE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var FULFILLMENTS_END_CONTACT_EMAIL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_END_CONTACT_EMAIL")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].end.contact.email", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"FULFILLMENTS_END_CONTACT_EMAIL","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].end.contact.email","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "FULFILLMENTS_END_CONTACT_EMAIL",
														Valid:    false,
														Code:     30000,
														Description: `#### **FULFILLMENTS_END_CONTACT_EMAIL**

- $.message.order.fulfillments[*].end.contact.email must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].end.contact.email is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_END_CONTACT_EMAIL",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											FULFILLMENTS_END_CONTACT_PHONE,
											FULFILLMENTS_END_CONTACT_EMAIL,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_END_CONTACT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									FULFILLMENTS_END_LOCATION,
									FULFILLMENTS_END_TIME,
									FULFILLMENTS_END_INSTRUCTIONS,
									FULFILLMENTS_END_CONTACT,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_END",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_AGENT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_AGENT")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var FULFILLMENTS_AGENT_PHONE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_AGENT_PHONE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].agent.phone", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"FULFILLMENTS_AGENT_PHONE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].agent.phone","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_AGENT_PHONE",
												Valid:    false,
												Code:     30000,
												Description: `#### **FULFILLMENTS_AGENT_PHONE**

- $.message.order.fulfillments[*].agent.phone must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].agent.phone is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_AGENT_PHONE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									FULFILLMENTS_AGENT_PHONE,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_AGENT",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_VEHICLE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_VEHICLE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var FULFILLMENTS_VEHICLE_REGISTRATION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_VEHICLE_REGISTRATION")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].vehicle.registration", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"FULFILLMENTS_VEHICLE_REGISTRATION","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].vehicle.registration","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_VEHICLE_REGISTRATION",
												Valid:    false,
												Code:     30000,
												Description: `#### **FULFILLMENTS_VEHICLE_REGISTRATION**

- $.message.order.fulfillments[*].vehicle.registration must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].vehicle.registration is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_VEHICLE_REGISTRATION",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									FULFILLMENTS_VEHICLE_REGISTRATION,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_VEHICLE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILLMENTS_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_TAGS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var FULFILLMENTS_TAGS_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test FULFILLMENTS_TAGS_VALID_TAGS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[*].code", true)
										validationutils.UnusedFunction(attr)
										valid := validationutils.StringSliceToInterface([]string{`state`, `routing`, `tracking`, `fulfillment_delay`, `order_details`, `cancel_request`, `quote_trail`, `precancel_state`})
										validationutils.UnusedFunction(valid)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.AllIn(attr, valid)

										configureDebugInfo = `{"_NAME_":"FULFILLMENTS_TAGS_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[*].code","valid":["state","routing","tracking","fulfillment_delay","order_details","cancel_request","quote_trail","precancel_state"],"_RETURN_":"attr all in valid"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "FULFILLMENTS_TAGS_VALID_TAGS",
												Valid:    false,
												Code:     30000,
												Description: `#### **FULFILLMENTS_TAGS_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[*].code must be in ["state", "routing", "tracking", "fulfillment_delay", "order_details", "cancel_request", "quote_trail", "precancel_state"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[*].code is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "FULFILLMENTS_TAGS_VALID_TAGS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_STATE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var STATE_READY_TO_SHIP_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test STATE_READY_TO_SHIP_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='state')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`ready_to_ship`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"STATE_READY_TO_SHIP_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='state')].list[*].code","valid":["ready_to_ship"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "STATE_READY_TO_SHIP_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **STATE_READY_TO_SHIP_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='state')].list[*].code must be in ["ready_to_ship"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='state')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "STATE_READY_TO_SHIP_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var STATE_READY_TO_SHIP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test STATE_READY_TO_SHIP")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='state')].list[?(@.code=='ready_to_ship')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"STATE_READY_TO_SHIP","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='state')].list[?(@.code=='ready_to_ship')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "STATE_READY_TO_SHIP",
														Valid:    false,
														Code:     30000,
														Description: `#### **STATE_READY_TO_SHIP**

- $.message.order.fulfillments[*].tags[?(@.code=='state')].list[?(@.code=='ready_to_ship')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='state')].list[?(@.code=='ready_to_ship')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "STATE_READY_TO_SHIP",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											STATE_READY_TO_SHIP_VALID_TAGS,
											STATE_READY_TO_SHIP,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_STATE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_ROUTING = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_ROUTING")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_ROUTING_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_ROUTING_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='routing')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`type`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_ROUTING_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='routing')].list[*].code","valid":["type"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_ROUTING_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_ROUTING_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='routing')].list[*].code must be in ["type"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='routing')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_ROUTING_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var ROUTING_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test ROUTING_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='routing')].list[?(@.code=='type')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"ROUTING_TYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='routing')].list[?(@.code=='type')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "ROUTING_TYPE",
														Valid:    false,
														Code:     30000,
														Description: `#### **ROUTING_TYPE**

- $.message.order.fulfillments[*].tags[?(@.code=='routing')].list[?(@.code=='type')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='routing')].list[?(@.code=='type')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "ROUTING_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_ROUTING_VALID_TAGS,
											ROUTING_TYPE,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_ROUTING",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_TRACKING = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_TRACKING")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_TRACKING_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_TRACKING_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`gps_enabled`, `url_enabled`, `url`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_TRACKING_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[*].code","valid":["gps_enabled","url_enabled","url"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_TRACKING_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_TRACKING_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[*].code must be in ["gps_enabled", "url_enabled", "url"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_TRACKING_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TRACKING_GPS_ENABLED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TRACKING_GPS_ENABLED")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='gps_enabled')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"TRACKING_GPS_ENABLED","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='gps_enabled')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TRACKING_GPS_ENABLED",
														Valid:    false,
														Code:     30000,
														Description: `#### **TRACKING_GPS_ENABLED**

- $.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='gps_enabled')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='gps_enabled')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TRACKING_GPS_ENABLED",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TRACKING_URL_ENABLED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TRACKING_URL_ENABLED")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='url_enabled')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"TRACKING_URL_ENABLED","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='url_enabled')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TRACKING_URL_ENABLED",
														Valid:    false,
														Code:     30000,
														Description: `#### **TRACKING_URL_ENABLED**

- $.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='url_enabled')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='url_enabled')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TRACKING_URL_ENABLED",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var TRACKING_URL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TRACKING_URL")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='url')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^https?://.*$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"TRACKING_URL","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='url')].value","reg":["^https?://.*$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TRACKING_URL",
														Valid:    false,
														Code:     30000,
														Description: `#### **TRACKING_URL**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='url')].value must follow every regex in ["^https?://.*$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='tracking')].list[?(@.code=='url')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TRACKING_URL",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_TRACKING_VALID_TAGS,
											TRACKING_GPS_ENABLED,
											TRACKING_URL_ENABLED,
											TRACKING_URL,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_TRACKING",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_FULFILLMENT_DELAY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_FULFILLMENT_DELAY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_FULFILLMENT_DELAY_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_FULFILLMENT_DELAY_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`state`, `reason_id`, `timestamp`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_FULFILLMENT_DELAY_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[*].code","valid":["state","reason_id","timestamp"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_FULFILLMENT_DELAY_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_FULFILLMENT_DELAY_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[*].code must be in ["state", "reason_id", "timestamp"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_FULFILLMENT_DELAY_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DELAY_STATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DELAY_STATE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='state')].value", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`Order-picked-up`, `Order-delivered`})
												validationutils.UnusedFunction(var_enum)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"DELAY_STATE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='state')].value","var_enum":["Order-picked-up","Order-delivered"],"_RETURN_":"attr all in var_enum"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DELAY_STATE",
														Valid:    false,
														Code:     30000,
														Description: `#### **DELAY_STATE**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='state')].value must be in ["Order-picked-up", "Order-delivered"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='state')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DELAY_STATE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DELAY_REASON_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DELAY_REASON_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='reason_id')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"DELAY_REASON_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='reason_id')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DELAY_REASON_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **DELAY_REASON_ID**

- $.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='reason_id')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='reason_id')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DELAY_REASON_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var DELAY_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test DELAY_TIMESTAMP")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='timestamp')].value", true)
												validationutils.UnusedFunction(attr)
												reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$`})
												validationutils.UnusedFunction(reg)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.FollowRegex(attr, reg)

												configureDebugInfo = `{"_NAME_":"DELAY_TIMESTAMP","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='timestamp')].value","reg":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.*Z$"],"_RETURN_":"attr follow regex reg"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "DELAY_TIMESTAMP",
														Valid:    false,
														Code:     30000,
														Description: `#### **DELAY_TIMESTAMP**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='timestamp')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*Z$"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='fulfillment_delay')].list[?(@.code=='timestamp')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "DELAY_TIMESTAMP",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_FULFILLMENT_DELAY_VALID_TAGS,
											DELAY_STATE,
											DELAY_REASON_ID,
											DELAY_TIMESTAMP,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_FULFILLMENT_DELAY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var TAGS_ORDER_DETAILS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_ORDER_DETAILS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var TAGS_ORDER_DETAILS_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_ORDER_DETAILS_VALID_TAGS")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[*].code", true)
												validationutils.UnusedFunction(attr)
												valid := validationutils.StringSliceToInterface([]string{`id`, `weight_unit`, `weight_value`, `dim_unit`, `length`, `breadth`, `height`})
												validationutils.UnusedFunction(valid)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.AllIn(attr, valid)

												configureDebugInfo = `{"_NAME_":"TAGS_ORDER_DETAILS_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[*].code","valid":["id","weight_unit","weight_value","dim_unit","length","breadth","height"],"_RETURN_":"attr all in valid"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "TAGS_ORDER_DETAILS_VALID_TAGS",
														Valid:    false,
														Code:     30000,
														Description: `#### **TAGS_ORDER_DETAILS_VALID_TAGS**

- All elements of $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[*].code must be in ["id", "weight_unit", "weight_value", "dim_unit", "length", "breadth", "height"]

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[*].code is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "TAGS_ORDER_DETAILS_VALID_TAGS",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var ORDER_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='id')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"ORDER_ID","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='id')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "ORDER_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **ORDER_ID**

- $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='id')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='id')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "ORDER_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var ORDER_WEIGHT_UNIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_WEIGHT_UNIT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='weight_unit')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"ORDER_WEIGHT_UNIT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='weight_unit')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "ORDER_WEIGHT_UNIT",
														Valid:    false,
														Code:     30000,
														Description: `#### **ORDER_WEIGHT_UNIT**

- $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='weight_unit')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='weight_unit')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "ORDER_WEIGHT_UNIT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var ORDER_WEIGHT_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_WEIGHT_VALUE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='weight_value')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"ORDER_WEIGHT_VALUE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='weight_value')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "ORDER_WEIGHT_VALUE",
														Valid:    false,
														Code:     30000,
														Description: `#### **ORDER_WEIGHT_VALUE**

- $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='weight_value')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='weight_value')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "ORDER_WEIGHT_VALUE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var ORDER_DIM_UNIT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_DIM_UNIT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='dim_unit')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"ORDER_DIM_UNIT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='dim_unit')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "ORDER_DIM_UNIT",
														Valid:    false,
														Code:     30000,
														Description: `#### **ORDER_DIM_UNIT**

- $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='dim_unit')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='dim_unit')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "ORDER_DIM_UNIT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var ORDER_LENGTH = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_LENGTH")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='length')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"ORDER_LENGTH","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='length')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "ORDER_LENGTH",
														Valid:    false,
														Code:     30000,
														Description: `#### **ORDER_LENGTH**

- $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='length')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='length')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "ORDER_LENGTH",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var ORDER_BREADTH = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_BREADTH")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='breadth')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"ORDER_BREADTH","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='breadth')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "ORDER_BREADTH",
														Valid:    false,
														Code:     30000,
														Description: `#### **ORDER_BREADTH**

- $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='breadth')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='breadth')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "ORDER_BREADTH",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var ORDER_HEIGHT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_HEIGHT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='height')].value", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"ORDER_HEIGHT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='height')].value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "ORDER_HEIGHT",
														Valid:    false,
														Code:     30000,
														Description: `#### **ORDER_HEIGHT**

- $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='height')].value must be present in the payload

> **Skip if:**
>
>     - $.message.order.fulfillments[*].tags[?(@.code=='order_details')].list[?(@.code=='height')].value is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "ORDER_HEIGHT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											TAGS_ORDER_DETAILS_VALID_TAGS,
											ORDER_ID,
											ORDER_WEIGHT_UNIT,
											ORDER_WEIGHT_VALUE,
											ORDER_DIM_UNIT,
											ORDER_LENGTH,
											ORDER_BREADTH,
											ORDER_HEIGHT,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "TAGS_ORDER_DETAILS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									FULFILLMENTS_TAGS_VALID_TAGS,
									TAGS_STATE,
									TAGS_ROUTING,
									TAGS_TRACKING,
									TAGS_FULFILLMENT_DELAY,
									TAGS_ORDER_DETAILS,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILLMENTS_TAGS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							FULFILLMENTS_ID,
							FULFILLMENTS_STATE_DESCRIPTOR_CODE,
							FULFILLMENTS_TYPE,
							FULFILLMENTS_ONDC_ORG_PROVIDER_NAME,
							FULFILLMENTS_TRACKING,
							FULFILLMENTS_ONDC_ORG_TAT,
							FULFILLMENTS_START,
							FULFILLMENTS_END,
							FULFILLMENTS_AGENT,
							FULFILLMENTS_VEHICLE,
							FULFILLMENTS_TAGS,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_FULFILLMENTS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_QUOTE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_QUOTE")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var QUOTE_PRICE_CURRENCY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test QUOTE_PRICE_CURRENCY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.price.currency", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"QUOTE_PRICE_CURRENCY","attr":"$.message.order.quote.price.currency","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "QUOTE_PRICE_CURRENCY",
										Valid:    false,
										Code:     30000,
										Description: `#### **QUOTE_PRICE_CURRENCY**

- $.message.order.quote.price.currency must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "QUOTE_PRICE_CURRENCY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var QUOTE_PRICE_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test QUOTE_PRICE_VALUE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.price.value", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"QUOTE_PRICE_VALUE","attr":"$.message.order.quote.price.value","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "QUOTE_PRICE_VALUE",
										Valid:    false,
										Code:     30000,
										Description: `#### **QUOTE_PRICE_VALUE**

- $.message.order.quote.price.value must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "QUOTE_PRICE_VALUE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var QUOTE_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test QUOTE_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.ttl", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"QUOTE_TTL","attr":"$.message.order.quote.ttl","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "QUOTE_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **QUOTE_TTL**

- $.message.order.quote.ttl must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "QUOTE_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var QUOTE_BREAKUP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test QUOTE_BREAKUP")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var BREAKUP_ITEM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										var BREAKUP_ITEM_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_ID")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.breakup[*]['@ondc/org/item_id']", true)
												validationutils.UnusedFunction(attr)

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"BREAKUP_ITEM_ID","attr":"$.message.order.quote.breakup[*]['@ondc/org/item_id']","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "BREAKUP_ITEM_ID",
														Valid:    false,
														Code:     30000,
														Description: `#### **BREAKUP_ITEM_ID**

- $.message.order.quote.breakup[*]['@ondc/org/item_id'] must be present in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "BREAKUP_ITEM_ID",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var BREAKUP_ITEM_QUANTITY_COUNT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_QUANTITY_COUNT")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.breakup[*]['@ondc/org/item_quantity'].count", true)
												validationutils.UnusedFunction(attr)

												skipCheck := !(validationutils.ArePresent(attr))
												if skipCheck {
													continue
												}

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"BREAKUP_ITEM_QUANTITY_COUNT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.quote.breakup[*]['@ondc/org/item_quantity'].count","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "BREAKUP_ITEM_QUANTITY_COUNT",
														Valid:    false,
														Code:     30000,
														Description: `#### **BREAKUP_ITEM_QUANTITY_COUNT**

- $.message.order.quote.breakup[*]['@ondc/org/item_quantity'].count must be present in the payload

> **Skip if:**
>
>     - $.message.order.quote.breakup[*]['@ondc/org/item_quantity'].count is not in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "BREAKUP_ITEM_QUANTITY_COUNT",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var BREAKUP_ITEM_TITLE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_TITLE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.breakup[*].title", true)
												validationutils.UnusedFunction(attr)

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"BREAKUP_ITEM_TITLE","attr":"$.message.order.quote.breakup[*].title","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "BREAKUP_ITEM_TITLE",
														Valid:    false,
														Code:     30000,
														Description: `#### **BREAKUP_ITEM_TITLE**

- $.message.order.quote.breakup[*].title must be present in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "BREAKUP_ITEM_TITLE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var BREAKUP_ITEM_TITLE_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_TITLE_TYPE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.breakup[*]['@ondc/org/title_type']", true)
												validationutils.UnusedFunction(attr)
												var_enum := validationutils.StringSliceToInterface([]string{`item`, `delivery`, `packing`, `tax`, `misc`, `discount`, `offer`})
												validationutils.UnusedFunction(var_enum)

												validate := validationutils.AllIn(attr, var_enum)

												configureDebugInfo = `{"_NAME_":"BREAKUP_ITEM_TITLE_TYPE","attr":"$.message.order.quote.breakup[*]['@ondc/org/title_type']","var_enum":["item","delivery","packing","tax","misc","discount","offer"],"_RETURN_":"attr all in var_enum"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "BREAKUP_ITEM_TITLE_TYPE",
														Valid:    false,
														Code:     30000,
														Description: `#### **BREAKUP_ITEM_TITLE_TYPE**

- All elements of $.message.order.quote.breakup[*]['@ondc/org/title_type'] must be in ["item", "delivery", "packing", "tax", "misc", "discount", "offer"]`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "BREAKUP_ITEM_TITLE_TYPE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var BREAKUP_ITEM_PRICE_CURRENCY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_PRICE_CURRENCY")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.breakup[*].price.currency", true)
												validationutils.UnusedFunction(attr)

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"BREAKUP_ITEM_PRICE_CURRENCY","attr":"$.message.order.quote.breakup[*].price.currency","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "BREAKUP_ITEM_PRICE_CURRENCY",
														Valid:    false,
														Code:     30000,
														Description: `#### **BREAKUP_ITEM_PRICE_CURRENCY**

- $.message.order.quote.breakup[*].price.currency must be present in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "BREAKUP_ITEM_PRICE_CURRENCY",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var BREAKUP_ITEM_PRICE_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_PRICE_VALUE")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.breakup[*].price.value", true)
												validationutils.UnusedFunction(attr)

												validate := validationutils.ArePresent(attr)

												configureDebugInfo = `{"_NAME_":"BREAKUP_ITEM_PRICE_VALUE","attr":"$.message.order.quote.breakup[*].price.value","_RETURN_":"attr are present"}`

												if !validate {
													result := validationutils.ValidationOutput{
														TestName: "BREAKUP_ITEM_PRICE_VALUE",
														Valid:    false,
														Code:     30000,
														Description: `#### **BREAKUP_ITEM_PRICE_VALUE**

- $.message.order.quote.breakup[*].price.value must be present in the payload`,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}
													delete(testObjMap, "_EXTERNAL")
													return []validationutils.ValidationOutput{result}, nil
												}

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "BREAKUP_ITEM_PRICE_VALUE",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}
										var BREAKUP_ITEM_ITEM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
											scope := validationutils.GetJsonPath(input.Payload, "$", true)

											subResults := make([]validationutils.ValidationOutput, 0)
											valid := true
											configureDebugInfo := ""
											for _, testObj := range scope {
												testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
												if !ok {
													return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_ITEM")
												}

												testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

												var BREAKUP_ITEM_ITEM_PRICE_CURRENCY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_ITEM_PRICE_CURRENCY")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.breakup[*].item.price.currency", true)
														validationutils.UnusedFunction(attr)

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"BREAKUP_ITEM_ITEM_PRICE_CURRENCY","attr":"$.message.order.quote.breakup[*].item.price.currency","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "BREAKUP_ITEM_ITEM_PRICE_CURRENCY",
																Valid:    false,
																Code:     30000,
																Description: `#### **BREAKUP_ITEM_ITEM_PRICE_CURRENCY**

- $.message.order.quote.breakup[*].item.price.currency must be present in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "BREAKUP_ITEM_ITEM_PRICE_CURRENCY",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var BREAKUP_ITEM_ITEM_PRICE_VALUE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_ITEM_PRICE_VALUE")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.breakup[*].item.price.value", true)
														validationutils.UnusedFunction(attr)

														validate := validationutils.ArePresent(attr)

														configureDebugInfo = `{"_NAME_":"BREAKUP_ITEM_ITEM_PRICE_VALUE","attr":"$.message.order.quote.breakup[*].item.price.value","_RETURN_":"attr are present"}`

														if !validate {
															result := validationutils.ValidationOutput{
																TestName: "BREAKUP_ITEM_ITEM_PRICE_VALUE",
																Valid:    false,
																Code:     30000,
																Description: `#### **BREAKUP_ITEM_ITEM_PRICE_VALUE**

- $.message.order.quote.breakup[*].item.price.value must be present in the payload`,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}
															delete(testObjMap, "_EXTERNAL")
															return []validationutils.ValidationOutput{result}, nil
														}

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "BREAKUP_ITEM_ITEM_PRICE_VALUE",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}
												var BREAKUP_ITEM_ITEM_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
													scope := validationutils.GetJsonPath(input.Payload, "$", true)

													subResults := make([]validationutils.ValidationOutput, 0)
													valid := true
													configureDebugInfo := ""
													for _, testObj := range scope {
														testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
														if !ok {
															return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_ITEM_TAGS")
														}

														testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

														var BREAKUP_ITEM_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
															scope := validationutils.GetJsonPath(input.Payload, "$", true)

															subResults := make([]validationutils.ValidationOutput, 0)
															valid := true
															configureDebugInfo := ""
															for _, testObj := range scope {
																testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
																if !ok {
																	return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_VALID_TAGS")
																}

																testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

																attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.breakup[*].item.tags[*].code", true)
																validationutils.UnusedFunction(attr)
																valid := validationutils.StringSliceToInterface([]string{`quote`, `np_fees`, `offer`})
																validationutils.UnusedFunction(valid)

																skipCheck := !(validationutils.ArePresent(attr))
																if skipCheck {
																	continue
																}

																validate := validationutils.AllIn(attr, valid)

																configureDebugInfo = `{"_NAME_":"BREAKUP_ITEM_VALID_TAGS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.quote.breakup[*].item.tags[*].code","valid":["quote","np_fees","offer"],"_RETURN_":"attr all in valid"}`

																if !validate {
																	result := validationutils.ValidationOutput{
																		TestName: "BREAKUP_ITEM_VALID_TAGS",
																		Valid:    false,
																		Code:     30000,
																		Description: `#### **BREAKUP_ITEM_VALID_TAGS**

- All elements of $.message.order.quote.breakup[*].item.tags[*].code must be in ["quote", "np_fees", "offer"]

> **Skip if:**
>
>     - $.message.order.quote.breakup[*].item.tags[*].code is not in the payload`,
																		DebugInfo: &validationutils.DebugInfo{
																			FedConfig: configureDebugInfo,
																		},
																	}
																	delete(testObjMap, "_EXTERNAL")
																	return []validationutils.ValidationOutput{result}, nil
																}

																delete(testObjMap, "_EXTERNAL")
															}

															result := validationutils.ValidationOutput{
																TestName: "BREAKUP_ITEM_VALID_TAGS",
																Valid:    valid,
																Code:     0,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}

															if valid {
																result.Code = 200
															} else {
																result.Code = 30000
															}

															results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
															results = append(results, result)
															results = append(results, subResults...)

															return results, nil
														}
														var BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
															scope := validationutils.GetJsonPath(input.Payload, "$", true)

															subResults := make([]validationutils.ValidationOutput, 0)
															valid := true
															configureDebugInfo := ""
															for _, testObj := range scope {
																testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
																if !ok {
																	return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE")
																}

																testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

																var BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
																	scope := validationutils.GetJsonPath(input.Payload, "$", true)

																	subResults := make([]validationutils.ValidationOutput, 0)
																	valid := true
																	configureDebugInfo := ""
																	for _, testObj := range scope {
																		testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
																		if !ok {
																			return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_TYPE")
																		}

																		testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

																		attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.breakup[*].item.tags[?(@.code=='quote')].list[?(@.code=='type')].value", true)
																		validationutils.UnusedFunction(attr)
																		var_enum := validationutils.StringSliceToInterface([]string{`fulfillment`, `order`, `item`})
																		validationutils.UnusedFunction(var_enum)

																		skipCheck := !(validationutils.ArePresent(attr))
																		if skipCheck {
																			continue
																		}

																		validate := validationutils.AllIn(attr, var_enum)

																		configureDebugInfo = `{"_NAME_":"BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_TYPE","attr":"$.message.order.quote.breakup[*].item.tags[?(@.code=='quote')].list[?(@.code=='type')].value","var_enum":["fulfillment","order","item"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum"}`

																		if !validate {
																			result := validationutils.ValidationOutput{
																				TestName: "BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_TYPE",
																				Valid:    false,
																				Code:     30000,
																				Description: `#### **BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_TYPE**

- All elements of $.message.order.quote.breakup[*].item.tags[?(@.code=='quote')].list[?(@.code=='type')].value must be in ["fulfillment", "order", "item"]

> **Skip if:**
>
>     - $.message.order.quote.breakup[*].item.tags[?(@.code=='quote')].list[?(@.code=='type')].value is not in the payload`,
																				DebugInfo: &validationutils.DebugInfo{
																					FedConfig: configureDebugInfo,
																				},
																			}
																			delete(testObjMap, "_EXTERNAL")
																			return []validationutils.ValidationOutput{result}, nil
																		}

																		delete(testObjMap, "_EXTERNAL")
																	}

																	result := validationutils.ValidationOutput{
																		TestName: "BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_TYPE",
																		Valid:    valid,
																		Code:     0,
																		DebugInfo: &validationutils.DebugInfo{
																			FedConfig: configureDebugInfo,
																		},
																	}

																	if valid {
																		result.Code = 200
																	} else {
																		result.Code = 30000
																	}

																	results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
																	results = append(results, result)
																	results = append(results, subResults...)

																	return results, nil
																}
																var BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_SUBTYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
																	scope := validationutils.GetJsonPath(input.Payload, "$", true)

																	subResults := make([]validationutils.ValidationOutput, 0)
																	valid := true
																	configureDebugInfo := ""
																	for _, testObj := range scope {
																		testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
																		if !ok {
																			return nil, fmt.Errorf("Invalid object structure in scope for test BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_SUBTYPE")
																		}

																		testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

																		attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.breakup[*].item.tags[?(@.code=='quote')].list[?(@.code=='subtype')].value", true)
																		validationutils.UnusedFunction(attr)
																		var_enum := validationutils.StringSliceToInterface([]string{`delivery`, `packaging`, `misc`})
																		validationutils.UnusedFunction(var_enum)

																		skipCheck := !(validationutils.ArePresent(attr))
																		if skipCheck {
																			continue
																		}

																		validate := validationutils.AllIn(attr, var_enum)

																		configureDebugInfo = `{"_NAME_":"BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_SUBTYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.quote.breakup[*].item.tags[?(@.code=='quote')].list[?(@.code=='subtype')].value","var_enum":["delivery","packaging","misc"],"_RETURN_":"attr all in var_enum"}`

																		if !validate {
																			result := validationutils.ValidationOutput{
																				TestName: "BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_SUBTYPE",
																				Valid:    false,
																				Code:     30000,
																				Description: `#### **BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_SUBTYPE**

- All elements of $.message.order.quote.breakup[*].item.tags[?(@.code=='quote')].list[?(@.code=='subtype')].value must be in ["delivery", "packaging", "misc"]

> **Skip if:**
>
>     - $.message.order.quote.breakup[*].item.tags[?(@.code=='quote')].list[?(@.code=='subtype')].value is not in the payload`,
																				DebugInfo: &validationutils.DebugInfo{
																					FedConfig: configureDebugInfo,
																				},
																			}
																			delete(testObjMap, "_EXTERNAL")
																			return []validationutils.ValidationOutput{result}, nil
																		}

																		delete(testObjMap, "_EXTERNAL")
																	}

																	result := validationutils.ValidationOutput{
																		TestName: "BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_SUBTYPE",
																		Valid:    valid,
																		Code:     0,
																		DebugInfo: &validationutils.DebugInfo{
																			FedConfig: configureDebugInfo,
																		},
																	}

																	if valid {
																		result.Code = 200
																	} else {
																		result.Code = 30000
																	}

																	results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
																	results = append(results, result)
																	results = append(results, subResults...)

																	return results, nil
																}

																var testFunctions = validationutils.TestFunctionArray{
																	BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_TYPE,
																	BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE_SUBTYPE,
																}

																allResults := make([]validationutils.ValidationOutput, 0)

																for _, testFunc := range testFunctions {
																	results, err := testFunc(input)
																	if err != nil {
																		return nil, err
																	}
																	allResults = append(allResults, results...)
																}

																subResults = allResults
																// if all subResults are valid, then valid is true
																valid = true
																for _, res := range subResults {
																	if !res.Valid {
																		valid = false
																		break
																	}
																}

																configureDebugInfo = `NESTED_TEST_OBJECT`

																delete(testObjMap, "_EXTERNAL")
															}

															result := validationutils.ValidationOutput{
																TestName: "BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE",
																Valid:    valid,
																Code:     0,
																DebugInfo: &validationutils.DebugInfo{
																	FedConfig: configureDebugInfo,
																},
															}

															if valid {
																result.Code = 200
															} else {
																result.Code = 30000
															}

															results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
															results = append(results, result)
															results = append(results, subResults...)

															return results, nil
														}

														var testFunctions = validationutils.TestFunctionArray{
															BREAKUP_ITEM_VALID_TAGS,
															BREAKUP_ITEM_ITEM_TAGS_TAGS_QUOTE,
														}

														allResults := make([]validationutils.ValidationOutput, 0)

														for _, testFunc := range testFunctions {
															results, err := testFunc(input)
															if err != nil {
																return nil, err
															}
															allResults = append(allResults, results...)
														}

														subResults = allResults
														// if all subResults are valid, then valid is true
														valid = true
														for _, res := range subResults {
															if !res.Valid {
																valid = false
																break
															}
														}

														configureDebugInfo = `NESTED_TEST_OBJECT`

														delete(testObjMap, "_EXTERNAL")
													}

													result := validationutils.ValidationOutput{
														TestName: "BREAKUP_ITEM_ITEM_TAGS",
														Valid:    valid,
														Code:     0,
														DebugInfo: &validationutils.DebugInfo{
															FedConfig: configureDebugInfo,
														},
													}

													if valid {
														result.Code = 200
													} else {
														result.Code = 30000
													}

													results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
													results = append(results, result)
													results = append(results, subResults...)

													return results, nil
												}

												var testFunctions = validationutils.TestFunctionArray{
													BREAKUP_ITEM_ITEM_PRICE_CURRENCY,
													BREAKUP_ITEM_ITEM_PRICE_VALUE,
													BREAKUP_ITEM_ITEM_TAGS,
												}

												allResults := make([]validationutils.ValidationOutput, 0)

												for _, testFunc := range testFunctions {
													results, err := testFunc(input)
													if err != nil {
														return nil, err
													}
													allResults = append(allResults, results...)
												}

												subResults = allResults
												// if all subResults are valid, then valid is true
												valid = true
												for _, res := range subResults {
													if !res.Valid {
														valid = false
														break
													}
												}

												configureDebugInfo = `NESTED_TEST_OBJECT`

												delete(testObjMap, "_EXTERNAL")
											}

											result := validationutils.ValidationOutput{
												TestName: "BREAKUP_ITEM_ITEM",
												Valid:    valid,
												Code:     0,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}

											if valid {
												result.Code = 200
											} else {
												result.Code = 30000
											}

											results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
											results = append(results, result)
											results = append(results, subResults...)

											return results, nil
										}

										var testFunctions = validationutils.TestFunctionArray{
											BREAKUP_ITEM_ID,
											BREAKUP_ITEM_QUANTITY_COUNT,
											BREAKUP_ITEM_TITLE,
											BREAKUP_ITEM_TITLE_TYPE,
											BREAKUP_ITEM_PRICE_CURRENCY,
											BREAKUP_ITEM_PRICE_VALUE,
											BREAKUP_ITEM_ITEM,
										}

										allResults := make([]validationutils.ValidationOutput, 0)

										for _, testFunc := range testFunctions {
											results, err := testFunc(input)
											if err != nil {
												return nil, err
											}
											allResults = append(allResults, results...)
										}

										subResults = allResults
										// if all subResults are valid, then valid is true
										valid = true
										for _, res := range subResults {
											if !res.Valid {
												valid = false
												break
											}
										}

										configureDebugInfo = `NESTED_TEST_OBJECT`

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "BREAKUP_ITEM",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									BREAKUP_ITEM,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "QUOTE_BREAKUP",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							QUOTE_PRICE_CURRENCY,
							QUOTE_PRICE_VALUE,
							QUOTE_TTL,
							QUOTE_BREAKUP,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_QUOTE",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_QUOTE_ADDITIONAL_PROPERTIES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_QUOTE_ADDITIONAL_PROPERTIES")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var QUOTE_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test QUOTE_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.quote.ttl", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"QUOTE_TTL","attr":"$.message.order.quote.ttl","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "QUOTE_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **QUOTE_TTL**

- $.message.order.quote.ttl must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "QUOTE_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							QUOTE_TTL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_QUOTE_ADDITIONAL_PROPERTIES",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_PAYMENT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_PAYMENT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_TYPE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/buyer_app_finder_fee_type']", true)
								validationutils.UnusedFunction(attr)
								var_enum := validationutils.StringSliceToInterface([]string{`percent`, `amount`})
								validationutils.UnusedFunction(var_enum)

								validate := validationutils.AllIn(attr, var_enum)

								configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_TYPE","attr":"$.message.order.payment['@ondc/org/buyer_app_finder_fee_type']","var_enum":["percent","amount"],"_RETURN_":"attr all in var_enum"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_TYPE",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_TYPE**

- All elements of $.message.order.payment['@ondc/org/buyer_app_finder_fee_type'] must be in ["percent", "amount"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_TYPE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_AMOUNT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_AMOUNT")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/buyer_app_finder_fee_amount']", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^(\d*.?\d{1,2})$`})
								validationutils.UnusedFunction(reg)

								validate := (validationutils.ArePresent(attr)) && (validationutils.FollowRegex(attr, reg))

								configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_AMOUNT","attr":"$.message.order.payment['@ondc/org/buyer_app_finder_fee_amount']","reg":["^(\\\\d*.?\\\\d{1,2})$"],"_RETURN_":"attr are present && attr follow regex reg"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_AMOUNT",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_AMOUNT**

**All of the following must be true:**
  - $.message.order.payment['@ondc/org/buyer_app_finder_fee_amount'] must be present in the payload
  - All elements of $.message.order.payment['@ondc/org/buyer_app_finder_fee_amount'] must follow every regex in ["^(\\d*.?\\d{1,2})$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_AMOUNT",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_details'][*].settlement_counterparty", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY","attr":"$.message.order.payment['@ondc/org/settlement_details'][*].settlement_counterparty","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY**

- $.message.order.payment['@ondc/org/settlement_details'][*].settlement_counterparty must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_details'][*].settlement_counterparty is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_details'][*].settlement_phase", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE","attr":"$.message.order.payment['@ondc/org/settlement_details'][*].settlement_phase","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE**

- $.message.order.payment['@ondc/org/settlement_details'][*].settlement_phase must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_details'][*].settlement_phase is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_details'][*].settlement_type", true)
										validationutils.UnusedFunction(attr)
										var_enum := validationutils.StringSliceToInterface([]string{`upi`, `neft`, `rtgs`})
										validationutils.UnusedFunction(var_enum)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.AllIn(attr, var_enum)

										configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE","attr":"$.message.order.payment['@ondc/org/settlement_details'][*].settlement_type","_CONTINUE_":"!(attr are present)","var_enum":["upi","neft","rtgs"],"_RETURN_":"attr all in var_enum"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE**

- All elements of $.message.order.payment['@ondc/org/settlement_details'][*].settlement_type must be in ["upi", "neft", "rtgs"]

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_details'][*].settlement_type is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_COUNTERPARTY,
									PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_PHASE,
									PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_TYPE,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_TYPE,
							PAYMENT_ONDC_ORG_BUYER_APP_FINDER_FEE_AMOUNT,
							PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_PAYMENT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_PAYMENT_ADDITIONAL_PROPERTIES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_PAYMENT_ADDITIONAL_PROPERTIES")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var PAYMENT_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment.uri", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"PAYMENT_URI","attr":"$.message.order.payment.uri","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_URI**

- $.message.order.payment.uri must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment.uri is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_TL_METHOD = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_TL_METHOD")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment.tl_method", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"PAYMENT_TL_METHOD","attr":"$.message.order.payment.tl_method","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_TL_METHOD",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_TL_METHOD**

- $.message.order.payment.tl_method must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment.tl_method is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_TL_METHOD",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_PARAMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_PARAMS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var PAYMENT_CURRENCY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_CURRENCY")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment.params.currency", true)
										validationutils.UnusedFunction(attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PAYMENT_CURRENCY","attr":"$.message.order.payment.params.currency","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_CURRENCY",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_CURRENCY**

- $.message.order.payment.params.currency must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_CURRENCY",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PAYMENT_TRANSACTION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_TRANSACTION_ID")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment.params.transaction_id", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PAYMENT_TRANSACTION_ID","attr":"$.message.order.payment.params.transaction_id","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_TRANSACTION_ID",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_TRANSACTION_ID**

- $.message.order.payment.params.transaction_id must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment.params.transaction_id is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_TRANSACTION_ID",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PAYMENT_AMOUNT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_AMOUNT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment.params.amount", true)
										validationutils.UnusedFunction(attr)

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PAYMENT_AMOUNT","attr":"$.message.order.payment.params.amount","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_AMOUNT",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_AMOUNT**

- $.message.order.payment.params.amount must be present in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_AMOUNT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									PAYMENT_CURRENCY,
									PAYMENT_TRANSACTION_ID,
									PAYMENT_AMOUNT,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_PARAMS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_STATUS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_STATUS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var_enum := validationutils.StringSliceToInterface([]string{`NOT-PAID`, `PAID`})
								validationutils.UnusedFunction(var_enum)
								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment.status", true)
								validationutils.UnusedFunction(attr)

								validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, var_enum))

								configureDebugInfo = `{"_NAME_":"PAYMENT_STATUS","var_enum":["NOT-PAID","PAID"],"attr":"$.message.order.payment.status","_RETURN_":"attr are present && attr all in var_enum"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_STATUS",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_STATUS**

**All of the following must be true:**
  - $.message.order.payment.status must be present in the payload
  - All elements of $.message.order.payment.status must be in ["NOT-PAID", "PAID"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_STATUS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_TYPE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment.type", true)
								validationutils.UnusedFunction(attr)
								var_enum := validationutils.StringSliceToInterface([]string{`ON-ORDER`, `ON-FULFILLMENT`})
								validationutils.UnusedFunction(var_enum)

								validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, var_enum))

								configureDebugInfo = `{"_NAME_":"PAYMENT_TYPE","attr":"$.message.order.payment.type","var_enum":["ON-ORDER","ON-FULFILLMENT"],"_RETURN_":"attr are present && attr all in var_enum"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_TYPE",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_TYPE**

**All of the following must be true:**
  - $.message.order.payment.type must be present in the payload
  - All elements of $.message.order.payment.type must be in ["ON-ORDER", "ON-FULFILLMENT"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_TYPE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_COLLECTED_BY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_COLLECTED_BY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var_enum := validationutils.StringSliceToInterface([]string{`BAP`, `BPP`})
								validationutils.UnusedFunction(var_enum)
								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment.collected_by", true)
								validationutils.UnusedFunction(attr)

								validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, var_enum))

								configureDebugInfo = `{"_NAME_":"PAYMENT_COLLECTED_BY","var_enum":["BAP","BPP"],"attr":"$.message.order.payment.collected_by","_RETURN_":"attr are present && attr all in var_enum"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_COLLECTED_BY",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_COLLECTED_BY**

**All of the following must be true:**
  - $.message.order.payment.collected_by must be present in the payload
  - All elements of $.message.order.payment.collected_by must be in ["BAP", "BPP"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_COLLECTED_BY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_ONDC_ORG_SETTLEMENT_WINDOW = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_WINDOW")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_window']", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_WINDOW","_CONTINUE_":"!(attr are present)","attr":"$.message.order.payment['@ondc/org/settlement_window']","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_WINDOW",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_WINDOW**

- $.message.order.payment['@ondc/org/settlement_window'] must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_window'] is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_WINDOW",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_ONDC_ORG_WITHHOLDING_AMOUNT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_WITHHOLDING_AMOUNT")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/withholding_amount']", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_WITHHOLDING_AMOUNT","_CONTINUE_":"!(attr are present)","attr":"$.message.order.payment['@ondc/org/withholding_amount']","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_WITHHOLDING_AMOUNT",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_ONDC_ORG_WITHHOLDING_AMOUNT**

- $.message.order.payment['@ondc/org/withholding_amount'] must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/withholding_amount'] is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_ONDC_ORG_WITHHOLDING_AMOUNT",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_ONDC_ORG_SETTLEMENT_BASIS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_BASIS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var_enum := validationutils.StringSliceToInterface([]string{`shipment`, `delivery`, `return_Window_expiry`})
								validationutils.UnusedFunction(var_enum)
								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_basis']", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := (validationutils.ArePresent(attr)) && (validationutils.AllIn(attr, var_enum))

								configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_BASIS","var_enum":["shipment","delivery","return_Window_expiry"],"_CONTINUE_":"!(attr are present)","attr":"$.message.order.payment['@ondc/org/settlement_basis']","_RETURN_":"attr are present && attr all in var_enum"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_BASIS",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_BASIS**

**All of the following must be true:**
  - $.message.order.payment['@ondc/org/settlement_basis'] must be present in the payload
  - All elements of $.message.order.payment['@ondc/org/settlement_basis'] must be in ["shipment", "delivery", "return_Window_expiry"]

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_basis'] is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_BASIS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_ADDITIONAL_PROPERTIES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_ADDITIONAL_PROPERTIES")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_REFERENCE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_REFERENCE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_details'][*].settlement_reference", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_REFERENCE","_CONTINUE_":"!(attr are present)","attr":"$.message.order.payment['@ondc/org/settlement_details'][*].settlement_reference","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_REFERENCE",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_REFERENCE**

- $.message.order.payment['@ondc/org/settlement_details'][*].settlement_reference must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_details'][*].settlement_reference is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_REFERENCE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_STATUS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_STATUS")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.order.payment['@ondc/org/settlement_details'][*].settlement_status", true)
										validationutils.UnusedFunction(attr)

										skipCheck := !(validationutils.ArePresent(attr))
										if skipCheck {
											continue
										}

										validate := validationutils.ArePresent(attr)

										configureDebugInfo = `{"_NAME_":"PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_STATUS","_CONTINUE_":"!(attr are present)","attr":"$.message.order.payment['@ondc/org/settlement_details'][*].settlement_status","_RETURN_":"attr are present"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_STATUS",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_STATUS**

- $.message.order.payment['@ondc/org/settlement_details'][*].settlement_status must be present in the payload

> **Skip if:**
>
>     - $.message.order.payment['@ondc/org/settlement_details'][*].settlement_status is not in the payload`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_STATUS",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_REFERENCE,
									PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_SETTLEMENT_STATUS,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_ADDITIONAL_PROPERTIES",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							PAYMENT_URI,
							PAYMENT_TL_METHOD,
							PAYMENT_PARAMS,
							PAYMENT_STATUS,
							PAYMENT_TYPE,
							PAYMENT_COLLECTED_BY,
							PAYMENT_ONDC_ORG_SETTLEMENT_WINDOW,
							PAYMENT_ONDC_ORG_WITHHOLDING_AMOUNT,
							PAYMENT_ONDC_ORG_SETTLEMENT_BASIS,
							PAYMENT_ONDC_ORG_SETTLEMENT_DETAILS_ADDITIONAL_PROPERTIES,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_PAYMENT_ADDITIONAL_PROPERTIES",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_DOCUMENTS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_DOCUMENTS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var DOCUMENTS_URL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test DOCUMENTS_URL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.documents[*].url", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"DOCUMENTS_URL","_CONTINUE_":"!(attr are present)","attr":"$.message.order.documents[*].url","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "DOCUMENTS_URL",
										Valid:    false,
										Code:     30000,
										Description: `#### **DOCUMENTS_URL**

- $.message.order.documents[*].url must be present in the payload

> **Skip if:**
>
>     - $.message.order.documents[*].url is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "DOCUMENTS_URL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var DOCUMENTS_LABEL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test DOCUMENTS_LABEL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.order.documents[*].label", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"DOCUMENTS_LABEL","_CONTINUE_":"!(attr are present)","attr":"$.message.order.documents[*].label","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "DOCUMENTS_LABEL",
										Valid:    false,
										Code:     30000,
										Description: `#### **DOCUMENTS_LABEL**

- $.message.order.documents[*].label must be present in the payload

> **Skip if:**
>
>     - $.message.order.documents[*].label is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "DOCUMENTS_LABEL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							DOCUMENTS_URL,
							DOCUMENTS_LABEL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_DOCUMENTS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_CREATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_CREATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.order.created_at", true)
						validationutils.UnusedFunction(attr)
						pattern := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$`})
						validationutils.UnusedFunction(pattern)

						validate := (validationutils.ArePresent(attr)) && (validationutils.FollowRegex(attr, pattern))

						configureDebugInfo = `{"_NAME_":"ORDER_CREATED_AT","attr":"$.message.order.created_at","pattern":["^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}Z$"],"_RETURN_":"attr are present && attr follow regex pattern"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "ORDER_CREATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **ORDER_CREATED_AT**

**All of the following must be true:**
  - $.message.order.created_at must be present in the payload
  - All elements of $.message.order.created_at must follow every regex in ["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_CREATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var ORDER_UPDATED_AT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test ORDER_UPDATED_AT")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						attr := validationutils.GetJsonPath(testObjMap, "$.message.order.updated_at", true)
						validationutils.UnusedFunction(attr)
						pattern := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$`})
						validationutils.UnusedFunction(pattern)

						validate := (validationutils.ArePresent(attr)) && (validationutils.FollowRegex(attr, pattern))

						configureDebugInfo = `{"_NAME_":"ORDER_UPDATED_AT","attr":"$.message.order.updated_at","pattern":["^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}Z$"],"_RETURN_":"attr are present && attr follow regex pattern"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "ORDER_UPDATED_AT",
								Valid:    false,
								Code:     30000,
								Description: `#### **ORDER_UPDATED_AT**

**All of the following must be true:**
  - $.message.order.updated_at must be present in the payload
  - All elements of $.message.order.updated_at must follow every regex in ["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$"]`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "ORDER_UPDATED_AT",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					ORDER_ID,
					ORDER_STATE,
					ORDER_PROVIDER,
					ORDER_CANCELLATION,
					ORDER_ITEMS,
					ORDER_BILLING,
					ORDER_FULFILLMENTS,
					ORDER_QUOTE,
					ORDER_QUOTE_ADDITIONAL_PROPERTIES,
					ORDER_PAYMENT,
					ORDER_PAYMENT_ADDITIONAL_PROPERTIES,
					ORDER_DOCUMENTS,
					ORDER_CREATED_AT,
					ORDER_UPDATED_AT,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "ON_STATUS_ORDER",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}

		var testFunctions = validationutils.TestFunctionArray{
			ON_STATUS_CONTEXT,
			ON_STATUS_ORDER,
		}

		allResults := make([]validationutils.ValidationOutput, 0)

		for _, testFunc := range testFunctions {
			results, err := testFunc(input)
			if err != nil {
				return nil, err
			}
			allResults = append(allResults, results...)
		}

		subResults = allResults
		// if all subResults are valid, then valid is true
		valid = true
		for _, res := range subResults {
			if !res.Valid {
				valid = false
				break
			}
		}

		configureDebugInfo = `NESTED_TEST_OBJECT`

		delete(testObjMap, "_EXTERNAL")
	}

	result := validationutils.ValidationOutput{
		TestName: "On_statusValidations",
		Valid:    valid,
		Code:     0,
		DebugInfo: &validationutils.DebugInfo{
			FedConfig: configureDebugInfo,
		},
	}

	if valid {
		result.Code = 200
	} else {
		result.Code = 30000
	}

	results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
	results = append(results, result)
	results = append(results, subResults...)

	return results, nil
}
