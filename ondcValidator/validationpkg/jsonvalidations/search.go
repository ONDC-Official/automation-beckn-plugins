// Code generated by github.com/ONDC-Official/automation-validation-compiler, DO NOT EDIT.

package jsonvalidations

import (
	"fmt"
	"validationpkg/validationutils"
)

func Search_Tests(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	totalResults, err := SearchValidations(input)
	if err != nil {
		return nil, err
	}

	if !input.Config.Debug {
		for i := range totalResults {
			totalResults[i].DebugInfo = nil
		}
	}

	if input.Config.HideParentErrors {
		// Delete results with valid false and no description
		filtered := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid && r.Description == "" {
				continue
			}
			filtered = append(filtered, r)
		}
		totalResults = filtered
	}

	if input.Config.OnlyInvalid {
		res := make([]validationutils.ValidationOutput, 0)
		for _, r := range totalResults {
			if !r.Valid {
				res = append(res, r)
			}
		}

		if len(res) == 0 {
			// Find the overall test result
			var targetSuccess *validationutils.ValidationOutput
			for i := range totalResults {
				if totalResults[i].TestName == "SearchValidations" {
					targetSuccess = &totalResults[i]
					break
				}
			}

			if targetSuccess == nil {
				panic("Critical: Overall test result not found")
			}

			return []validationutils.ValidationOutput{*targetSuccess}, nil
		}

		return res, nil
	}

	return totalResults, nil
}

var SearchValidations = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
	scope := validationutils.GetJsonPath(input.Payload, "$", true)

	subResults := make([]validationutils.ValidationOutput, 0)
	valid := true
	configureDebugInfo := ""
	for _, testObj := range scope {
		testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("Invalid object structure in scope for test SearchValidations")
		}

		testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

		var SEARCH_CONTEXT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test SEARCH_CONTEXT")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				action := validationutils.StringSliceToInterface([]string{`search`})
				validationutils.UnusedFunction(action)

				var CONTEXT_REQUIRED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CONTEXT_REQUIRED_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_DOMAIN")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_DOMAIN","attr":"$.context.domain","_RETURN_":"attr are present","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_DOMAIN",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_DOMAIN**

- $.context.domain must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_DOMAIN",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_ACTION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_ACTION","attr":"$.context.action","_RETURN_":"attr are present","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_ACTION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_ACTION**

- $.context.action must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_ACTION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_COUNTRY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_COUNTRY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.country", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_COUNTRY","attr":"$.context.country","_RETURN_":"attr are present","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_COUNTRY",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_COUNTRY**

- $.context.country must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_COUNTRY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var REQUIRED_CONTEXT_CODE_14 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test REQUIRED_CONTEXT_CODE_14")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.city", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^(std:\d{3,5}|\*)$`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"REQUIRED_CONTEXT_CODE_14","attr":"$.context.city","reg":["^(std:\\\\d{3,5}|\\\\*)$"],"_RETURN_":"attr follow regex reg","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "REQUIRED_CONTEXT_CODE_14",
										Valid:    false,
										Code:     30000,
										Description: `#### **REQUIRED_CONTEXT_CODE_14**

- All elements of $.context.city must follow every regex in ["^(std:\\d{3,5}|\\*)$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "REQUIRED_CONTEXT_CODE_14",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_VERSION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.core_version", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_VERSION","attr":"$.context.core_version","_RETURN_":"attr are present","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_VERSION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_VERSION**

- $.context.core_version must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_VERSION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BAP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BAP_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BAP_ID","attr":"$.context.bap_id","_RETURN_":"attr are present","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BAP_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BAP_ID**

- $.context.bap_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BAP_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BAP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BAP_URI","attr":"$.context.bap_uri","_RETURN_":"attr are present","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BAP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BAP_URI**

- $.context.bap_uri must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BAP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BPP_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BPP_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BPP_ID","search":["search"],"attr":"$.context.bpp_id","_CONTINUE_":"(action equal to search)","_RETURN_":"attr are present","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BPP_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BPP_ID**

- $.context.bpp_id must be present in the payload

> **Skip if:**
>
>     - ["search"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BPP_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_BPP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_BPP_URI","search":["search"],"_CONTINUE_":"(action equal to search)","attr":"$.context.bpp_uri","_RETURN_":"attr are present","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_BPP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_BPP_URI**

- $.context.bpp_uri must be present in the payload

> **Skip if:**
>
>     - ["search"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_BPP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TRANSACTION_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TRANSACTION_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.transaction_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TRANSACTION_ID","attr":"$.context.transaction_id","_RETURN_":"attr are present","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TRANSACTION_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TRANSACTION_ID**

- $.context.transaction_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TRANSACTION_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_MESSAGE_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_MESSAGE_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.message_id", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_MESSAGE_ID","attr":"$.context.message_id","_RETURN_":"attr are present","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_MESSAGE_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_MESSAGE_ID**

- $.context.message_id must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_MESSAGE_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TIMESTAMP = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TIMESTAMP")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.timestamp", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TIMESTAMP","attr":"$.context.timestamp","reg":["^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}Z$"],"_RETURN_":"attr follow regex reg","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TIMESTAMP",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TIMESTAMP**

- All elements of $.context.timestamp must follow every regex in ["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TIMESTAMP",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REQUIRED_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REQUIRED_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
								validationutils.UnusedFunction(attr)
								optional_vars := validationutils.StringSliceToInterface([]string{`on_search`, `on_select`, `on_confirm`, `on_init`, `on_cancel`, `on_track`, `on_update`, `on_status`})
								validationutils.UnusedFunction(optional_vars)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.AllIn(action, optional_vars)
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REQUIRED_TTL","attr":"$.context.ttl","optional_vars":["on_search","on_select","on_confirm","on_init","on_cancel","on_track","on_update","on_status"],"_CONTINUE_":"(action all in optional_vars)","_RETURN_":"attr are present","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REQUIRED_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REQUIRED_TTL**

- $.context.ttl must be present in the payload

> **Skip if:**
>
>     - all elements of ["search"] are in ["on_search", "on_select", "on_confirm", "on_init", "on_cancel", "on_track", "on_update", "on_status"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REQUIRED_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CONTEXT_REQUIRED_DOMAIN,
							CONTEXT_REQUIRED_ACTION,
							CONTEXT_REQUIRED_COUNTRY,
							REQUIRED_CONTEXT_CODE_14,
							CONTEXT_REQUIRED_VERSION,
							CONTEXT_REQUIRED_BAP_ID,
							CONTEXT_REQUIRED_BAP_URI,
							CONTEXT_REQUIRED_BPP_ID,
							CONTEXT_REQUIRED_BPP_URI,
							CONTEXT_REQUIRED_TRANSACTION_ID,
							CONTEXT_REQUIRED_MESSAGE_ID,
							CONTEXT_REQUIRED_TIMESTAMP,
							CONTEXT_REQUIRED_TTL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CONTEXT_REQUIRED",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var CONTEXT_ENUM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CONTEXT_ENUM_DOMAIN = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_DOMAIN")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								domain := validationutils.StringSliceToInterface([]string{`ONDC:RET10`})
								validationutils.UnusedFunction(domain)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.domain", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.EqualTo(attr, domain)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_DOMAIN","domain":["ONDC:RET10"],"attr":"$.context.domain","_RETURN_":"attr equal to domain","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_DOMAIN",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_DOMAIN**

- $.context.domain must equal ["ONDC:RET10"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_DOMAIN",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_ENUM_ACTION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_ACTION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.action", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.EqualTo(attr, action)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_ACTION","attr":"$.context.action","_RETURN_":"attr equal to action","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_ACTION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_ACTION**

- $.context.action must equal ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_ACTION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_ENUM_VERSION = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_ENUM_VERSION")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								version := validationutils.StringSliceToInterface([]string{`1.2.5`})
								validationutils.UnusedFunction(version)
								attr := validationutils.GetJsonPath(testObjMap, "$.context.core_version", true)
								validationutils.UnusedFunction(attr)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.AllIn(attr, version)

								configureDebugInfo = `{"_NAME_":"CONTEXT_ENUM_VERSION","version":["1.2.5"],"attr":"$.context.core_version","_RETURN_":"attr all in version","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_ENUM_VERSION",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_ENUM_VERSION**

- All elements of $.context.core_version must be in ["1.2.5"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_ENUM_VERSION",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_BAP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_BAP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bap_uri", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^https?\:\/\/`})
								validationutils.UnusedFunction(reg)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_BAP_URI","attr":"$.context.bap_uri","reg":["^https?\\:\\/\\/"],"_RETURN_":"attr follow regex reg","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_BAP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_BAP_URI**

- All elements of $.context.bap_uri must follow every regex in ["^https?\:\/\/"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_BAP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_BPP_URI = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_BPP_URI")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.bpp_uri", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^https?\:\/\/`})
								validationutils.UnusedFunction(reg)
								search := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(search)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.EqualTo(action, search)
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_BPP_URI","attr":"$.context.bpp_uri","reg":["^https?\\:\\/\\/"],"_RETURN_":"attr follow regex reg","search":["search"],"_CONTINUE_":"(action equal to search)","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_BPP_URI",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_BPP_URI**

- All elements of $.context.bpp_uri must follow every regex in ["^https?\:\/\/"]

> **Skip if:**
>
>     - ["search"] equals ["search"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_BPP_URI",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var CONTEXT_REG_TTL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CONTEXT_REG_TTL")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.context.ttl", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^P(?=\d|T)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$`})
								validationutils.UnusedFunction(reg)
								optional_vars := validationutils.StringSliceToInterface([]string{`on_search`, `on_select`, `on_confirm`, `on_init`, `on_cancel`, `on_track`, `on_update`, `on_status`})
								validationutils.UnusedFunction(optional_vars)
								action := validationutils.StringSliceToInterface([]string{`search`})
								validationutils.UnusedFunction(action)

								skipCheck := validationutils.AllIn(action, optional_vars)
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"CONTEXT_REG_TTL","attr":"$.context.ttl","reg":["^P(?=\\\\d|T)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?(\\\\d+S)?)?$"],"optional_vars":["on_search","on_select","on_confirm","on_init","on_cancel","on_track","on_update","on_status"],"_CONTINUE_":"(action all in optional_vars)","_RETURN_":"attr follow regex reg","action":["search"]}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CONTEXT_REG_TTL",
										Valid:    false,
										Code:     30000,
										Description: `#### **CONTEXT_REG_TTL**

- All elements of $.context.ttl must follow every regex in ["^P(?=\\d|T)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$"]

> **Skip if:**
>
>     - all elements of ["search"] are in ["on_search", "on_select", "on_confirm", "on_init", "on_cancel", "on_track", "on_update", "on_status"]`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CONTEXT_REG_TTL",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CONTEXT_ENUM_DOMAIN,
							CONTEXT_ENUM_ACTION,
							CONTEXT_ENUM_VERSION,
							CONTEXT_REG_BAP_URI,
							CONTEXT_REG_BPP_URI,
							CONTEXT_REG_TTL,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "CONTEXT_ENUM",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					CONTEXT_REQUIRED,
					CONTEXT_ENUM,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "SEARCH_CONTEXT",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var SEARCH_PAYMENT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test SEARCH_PAYMENT")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				var PAYMENT_REQUIRED = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_REQUIRED")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var PAYMENT_REQUIRED_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_REQUIRED_TYPE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.payment['@ondc/org/buyer_app_finder_fee_type']", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"PAYMENT_REQUIRED_TYPE","attr":"$.message.intent.payment['@ondc/org/buyer_app_finder_fee_type']","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_REQUIRED_TYPE",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_REQUIRED_TYPE**

- $.message.intent.payment['@ondc/org/buyer_app_finder_fee_type'] must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_REQUIRED_TYPE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_REQUIRED_AMOUNT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_REQUIRED_AMOUNT")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.payment['@ondc/org/buyer_app_finder_fee_amount']", true)
								validationutils.UnusedFunction(attr)

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"PAYMENT_REQUIRED_AMOUNT","attr":"$.message.intent.payment['@ondc/org/buyer_app_finder_fee_amount']","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_REQUIRED_AMOUNT",
										Valid:    false,
										Code:     30000,
										Description: `#### **PAYMENT_REQUIRED_AMOUNT**

- $.message.intent.payment['@ondc/org/buyer_app_finder_fee_amount'] must be present in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_REQUIRED_AMOUNT",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							PAYMENT_REQUIRED_TYPE,
							PAYMENT_REQUIRED_AMOUNT,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "PAYMENT_REQUIRED",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var SEARCH_CATEGORY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test SEARCH_CATEGORY")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var CATEGORY_REQUIRED_ID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test CATEGORY_REQUIRED_ID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.category.id", true)
								validationutils.UnusedFunction(attr)
								valid := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Masala & Seasoning`, `Oil & Ghee`, `Eggs, Meat & Fish`, `Bakery, Cakes & Dairy`, `Pet Care`, `Detergents and Dishwash`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Pasta, Soup and Noodles`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Cooking and Baking Needs`, `Tinned and Processed Food`, `Atta, Flours and Sooji`, `Rice and Rice Products`, `Dals and Pulses`, `Salt, Sugar and Jaggery`, `Energy and Soft Drinks`, `Water`, `Tea and Coffee`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Vegetables`, `Frozen Snacks`, `Gift Voucher`})
								validationutils.UnusedFunction(valid)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, valid)

								configureDebugInfo = `{"_NAME_":"CATEGORY_REQUIRED_ID","attr":"$.message.intent.category.id","valid":["Fruits and Vegetables","Masala & Seasoning","Oil & Ghee","Eggs, Meat & Fish","Bakery, Cakes & Dairy","Pet Care","Detergents and Dishwash","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Pasta, Soup and Noodles","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Cooking and Baking Needs","Tinned and Processed Food","Atta, Flours and Sooji","Rice and Rice Products","Dals and Pulses","Salt, Sugar and Jaggery","Energy and Soft Drinks","Water","Tea and Coffee","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Vegetables","Frozen Snacks","Gift Voucher"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in valid"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "CATEGORY_REQUIRED_ID",
										Valid:    false,
										Code:     30000,
										Description: `#### **CATEGORY_REQUIRED_ID**

- All elements of $.message.intent.category.id must be in ["Fruits and Vegetables", "Masala & Seasoning", "Oil & Ghee", "Eggs, Meat & Fish", "Bakery, Cakes & Dairy", "Pet Care", "Detergents and Dishwash", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Pasta, Soup and Noodles", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Cooking and Baking Needs", "Tinned and Processed Food", "Atta, Flours and Sooji", "Rice and Rice Products", "Dals and Pulses", "Salt, Sugar and Jaggery", "Energy and Soft Drinks", "Water", "Tea and Coffee", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Vegetables", "Frozen Snacks", "Gift Voucher"]

> **Skip if:**
>
>     - $.message.intent.category.id is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "CATEGORY_REQUIRED_ID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var PAYMENT_ENUM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ENUM")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								var PAYMENT_ENUM_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_ENUM_TYPE")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.payment['@ondc/org/buyer_app_finder_fee_type']", true)
										validationutils.UnusedFunction(attr)
										var_fee_type := validationutils.StringSliceToInterface([]string{`percent`, `amount`})
										validationutils.UnusedFunction(var_fee_type)

										validate := validationutils.AllIn(attr, var_fee_type)

										configureDebugInfo = `{"_NAME_":"PAYMENT_ENUM_TYPE","attr":"$.message.intent.payment['@ondc/org/buyer_app_finder_fee_type']","var_fee_type":["percent","amount"],"_RETURN_":"attr all in var_fee_type"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_ENUM_TYPE",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_ENUM_TYPE**

- All elements of $.message.intent.payment['@ondc/org/buyer_app_finder_fee_type'] must be in ["percent", "amount"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_ENUM_TYPE",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}
								var PAYMENT_REGEX_AMOUNT = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
									scope := validationutils.GetJsonPath(input.Payload, "$", true)

									subResults := make([]validationutils.ValidationOutput, 0)
									valid := true
									configureDebugInfo := ""
									for _, testObj := range scope {
										testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
										if !ok {
											return nil, fmt.Errorf("Invalid object structure in scope for test PAYMENT_REGEX_AMOUNT")
										}

										testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

										attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.payment['@ondc/org/buyer_app_finder_fee_amount']", true)
										validationutils.UnusedFunction(attr)
										reg := validationutils.StringSliceToInterface([]string{`^(\d*.?\d{1,2})$`})
										validationutils.UnusedFunction(reg)

										validate := validationutils.FollowRegex(attr, reg)

										configureDebugInfo = `{"_NAME_":"PAYMENT_REGEX_AMOUNT","attr":"$.message.intent.payment['@ondc/org/buyer_app_finder_fee_amount']","reg":["^(\\\\d*.?\\\\d{1,2})$"],"_RETURN_":"attr follow regex reg"}`

										if !validate {
											result := validationutils.ValidationOutput{
												TestName: "PAYMENT_REGEX_AMOUNT",
												Valid:    false,
												Code:     30000,
												Description: `#### **PAYMENT_REGEX_AMOUNT**

- All elements of $.message.intent.payment['@ondc/org/buyer_app_finder_fee_amount'] must follow every regex in ["^(\\d*.?\\d{1,2})$"]`,
												DebugInfo: &validationutils.DebugInfo{
													FedConfig: configureDebugInfo,
												},
											}
											delete(testObjMap, "_EXTERNAL")
											return []validationutils.ValidationOutput{result}, nil
										}

										delete(testObjMap, "_EXTERNAL")
									}

									result := validationutils.ValidationOutput{
										TestName: "PAYMENT_REGEX_AMOUNT",
										Valid:    valid,
										Code:     0,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}

									if valid {
										result.Code = 200
									} else {
										result.Code = 30000
									}

									results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
									results = append(results, result)
									results = append(results, subResults...)

									return results, nil
								}

								var testFunctions = validationutils.TestFunctionArray{
									PAYMENT_ENUM_TYPE,
									PAYMENT_REGEX_AMOUNT,
								}

								allResults := make([]validationutils.ValidationOutput, 0)

								for _, testFunc := range testFunctions {
									results, err := testFunc(input)
									if err != nil {
										return nil, err
									}
									allResults = append(allResults, results...)
								}

								subResults = allResults
								// if all subResults are valid, then valid is true
								valid = true
								for _, res := range subResults {
									if !res.Valid {
										valid = false
										break
									}
								}

								configureDebugInfo = `NESTED_TEST_OBJECT`

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "PAYMENT_ENUM",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							CATEGORY_REQUIRED_ID,
							PAYMENT_ENUM,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "SEARCH_CATEGORY",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var FULFILMENT_ENUM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test FULFILMENT_ENUM")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var FULFILMENT_ENUM_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILMENT_ENUM_TYPE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.fulfillment.type", true)
								validationutils.UnusedFunction(attr)
								var_types := validationutils.StringSliceToInterface([]string{`Delivery`, `Self-Pickup`, `Buyer-Delivery`})
								validationutils.UnusedFunction(var_types)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, var_types)

								configureDebugInfo = `{"_NAME_":"FULFILMENT_ENUM_TYPE","attr":"$.message.intent.fulfillment.type","var_types":["Delivery","Self-Pickup","Buyer-Delivery"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_types"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "FULFILMENT_ENUM_TYPE",
										Valid:    false,
										Code:     30000,
										Description: `#### **FULFILMENT_ENUM_TYPE**

- All elements of $.message.intent.fulfillment.type must be in ["Delivery", "Self-Pickup", "Buyer-Delivery"]

> **Skip if:**
>
>     - $.message.intent.fulfillment.type is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILMENT_ENUM_TYPE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILMENT_REQUIRED_END_LOCATION_GPS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILMENT_REQUIRED_END_LOCATION_GPS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.fulfillment.end.location.gps", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^\d{2}\.\d{4,}\s*,\s*\d{2}\.\d{4,}$`})
								validationutils.UnusedFunction(reg)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"FULFILMENT_REQUIRED_END_LOCATION_GPS","attr":"$.message.intent.fulfillment.end.location.gps","reg":["^\\\\d{2}\\\\.\\\\d{4,}\\\\s*,\\\\s*\\\\d{2}\\\\.\\\\d{4,}$"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr follow regex reg"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "FULFILMENT_REQUIRED_END_LOCATION_GPS",
										Valid:    false,
										Code:     30000,
										Description: `#### **FULFILMENT_REQUIRED_END_LOCATION_GPS**

- All elements of $.message.intent.fulfillment.end.location.gps must follow every regex in ["^\\d{2}\\.\\d{4,}\\s*,\\s*\\d{2}\\.\\d{4,}$"]

> **Skip if:**
>
>     - $.message.intent.fulfillment.end.location.gps is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILMENT_REQUIRED_END_LOCATION_GPS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var FULFILMENT_REQUIRED_END_LOCATION_AREA_CODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test FULFILMENT_REQUIRED_END_LOCATION_AREA_CODE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.fulfillment.end.location.address.area_code", true)
								validationutils.UnusedFunction(attr)
								reg := validationutils.StringSliceToInterface([]string{`^\d{6}$`})
								validationutils.UnusedFunction(reg)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, reg)

								configureDebugInfo = `{"_NAME_":"FULFILMENT_REQUIRED_END_LOCATION_AREA_CODE","attr":"$.message.intent.fulfillment.end.location.address.area_code","reg":["^\\d{6}$"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr follow regex reg"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "FULFILMENT_REQUIRED_END_LOCATION_AREA_CODE",
										Valid:    false,
										Code:     30000,
										Description: `#### **FULFILMENT_REQUIRED_END_LOCATION_AREA_CODE**

- All elements of $.message.intent.fulfillment.end.location.address.area_code must follow every regex in ["^\d{6}$"]

> **Skip if:**
>
>     - $.message.intent.fulfillment.end.location.address.area_code is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "FULFILMENT_REQUIRED_END_LOCATION_AREA_CODE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							FULFILMENT_ENUM_TYPE,
							FULFILMENT_REQUIRED_END_LOCATION_GPS,
							FULFILMENT_REQUIRED_END_LOCATION_AREA_CODE,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "FULFILMENT_ENUM",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					PAYMENT_REQUIRED,
					SEARCH_CATEGORY,
					FULFILMENT_ENUM,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "SEARCH_PAYMENT",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}
		var SEARCH_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
			scope := validationutils.GetJsonPath(input.Payload, "$", true)

			subResults := make([]validationutils.ValidationOutput, 0)
			valid := true
			configureDebugInfo := ""
			for _, testObj := range scope {
				testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
				if !ok {
					return nil, fmt.Errorf("Invalid object structure in scope for test SEARCH_TAGS")
				}

				testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

				var SEARCH_TAG_VALID_TAGS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test SEARCH_TAG_VALID_TAGS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						code := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[*].code", true)
						validationutils.UnusedFunction(code)
						var_codes := validationutils.StringSliceToInterface([]string{`catalog_inc`, `bap_terms`, `catalog_full`, `bap_features`, `bap_promos`, `bnp_demand_signal`})
						validationutils.UnusedFunction(var_codes)

						skipCheck := !(validationutils.ArePresent(code))
						if skipCheck {
							continue
						}

						validate := validationutils.AllIn(code, var_codes)

						configureDebugInfo = `{"_NAME_":"SEARCH_TAG_VALID_TAGS","code":"$.message.intent.tags[*].code","_CONTINUE_":"!(code are present)","var_codes":["catalog_inc","bap_terms","catalog_full","bap_features","bap_promos","bnp_demand_signal"],"_RETURN_":"code all in var_codes"}`

						if !validate {
							result := validationutils.ValidationOutput{
								TestName: "SEARCH_TAG_VALID_TAGS",
								Valid:    false,
								Code:     30000,
								Description: `#### **SEARCH_TAG_VALID_TAGS**

- All elements of $.message.intent.tags[*].code must be in ["catalog_inc", "bap_terms", "catalog_full", "bap_features", "bap_promos", "bnp_demand_signal"]

> **Skip if:**
>
>     - $.message.intent.tags[*].code is not in the payload`,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}
							delete(testObjMap, "_EXTERNAL")
							return []validationutils.ValidationOutput{result}, nil
						}

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "SEARCH_TAG_VALID_TAGS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var TAGS_BNP_FEATURES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_FEATURES")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var TAGS_BNP_FEATURES_PAYLOAD_TYPE_VALID = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_FEATURES_PAYLOAD_TYPE_VALID")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bap_features')].list[*].code", true)
								validationutils.UnusedFunction(attr)
								valid := validationutils.StringSliceToInterface([]string{`001`, `002`, `003`, `004`, `005`, `006`, `007`, `008`, `0091`, `0092`, `0093`, `0094`, `0095`, `0096`, `0097`, `0098`, `0099`, `00A`, `00B`, `00C`, `00D`, `00E`, `00F`, `010`, `011`, `012`, `013`, `014`, `015`, `016`, `017`, `018`, `019`, `01A`, `01B`, `01C`, `01D`, `01E`, `01F`, `020`, `021`, `022`, `023`, `024`, `025`})
								validationutils.UnusedFunction(valid)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, valid)

								configureDebugInfo = `{"_NAME_":"TAGS_BNP_FEATURES_PAYLOAD_TYPE_VALID","_CONTINUE_":"!(attr are present)","attr":"$.message.intent.tags[?(@.code=='bap_features')].list[*].code","valid":["001","002","003","004","005","006","007","008","0091","0092","0093","0094","0095","0096","0097","0098","0099","00A","00B","00C","00D","00E","00F","010","011","012","013","014","015","016","017","018","019","01A","01B","01C","01D","01E","01F","020","021","022","023","024","025"],"_RETURN_":"attr all in valid"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BNP_FEATURES_PAYLOAD_TYPE_VALID",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BNP_FEATURES_PAYLOAD_TYPE_VALID**

- All elements of $.message.intent.tags[?(@.code=='bap_features')].list[*].code must be in ["001", "002", "003", "004", "005", "006", "007", "008", "0091", "0092", "0093", "0094", "0095", "0096", "0097", "0098", "0099", "00A", "00B", "00C", "00D", "00E", "00F", "010", "011", "012", "013", "014", "015", "016", "017", "018", "019", "01A", "01B", "01C", "01D", "01E", "01F", "020", "021", "022", "023", "024", "025"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bap_features')].list[*].code is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BNP_FEATURES_PAYLOAD_TYPE_VALID",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_BNP_FEATURES_PAYLOAD_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_FEATURES_PAYLOAD_TYPE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bap_features')].list[*].value", true)
								validationutils.UnusedFunction(attr)
								valid := validationutils.StringSliceToInterface([]string{`yes`})
								validationutils.UnusedFunction(valid)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, valid)

								configureDebugInfo = `{"_NAME_":"TAGS_BNP_FEATURES_PAYLOAD_TYPE","_CONTINUE_":"!(attr are present)","attr":"$.message.intent.tags[?(@.code=='bap_features')].list[*].value","valid":["yes"],"_RETURN_":"attr all in valid"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BNP_FEATURES_PAYLOAD_TYPE",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BNP_FEATURES_PAYLOAD_TYPE**

- All elements of $.message.intent.tags[?(@.code=='bap_features')].list[*].value must be in ["yes"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bap_features')].list[*].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BNP_FEATURES_PAYLOAD_TYPE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							TAGS_BNP_FEATURES_PAYLOAD_TYPE_VALID,
							TAGS_BNP_FEATURES_PAYLOAD_TYPE,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "TAGS_BNP_FEATURES",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var TAGS_BAP_TERMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_TERMS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var TAGS_BAP_TERMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_TERMS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bap_terms')].list[*].code", true)
								validationutils.UnusedFunction(attr)
								valid := validationutils.StringSliceToInterface([]string{`static_terms`, `static_terms_new`, `effective_date`})
								validationutils.UnusedFunction(valid)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, valid)

								configureDebugInfo = `{"_NAME_":"TAGS_BAP_TERMS","_CONTINUE_":"!(attr are present)","attr":"$.message.intent.tags[?(@.code=='bap_terms')].list[*].code","valid":["static_terms","static_terms_new","effective_date"],"_RETURN_":"attr all in valid"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BAP_TERMS",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BAP_TERMS**

- All elements of $.message.intent.tags[?(@.code=='bap_terms')].list[*].code must be in ["static_terms", "static_terms_new", "effective_date"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bap_terms')].list[*].code is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BAP_TERMS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_BAP_TERMS_EFFECTIVE_DATE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_TERMS_EFFECTIVE_DATE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bap_terms')].list[?(@.code=='effective_date')].value", true)
								validationutils.UnusedFunction(attr)
								var_date_regex := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$`})
								validationutils.UnusedFunction(var_date_regex)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, var_date_regex)

								configureDebugInfo = `{"_NAME_":"TAGS_BAP_TERMS_EFFECTIVE_DATE","_CONTINUE_":"!(attr are present)","attr":"$.message.intent.tags[?(@.code=='bap_terms')].list[?(@.code=='effective_date')].value","var_date_regex":["^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{3}Z$"],"_RETURN_":"attr follow regex var_date_regex"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BAP_TERMS_EFFECTIVE_DATE",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BAP_TERMS_EFFECTIVE_DATE**

- All elements of $.message.intent.tags[?(@.code=='bap_terms')].list[?(@.code=='effective_date')].value must follow every regex in ["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bap_terms')].list[?(@.code=='effective_date')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BAP_TERMS_EFFECTIVE_DATE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							TAGS_BAP_TERMS,
							TAGS_BAP_TERMS_EFFECTIVE_DATE,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "TAGS_BAP_TERMS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var TAGS_CATALOG_FULL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_CATALOG_FULL")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var TAGS_CATALOG_FULL_VALID_ENUMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_CATALOG_FULL_VALID_ENUMS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='catalog_full')].list[*].code", true)
								validationutils.UnusedFunction(attr)
								valid := validationutils.StringSliceToInterface([]string{`payload_type`})
								validationutils.UnusedFunction(valid)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, valid)

								configureDebugInfo = `{"_NAME_":"TAGS_CATALOG_FULL_VALID_ENUMS","_CONTINUE_":"!(attr are present)","attr":"$.message.intent.tags[?(@.code=='catalog_full')].list[*].code","valid":["payload_type"],"_RETURN_":"attr all in valid"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_CATALOG_FULL_VALID_ENUMS",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_CATALOG_FULL_VALID_ENUMS**

- All elements of $.message.intent.tags[?(@.code=='catalog_full')].list[*].code must be in ["payload_type"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='catalog_full')].list[*].code is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_CATALOG_FULL_VALID_ENUMS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_CATALOG_FULL_PAYLOAD_TYPE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_CATALOG_FULL_PAYLOAD_TYPE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='catalog_full')].list[?(@.code=='payload_type')].value", true)
								validationutils.UnusedFunction(attr)
								var_enum_payload_type := validationutils.StringSliceToInterface([]string{`link`, `inline`})
								validationutils.UnusedFunction(var_enum_payload_type)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, var_enum_payload_type)

								configureDebugInfo = `{"_NAME_":"TAGS_CATALOG_FULL_PAYLOAD_TYPE","attr":"$.message.intent.tags[?(@.code=='catalog_full')].list[?(@.code=='payload_type')].value","var_enum_payload_type":["link","inline"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum_payload_type"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_CATALOG_FULL_PAYLOAD_TYPE",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_CATALOG_FULL_PAYLOAD_TYPE**

- All elements of $.message.intent.tags[?(@.code=='catalog_full')].list[?(@.code=='payload_type')].value must be in ["link", "inline"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='catalog_full')].list[?(@.code=='payload_type')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_CATALOG_FULL_PAYLOAD_TYPE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							TAGS_CATALOG_FULL_VALID_ENUMS,
							TAGS_CATALOG_FULL_PAYLOAD_TYPE,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "TAGS_CATALOG_FULL",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var TAGS_CATALOG_INC = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_CATALOG_INC")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var TAGS_CATALOG_INC_VALID_ENUMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_CATALOG_INC_VALID_ENUMS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='catalog_inc')].list[*].code", true)
								validationutils.UnusedFunction(attr)
								valid := validationutils.StringSliceToInterface([]string{`start_time`, `end_time`, `mode`})
								validationutils.UnusedFunction(valid)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, valid)

								configureDebugInfo = `{"_NAME_":"TAGS_CATALOG_INC_VALID_ENUMS","_CONTINUE_":"!(attr are present)","attr":"$.message.intent.tags[?(@.code=='catalog_inc')].list[*].code","valid":["start_time","end_time","mode"],"_RETURN_":"attr all in valid"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_CATALOG_INC_VALID_ENUMS",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_CATALOG_INC_VALID_ENUMS**

- All elements of $.message.intent.tags[?(@.code=='catalog_inc')].list[*].code must be in ["start_time", "end_time", "mode"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='catalog_inc')].list[*].code is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_CATALOG_INC_VALID_ENUMS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_CATALOG_INC_START_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_CATALOG_INC_START_TIME")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='start_time')].value", true)
								validationutils.UnusedFunction(attr)
								var_datetime_regex := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}`})
								validationutils.UnusedFunction(var_datetime_regex)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, var_datetime_regex)

								configureDebugInfo = `{"_NAME_":"TAGS_CATALOG_INC_START_TIME","attr":"$.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='start_time')].value","var_datetime_regex":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr follow regex var_datetime_regex"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_CATALOG_INC_START_TIME",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_CATALOG_INC_START_TIME**

- All elements of $.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='start_time')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='start_time')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_CATALOG_INC_START_TIME",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_CATALOG_INC_END_TIME = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_CATALOG_INC_END_TIME")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='end_time')].value", true)
								validationutils.UnusedFunction(attr)
								var_datetime_regex := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}`})
								validationutils.UnusedFunction(var_datetime_regex)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, var_datetime_regex)

								configureDebugInfo = `{"_NAME_":"TAGS_CATALOG_INC_END_TIME","attr":"$.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='end_time')].value","var_datetime_regex":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr follow regex var_datetime_regex"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_CATALOG_INC_END_TIME",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_CATALOG_INC_END_TIME**

- All elements of $.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='end_time')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='end_time')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_CATALOG_INC_END_TIME",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_CATALOG_INC_MODE = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_CATALOG_INC_MODE")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='mode')].value", true)
								validationutils.UnusedFunction(attr)
								var_enum_mode := validationutils.StringSliceToInterface([]string{`start`, `end`, `stop`})
								validationutils.UnusedFunction(var_enum_mode)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, var_enum_mode)

								configureDebugInfo = `{"_NAME_":"TAGS_CATALOG_INC_MODE","attr":"$.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='mode')].value","var_enum_mode":["start","end","stop"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum_mode"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_CATALOG_INC_MODE",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_CATALOG_INC_MODE**

- All elements of $.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='mode')].value must be in ["start", "end", "stop"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='catalog_inc')].list[?(@.code=='mode')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_CATALOG_INC_MODE",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							TAGS_CATALOG_INC_VALID_ENUMS,
							TAGS_CATALOG_INC_START_TIME,
							TAGS_CATALOG_INC_END_TIME,
							TAGS_CATALOG_INC_MODE,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "TAGS_CATALOG_INC",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var TAGS_BAP_FEATURES = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_FEATURES")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var TAGS_BAP_FEATURES_ITEM_1 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_FEATURES_ITEM_1")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='1')].value", true)
								validationutils.UnusedFunction(attr)
								var_enum_bap_features := validationutils.StringSliceToInterface([]string{`yes`, `no`})
								validationutils.UnusedFunction(var_enum_bap_features)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, var_enum_bap_features)

								configureDebugInfo = `{"_NAME_":"TAGS_BAP_FEATURES_ITEM_1","attr":"$.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='1')].value","var_enum_bap_features":["yes","no"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum_bap_features"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BAP_FEATURES_ITEM_1",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BAP_FEATURES_ITEM_1**

- All elements of $.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='1')].value must be in ["yes", "no"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='1')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BAP_FEATURES_ITEM_1",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_BAP_FEATURES_ITEM_2 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_FEATURES_ITEM_2")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='2')].value", true)
								validationutils.UnusedFunction(attr)
								var_enum_bap_features := validationutils.StringSliceToInterface([]string{`yes`, `no`})
								validationutils.UnusedFunction(var_enum_bap_features)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, var_enum_bap_features)

								configureDebugInfo = `{"_NAME_":"TAGS_BAP_FEATURES_ITEM_2","attr":"$.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='2')].value","var_enum_bap_features":["yes","no"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum_bap_features"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BAP_FEATURES_ITEM_2",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BAP_FEATURES_ITEM_2**

- All elements of $.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='2')].value must be in ["yes", "no"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='2')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BAP_FEATURES_ITEM_2",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_BAP_FEATURES_ITEM_3 = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_FEATURES_ITEM_3")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='3')].value", true)
								validationutils.UnusedFunction(attr)
								var_enum_bap_features := validationutils.StringSliceToInterface([]string{`yes`, `no`})
								validationutils.UnusedFunction(var_enum_bap_features)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, var_enum_bap_features)

								configureDebugInfo = `{"_NAME_":"TAGS_BAP_FEATURES_ITEM_3","attr":"$.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='3')].value","var_enum_bap_features":["yes","no"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum_bap_features"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BAP_FEATURES_ITEM_3",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BAP_FEATURES_ITEM_3**

- All elements of $.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='3')].value must be in ["yes", "no"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bap_features')].list[?(@.code=='3')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BAP_FEATURES_ITEM_3",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							TAGS_BAP_FEATURES_ITEM_1,
							TAGS_BAP_FEATURES_ITEM_2,
							TAGS_BAP_FEATURES_ITEM_3,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "TAGS_BAP_FEATURES",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var TAGS_BAP_PROMOS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_PROMOS")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var TAGS_BAP_PROMOS_VALID_ENUMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_PROMOS_VALID_ENUMS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bap_promos')].list[*].code", true)
								validationutils.UnusedFunction(attr)
								valid := validationutils.StringSliceToInterface([]string{`category`, `from`, `to`})
								validationutils.UnusedFunction(valid)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, valid)

								configureDebugInfo = `{"_NAME_":"TAGS_BAP_PROMOS_VALID_ENUMS","_CONTINUE_":"!(attr are present)","attr":"$.message.intent.tags[?(@.code=='bap_promos')].list[*].code","valid":["category","from","to"],"_RETURN_":"attr all in valid"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BAP_PROMOS_VALID_ENUMS",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BAP_PROMOS_VALID_ENUMS**

- All elements of $.message.intent.tags[?(@.code=='bap_promos')].list[*].code must be in ["category", "from", "to"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bap_promos')].list[*].code is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BAP_PROMOS_VALID_ENUMS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_BAP_PROMOS_CATEGORY = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_PROMOS_CATEGORY")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='category')].value", true)
								validationutils.UnusedFunction(attr)
								var_enum_promo_categories := validationutils.StringSliceToInterface([]string{`Fruits and Vegetables`, `Masala & Seasoning`, `Oil & Ghee`, `Eggs, Meat & Fish`, `Bakery, Cakes & Dairy`, `Pet Care`, `Detergents and Dishwash`, `Dairy and Cheese`, `Snacks, Dry Fruits, Nuts`, `Pasta, Soup and Noodles`, `Cereals and Breakfast`, `Sauces, Spreads and Dips`, `Chocolates and Biscuits`, `Cooking and Baking Needs`, `Tinned and Processed Food`, `Atta, Flours and Sooji`, `Rice and Rice Products`, `Dals and Pulses`, `Salt, Sugar and Jaggery`, `Energy and Soft Drinks`, `Water`, `Tea and Coffee`, `Fruit Juices and Fruit Drinks`, `Snacks and Namkeen`, `Ready to Cook and Eat`, `Pickles and Chutney`, `Indian Sweets`, `Frozen Vegetables`, `Frozen Snacks`, `Gift Voucher`})
								validationutils.UnusedFunction(var_enum_promo_categories)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, var_enum_promo_categories)

								configureDebugInfo = `{"_NAME_":"TAGS_BAP_PROMOS_CATEGORY","attr":"$.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='category')].value","var_enum_promo_categories":["Fruits and Vegetables","Masala & Seasoning","Oil & Ghee","Eggs, Meat & Fish","Bakery, Cakes & Dairy","Pet Care","Detergents and Dishwash","Dairy and Cheese","Snacks, Dry Fruits, Nuts","Pasta, Soup and Noodles","Cereals and Breakfast","Sauces, Spreads and Dips","Chocolates and Biscuits","Cooking and Baking Needs","Tinned and Processed Food","Atta, Flours and Sooji","Rice and Rice Products","Dals and Pulses","Salt, Sugar and Jaggery","Energy and Soft Drinks","Water","Tea and Coffee","Fruit Juices and Fruit Drinks","Snacks and Namkeen","Ready to Cook and Eat","Pickles and Chutney","Indian Sweets","Frozen Vegetables","Frozen Snacks","Gift Voucher"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr all in var_enum_promo_categories"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BAP_PROMOS_CATEGORY",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BAP_PROMOS_CATEGORY**

- All elements of $.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='category')].value must be in ["Fruits and Vegetables", "Masala & Seasoning", "Oil & Ghee", "Eggs, Meat & Fish", "Bakery, Cakes & Dairy", "Pet Care", "Detergents and Dishwash", "Dairy and Cheese", "Snacks, Dry Fruits, Nuts", "Pasta, Soup and Noodles", "Cereals and Breakfast", "Sauces, Spreads and Dips", "Chocolates and Biscuits", "Cooking and Baking Needs", "Tinned and Processed Food", "Atta, Flours and Sooji", "Rice and Rice Products", "Dals and Pulses", "Salt, Sugar and Jaggery", "Energy and Soft Drinks", "Water", "Tea and Coffee", "Fruit Juices and Fruit Drinks", "Snacks and Namkeen", "Ready to Cook and Eat", "Pickles and Chutney", "Indian Sweets", "Frozen Vegetables", "Frozen Snacks", "Gift Voucher"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='category')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BAP_PROMOS_CATEGORY",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_BAP_PROMOS_FROM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_PROMOS_FROM")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='from')].value", true)
								validationutils.UnusedFunction(attr)
								var_datetime_regex := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}`})
								validationutils.UnusedFunction(var_datetime_regex)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, var_datetime_regex)

								configureDebugInfo = `{"_NAME_":"TAGS_BAP_PROMOS_FROM","attr":"$.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='from')].value","var_datetime_regex":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr follow regex var_datetime_regex"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BAP_PROMOS_FROM",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BAP_PROMOS_FROM**

- All elements of $.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='from')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='from')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BAP_PROMOS_FROM",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_BAP_PROMOS_TO = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_PROMOS_TO")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='to')].value", true)
								validationutils.UnusedFunction(attr)
								var_datetime_regex := validationutils.StringSliceToInterface([]string{`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}`})
								validationutils.UnusedFunction(var_datetime_regex)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.FollowRegex(attr, var_datetime_regex)

								configureDebugInfo = `{"_NAME_":"TAGS_BAP_PROMOS_TO","attr":"$.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='to')].value","var_datetime_regex":["^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}"],"_CONTINUE_":"!(attr are present)","_RETURN_":"attr follow regex var_datetime_regex"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BAP_PROMOS_TO",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BAP_PROMOS_TO**

- All elements of $.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='to')].value must follow every regex in ["^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bap_promos')].list[?(@.code=='to')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BAP_PROMOS_TO",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							TAGS_BAP_PROMOS_VALID_ENUMS,
							TAGS_BAP_PROMOS_CATEGORY,
							TAGS_BAP_PROMOS_FROM,
							TAGS_BAP_PROMOS_TO,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "TAGS_BAP_PROMOS",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}
				var TAGS_BNP_DEMAND_SIGNAL = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
					scope := validationutils.GetJsonPath(input.Payload, "$", true)

					subResults := make([]validationutils.ValidationOutput, 0)
					valid := true
					configureDebugInfo := ""
					for _, testObj := range scope {
						testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
						if !ok {
							return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_DEMAND_SIGNAL")
						}

						testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

						var TAGS_BAP_PROMOS_VALID_ENUMS = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BAP_PROMOS_VALID_ENUMS")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bnp_demand_signal')].list[*].code", true)
								validationutils.UnusedFunction(attr)
								valid := validationutils.StringSliceToInterface([]string{`search_term`})
								validationutils.UnusedFunction(valid)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.AllIn(attr, valid)

								configureDebugInfo = `{"_NAME_":"TAGS_BAP_PROMOS_VALID_ENUMS","_CONTINUE_":"!(attr are present)","attr":"$.message.intent.tags[?(@.code=='bnp_demand_signal')].list[*].code","valid":["search_term"],"_RETURN_":"attr all in valid"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BAP_PROMOS_VALID_ENUMS",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BAP_PROMOS_VALID_ENUMS**

- All elements of $.message.intent.tags[?(@.code=='bnp_demand_signal')].list[*].code must be in ["search_term"]

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bnp_demand_signal')].list[*].code is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BAP_PROMOS_VALID_ENUMS",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}
						var TAGS_BNP_DEMAND_SIGNAL_SEARCH_TERM = func(input validationutils.ValidationInput) ([]validationutils.ValidationOutput, error) {
							scope := validationutils.GetJsonPath(input.Payload, "$", true)

							subResults := make([]validationutils.ValidationOutput, 0)
							valid := true
							configureDebugInfo := ""
							for _, testObj := range scope {
								testObjMap, ok := validationutils.DeepCloneJSON(testObj).(map[string]interface{})
								if !ok {
									return nil, fmt.Errorf("Invalid object structure in scope for test TAGS_BNP_DEMAND_SIGNAL_SEARCH_TERM")
								}

								testObjMap["_EXTERNAL"] = validationutils.DeepCloneJSON(input.ExternalData)

								attr := validationutils.GetJsonPath(testObjMap, "$.message.intent.tags[?(@.code=='bnp_demand_signal')].list[?(@.code=='search_term')].value", true)
								validationutils.UnusedFunction(attr)

								skipCheck := !(validationutils.ArePresent(attr))
								if skipCheck {
									continue
								}

								validate := validationutils.ArePresent(attr)

								configureDebugInfo = `{"_NAME_":"TAGS_BNP_DEMAND_SIGNAL_SEARCH_TERM","attr":"$.message.intent.tags[?(@.code=='bnp_demand_signal')].list[?(@.code=='search_term')].value","_CONTINUE_":"!(attr are present)","_RETURN_":"attr are present"}`

								if !validate {
									result := validationutils.ValidationOutput{
										TestName: "TAGS_BNP_DEMAND_SIGNAL_SEARCH_TERM",
										Valid:    false,
										Code:     30000,
										Description: `#### **TAGS_BNP_DEMAND_SIGNAL_SEARCH_TERM**

- $.message.intent.tags[?(@.code=='bnp_demand_signal')].list[?(@.code=='search_term')].value must be present in the payload

> **Skip if:**
>
>     - $.message.intent.tags[?(@.code=='bnp_demand_signal')].list[?(@.code=='search_term')].value is not in the payload`,
										DebugInfo: &validationutils.DebugInfo{
											FedConfig: configureDebugInfo,
										},
									}
									delete(testObjMap, "_EXTERNAL")
									return []validationutils.ValidationOutput{result}, nil
								}

								delete(testObjMap, "_EXTERNAL")
							}

							result := validationutils.ValidationOutput{
								TestName: "TAGS_BNP_DEMAND_SIGNAL_SEARCH_TERM",
								Valid:    valid,
								Code:     0,
								DebugInfo: &validationutils.DebugInfo{
									FedConfig: configureDebugInfo,
								},
							}

							if valid {
								result.Code = 200
							} else {
								result.Code = 30000
							}

							results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
							results = append(results, result)
							results = append(results, subResults...)

							return results, nil
						}

						var testFunctions = validationutils.TestFunctionArray{
							TAGS_BAP_PROMOS_VALID_ENUMS,
							TAGS_BNP_DEMAND_SIGNAL_SEARCH_TERM,
						}

						allResults := make([]validationutils.ValidationOutput, 0)

						for _, testFunc := range testFunctions {
							results, err := testFunc(input)
							if err != nil {
								return nil, err
							}
							allResults = append(allResults, results...)
						}

						subResults = allResults
						// if all subResults are valid, then valid is true
						valid = true
						for _, res := range subResults {
							if !res.Valid {
								valid = false
								break
							}
						}

						configureDebugInfo = `NESTED_TEST_OBJECT`

						delete(testObjMap, "_EXTERNAL")
					}

					result := validationutils.ValidationOutput{
						TestName: "TAGS_BNP_DEMAND_SIGNAL",
						Valid:    valid,
						Code:     0,
						DebugInfo: &validationutils.DebugInfo{
							FedConfig: configureDebugInfo,
						},
					}

					if valid {
						result.Code = 200
					} else {
						result.Code = 30000
					}

					results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
					results = append(results, result)
					results = append(results, subResults...)

					return results, nil
				}

				var testFunctions = validationutils.TestFunctionArray{
					SEARCH_TAG_VALID_TAGS,
					TAGS_BNP_FEATURES,
					TAGS_BAP_TERMS,
					TAGS_CATALOG_FULL,
					TAGS_CATALOG_INC,
					TAGS_BAP_FEATURES,
					TAGS_BAP_PROMOS,
					TAGS_BNP_DEMAND_SIGNAL,
				}

				allResults := make([]validationutils.ValidationOutput, 0)

				for _, testFunc := range testFunctions {
					results, err := testFunc(input)
					if err != nil {
						return nil, err
					}
					allResults = append(allResults, results...)
				}

				subResults = allResults
				// if all subResults are valid, then valid is true
				valid = true
				for _, res := range subResults {
					if !res.Valid {
						valid = false
						break
					}
				}

				configureDebugInfo = `NESTED_TEST_OBJECT`

				delete(testObjMap, "_EXTERNAL")
			}

			result := validationutils.ValidationOutput{
				TestName: "SEARCH_TAGS",
				Valid:    valid,
				Code:     0,
				DebugInfo: &validationutils.DebugInfo{
					FedConfig: configureDebugInfo,
				},
			}

			if valid {
				result.Code = 200
			} else {
				result.Code = 30000
			}

			results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
			results = append(results, result)
			results = append(results, subResults...)

			return results, nil
		}

		var testFunctions = validationutils.TestFunctionArray{
			SEARCH_CONTEXT,
			SEARCH_PAYMENT,
			SEARCH_TAGS,
		}

		allResults := make([]validationutils.ValidationOutput, 0)

		for _, testFunc := range testFunctions {
			results, err := testFunc(input)
			if err != nil {
				return nil, err
			}
			allResults = append(allResults, results...)
		}

		subResults = allResults
		// if all subResults are valid, then valid is true
		valid = true
		for _, res := range subResults {
			if !res.Valid {
				valid = false
				break
			}
		}

		configureDebugInfo = `NESTED_TEST_OBJECT`

		delete(testObjMap, "_EXTERNAL")
	}

	result := validationutils.ValidationOutput{
		TestName: "SearchValidations",
		Valid:    valid,
		Code:     0,
		DebugInfo: &validationutils.DebugInfo{
			FedConfig: configureDebugInfo,
		},
	}

	if valid {
		result.Code = 200
	} else {
		result.Code = 30000
	}

	results := make([]validationutils.ValidationOutput, 0, len(subResults)+1)
	results = append(results, result)
	results = append(results, subResults...)

	return results, nil
}
